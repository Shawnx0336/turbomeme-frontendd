<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DegenJack</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset and Body Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: #111; /* Dark background */
            color: #eee;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            height: 100vh; /* Full viewport height */
            /* Ensure full coverage on mobile */
            width: 100%;
            box-sizing: border-box;
        }

        /* Custom Scrollbar for Chat */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Layout Zones */
        #top-bar {
            flex-shrink: 0; /* Prevent shrinking */
            background-color: #0a0a0a; /* Slightly darker */
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #222;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
        }

        #game-table {
            flex-grow: 1; /* Take available space */
            background-color: #1a1a1a; /* Middle dark */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
            overflow: hidden; /* Prevent game table content from causing scroll */
        }

        #bottom-bar {
            flex-shrink: 0; /* Prevent shrinking */
            background-color: #0a0a0a; /* Slightly darker */
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #222;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
        }

        /* Top Bar Styles */
        .wallet-info, .xp-progress, .recent-plays {
            display: flex;
            align-items: center;
        }

        .wallet-info span {
            margin-right: 10px;
        }

        .xp-bar-container {
            width: 150px;
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 0 10px;
        }

        .xp-bar-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background: linear-gradient(90deg, #8b5cf6, #e879f9); /* Purple gradient */
            transition: width 0.5s ease-in-out;
        }

        .recent-plays-ticker {
            width: 200px;
            overflow: hidden;
            white-space: nowrap;
            font-style: italic;
            color: #aaa;
            font-size: 0.8em;
        }

        .recent-play-item {
            margin-right: 15px;
            display: inline-block;
        }

        .win { color: #10b981; /* Green */ }
        .loss { color: #ef4444; /* Red */ }

        .menu-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            fill: #eee;
        }

        /* Game Table Styles */
        .dealer-hand, .player-hand {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .card {
            width: 60px;
            height: 90px;
            background-color: #fff;
            border-radius: 6px;
            margin: 0 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card-back {
            background-color: #4a4a4a; /* Dark grey back */
            color: transparent; /* Hide text on back */
             /* Optional: Add a simple pattern or logo on the back */
             background-image: url('/assets/card_back.png'); /* Placeholder */
             background-size: cover;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .player-seats {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .player-seat {
            width: 150px;
            margin: 0 10px;
            padding: 10px;
            background-color: #2a2a2a;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid transparent;
            transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }

        .player-seat.active {
            border-color: #a78bfa; /* Purple glow */
            box-shadow: 0 0 10px #a78bfa;
        }

        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .avatar {
            width: 30px;
            height: 30px;
            background-color: #5b21b6; /* Violet */
            border-radius: 50%;
            margin-right: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
        }

        .username {
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
        }

        .xp-badge {
            background-color: #facc15; /* Yellow */
            color: #333;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
        }

        .action-buttons {
            margin-top: 10px;
        }

        .action-buttons button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            min-width: 44px; /* Ensure touch target size */
            min-height: 44px;
        }

        .action-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .hit-button {
            background-color: #10b981; /* Green */
            color: #0a0a0a;
            margin-right: 5px;
        }

        .hit-button:hover:not(:disabled) {
            background-color: #059669;
            box-shadow: 0 0 8px #10b981;
        }

        .stand-button {
            background-color: #ec4899; /* Pink */
            color: #0a0a0a;
        }

        .stand-button:hover:not(:disabled) {
            background-color: #db2777;
            box-shadow: 0 0 8px #ec4899;
        }

        .turn-timer-bar {
            width: 100%;
            height: 3px;
            background-color: #333;
            margin-top: 5px;
            border-radius: 2px;
            overflow: hidden;
        }

        .turn-timer-fill {
            height: 100%;
            width: 100%; /* Initial width */
            background-color: #3b82f6; /* Blue */
            transition: width linear; /* Transition handled by JS */
        }

        /* Hot Streak Placeholder */
        .hot-streak-bar {
            width: 80%;
            height: 5px;
            background-color: #333;
            border-radius: 2.5px;
            margin-top: 5px;
            overflow: hidden;
        }

        .hot-streak-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #facc15, #ef4444); /* Yellow to Red */
            transition: width 0.3s ease-in-out;
        }

        /* Near Miss Placeholder */
        .near-miss-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 0, 0.8); /* Yellowish semi-transparent */
            color: #333;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Don't block clicks */
        }

        .near-miss-popup.show {
            opacity: 1;
        }


        /* Bottom Bar Styles */
        .betting-controls {
            display: flex;
            align-items: center;
        }

        .betting-controls input[type="range"] {
            width: 150px;
            margin: 0 10px;
            accent-color: #10b981; /* Green accent */
        }

        .quick-bet-buttons button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background-color: #333;
            color: #eee;
            cursor: pointer;
            font-size: 0.8em;
            margin-right: 5px;
            transition: background-color 0.3s ease-in-out;
            min-width: 44px; /* Ensure touch target size */
            min-height: 44px;
        }

        .quick-bet-buttons button:hover {
            background-color: #555;
        }

        .join-leave-button {
             padding: 8px 15px;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 0.9em;
             font-weight: bold;
             transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
             margin-left: 20px;
             min-width: 44px; /* Ensure touch target size */
             min-height: 44px;
         }

         .join-button {
            background-color: #10b981; /* Green */
            color: #0a0a0a;
         }

         .join-button:hover {
            background-color: #059669;
            box-shadow: 0 0 8px #10b981;
         }

         .leave-button {
            background-color: #ef4444; /* Red */
            color: #0a0a0a;
         }

         .leave-button:hover {
            background-color: #d92d2d;
            box-shadow: 0 0 8px #ef4444;
         }

        .chat-container {
            width: 300px;
            height: 120px;
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .chat-feed {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.8em;
            color: #bbb;
            margin-bottom: 5px;
        }

        .chat-message {
            margin-bottom: 3px;
        }

        .chat-sender {
            font-weight: bold;
            color: #60a5fa; /* Blue */
            margin-right: 5px;
        }

         .chat-badge {
             color: #facc15; /* Yellow */
             margin-right: 5px;
         }

        .chat-input-area {
            display: flex;
        }

        .chat-input-area input[type="text"] {
            flex-grow: 1;
            padding: 5px 10px;
            border: none;
            border-radius: 4px 0 0 4px;
            background-color: #333;
            color: #eee;
            font-size: 0.9em; /* Adjust for mobile keyboard */
            outline: none;
             min-height: 34px; /* Adjust for touch */
        }

        .chat-input-area button {
            padding: 5px 10px;
            border: none;
            border-radius: 0 4px 44px 0;
            background-color: #3b82f6; /* Blue */
            color: #fff;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease-in-out;
            min-width: 44px; /* Ensure touch target size */
            min-height: 44px;
        }

        .chat-input-area button:hover {
            background-color: #2563eb;
        }

        /* Crate Animation Placeholder */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        .crate-icon {
            width: 30px;
            height: 30px;
            fill: #facc15; /* Yellow */
            cursor: pointer;
            animation: bounce 1s infinite;
            margin-left: 10px;
        }

        /* Placeholder for Confetti Canvas */
        #confetti-canvas {
            position: fixed; /* Use fixed for full viewport coverage */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks through */
            z-index: 10; /* Above game elements */
        }

        /* Hot Table Banner Placeholder */
        #hot-table-banner {
            position: fixed;
            top: 60px; /* Below top bar */
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff6bec; /* Pink accent */
            color: #0a0a0a;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 15;
            display: none; /* Hidden by default */
            box-shadow: 0 0 10px #ff6bec;
        }

         /* Next Hand Button Placeholder */
         #next-hand-button {
             position: absolute;
             bottom: 150px; /* Above bottom bar */
             left: 50%;
             transform: translateX(-50%);
             padding: 12px 25px;
             border: none;
             border-radius: 8px;
             background-color: #10b981; /* Green */
             color: #0a0a0a;
             font-size: 1.1em;
             font-weight: bold;
             cursor: pointer;
             z-index: 15;
             display: none; /* Hidden by default */
             box-shadow: 0 0 15px #10b981;
             transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
         }

         #next-hand-button:hover {
             background-color: #059669;
             box-shadow: 0 0 20px #059669;
         }


        /* Mobile Specific Styles */
        @media (max-width: 768px) {
            body {
                font-size: 16px;
            }

            #top-bar {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
                height: auto;
            }

            .wallet-info, .xp-progress, .recent-plays {
                width: 100%;
                justify-content: space-between;
                margin-bottom: 8px;
            }

            .xp-bar-container {
                flex-grow: 1; /* Allow XP bar to take available space */
                margin: 0 8px;
            }

            .recent-plays-ticker {
                width: 120px; /* Smaller width on mobile */
                font-size: 0.7em;
            }

            #game-table {
                padding: 10px;
                justify-content: flex-start; /* Align items to top */
            }

            .dealer-hand {
                margin-bottom: 10px;
            }

            .card {
                width: 45px; /* Smaller cards on mobile */
                height: 67.5px;
                margin: 0 3px;
                font-size: 1em;
            }

            .player-seats {
                flex-direction: column; /* Stack players vertically */
                align-items: center;
            }

            .player-seat {
                width: 95%; /* Nearly full width */
                margin: 5px 0;
                padding: 8px;
            }

            .player-info {
                width: 100%;
                justify-content: center;
                margin-bottom: 8px;
            }

            .action-buttons {
                margin-top: 8px;
            }

            .action-buttons button {
                padding: 10px 20px; /* Larger touch targets */
                font-size: 1em;
            }

            #bottom-bar {
                flex-direction: column;
                align-items: center;
                height: auto;
                padding: 10px;
            }

            .betting-controls {
                width: 100%;
                flex-direction: column;
                align-items: center;
                margin-bottom: 10px;
            }

            .betting-controls > span, .betting-controls input[type="range"], .quick-bet-buttons {
                margin-bottom: 8px;
            }

            .betting-controls input[type="range"] {
                width: 80%; /* Adjust slider width */
                margin: 8px 0;
            }

            .quick-bet-buttons {
                 width: 100%;
                 justify-content: center;
            }

            .quick-bet-buttons button {
                 flex-grow: 1; /* Distribute space */
                 margin: 0 4px;
                 padding: 10px 5px; /* Adjust padding */
            }

            .join-leave-button {
                margin-left: 0; /* Remove left margin */
                width: 100%; /* Full width button */
                padding: 12px 20px; /* Larger touch target */
            }

            .chat-container {
                width: 100%; /* Full width */
                height: 200px; /* Initial smaller height */
                position: fixed; /* Position fixed for slide-up */
                bottom: 0;
                left: 0;
                border-radius: 8px 8px 0 0;
                transform: translateY(100%); /* Initially hidden below screen */
                transition: transform 0.3s ease-in-out;
                z-index: 20; /* Above other content */
                box-sizing: border-box;
                 padding-bottom: 50px; /* Space for input */
            }

            .chat-container.active {
                transform: translateY(0); /* Slide up */
                 height: 50vh; /* Take up half viewport height */
            }

             .chat-feed {
                 height: calc(100% - 40px); /* Adjust height based on input area */
                 margin-bottom: 0;
             }

            .chat-input-area {
                position: absolute; /* Position relative to chat container */
                bottom: 0;
                left: 0;
                width: 100%;
                padding: 5px;
                background-color: #1a1a1a; /* Match chat container background */
                box-sizing: border-box;
            }

             .chat-input-area input[type="text"] {
                 font-size: 1em; /* Standard font size */
                 min-height: 44px; /* Ensure touch target size */
             }

             .chat-input-area button {
                 min-height: 44px; /* Ensure touch target size */
             }


            #toggle-chat {
                display: block; /* Show toggle button on mobile */
                padding: 8px 15px;
                border: none;
                border-radius: 5px;
                background-color: #3b82f6; /* Blue */
                color: #fff;
                font-weight: bold;
                cursor: pointer;
                margin-top: 10px;
                min-width: 44px; /* Ensure touch target size */
                min-height: 44px;
            }

            .player-seat .player-hand {
                 justify-content: center; /* Center cards in mobile view */
            }

             /* Hide other players' hands by default on mobile */
             .player-seat:not(.is-user) .player-hand {
                 /* display: none; */ /* Option 1: Hide completely */
                 /* Or show face-down cards */
             }

             /* Optional: Button to toggle other players' hands */
             #toggle-other-hands {
                 display: block; /* Show on mobile */
                 margin-top: 10px;
                 padding: 8px 15px;
                 border: none;
                 border-radius: 5px;
                 background-color: #555;
                 color: #eee;
                 cursor: pointer;
             }
        }

        /* Hide toggle button on desktop */
        #toggle-chat, #toggle-other-hands {
            display: none;
        }

    </style>
</head>
<body>

    <div id="top-bar">
        <div class="wallet-info">
            <span id="wallet-address">Not Connected</span>
            <span id="wallet-balance">-- SOL</span>
            <button id="connect-wallet-button">Connect Wallet</button>
            <button id="disconnect-wallet-button" style="display: none;">Disconnect</button>
             <a id="phantom-deeplink" href="#" style="display: none; color: #a78bfa; font-size: 0.8em; margin-left: 10px;">Open in Phantom App</a>
             <span id="wallet-guidance" style="display: none; color: #facc15; font-size: 0.8em; margin-left: 10px;"></span>
        </div>
        <div class="xp-progress">
            <span id="user-level">Level 1</span>
            <div class="xp-bar-container">
                <div id="xp-bar-fill" class="xp-bar-fill"></div>
            </div>
            <span id="user-xp">0/100 XP</span>
            <svg id="crate-icon" class="crate-icon" style="display: none;" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M7.293 2.293a1 1 0 011.414 0L10 3.586l1.293-1.293a1 1 0 111.414 1.414L11.414 5l1.293 1.293a1 1 0 11-1.414 1.414L10 6.414l-1.293 1.293a1 1 0 01-1.414-1.414L8.586 5l-1.293-1.293a1 1 0 010-1.414zM10 14a1 1 0 100-2 1 1 0 000 2zm0 4a1 1 0 100-2 1 1 0 000 2zM5 10a1 1 0 11-2 0 1 1 0 012 0zm10 0a1 1 0 11-2 0 1 1 0 012 0z" clip-rule="evenodd"></path>
            </svg>
        </div>
        <div class="recent-plays">
            <div id="recent-plays-ticker" class="recent-plays-ticker">
                <span>No recent plays...</span>
            </div>
             <div id="leaderboard" style="font-size: 0.8em; margin-left: 10px;">
                 </div>
            <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
            <div id="settings-dropdown" style="display: none; position: absolute; top: 50px; right: 20px; background-color: #333; border-radius: 5px; padding: 10px; z-index: 20;">
                Settings content here...
            </div>
        </div>
    </div>

    <div id="game-table">
        <div class="dealer-hand">
            <h3>Dealer</h3>
            <div id="dealer-cards" class="player-hand">
                </div>
        </div>
        <div id="player-seats" class="player-seats">
            </div>
         <div id="hot-table-banner">Hot Table!</div>
         <div id="near-miss-popup" class="near-miss-popup">Almost!</div>
         <div id="hot-streak-bar" class="hot-streak-bar" style="display: none;">
             <div class="hot-streak-fill"></div>
         </div>

         <button id="toggle-other-hands">Show/Hide Other Hands</button>

    </div>

    <div id="bottom-bar">
        <div class="betting-controls">
            <span id="current-bet-display">Bet: 0.00 SOL</span>
            <input type="range" id="bet-slider" min="0" max="10" step="0.01" value="0">
            <div class="quick-bet-buttons">
                <button data-bet-amount="0.01">+0.01</button>
                <button data-bet-amount="0.1">+0.1</button>
                <button data-bet-amount="MAX">MAX</button>
            </div>
            <button id="join-leave-button" class="join-leave-button join-button">Join Table</button>
             <span id="spectator-status" style="display: none; color: #facc15; font-size: 0.9em; margin-left: 10px;">You are a spectator.</span>
             <button id="refer-friends-button" style="margin-left: 10px; padding: 8px 15px; border: none; border-radius: 5px; background-color: #5b21b6; color: #fff; font-weight: bold; cursor: pointer;">Refer Friends</button>
        </div>
        <div class="chat-container">
            <div id="chat-feed" class="chat-feed custom-scrollbar">
                </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type message...">
                <button id="send-chat-button">Send</button>
            </div>
        </div>
         <button id="toggle-chat">Chat</button>
         <button id="next-hand-button">Next Hand?</button>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <audio id="card-deal-sound" src="/assets/sounds/card-deal.mp3" preload="auto"></audio> <audio id="win-sound" src="/assets/sounds/win.mp3" preload="auto"></audio> <audio id="loss-sound" src="/assets/sounds/loss.mp3" preload="auto"></audio> <audio id="button-click-sound" src="/assets/sounds/button-click.mp3" preload="auto"></audio> <script>
        // --- Global State ---
        const gameState = {
            walletAddress: null,
            walletBalance: 0,
            userXP: parseInt(localStorage.getItem('userXP') || '0'), // Load from localStorage
            userLevel: parseInt(localStorage.getItem('userLevel') || '1'), // Load from localStorage
            dealerHand: [],
            players: [], // Array of player objects { id, name, level, avatar, hand, isUser, timer, hotStreak }
            activePlayerId: null,
            turnTimerDuration: 10, // seconds
            betAmount: 0,
            chatMessages: [], // Array of { sender, message, badge }
            recentPlays: [], // Array of { player, amount, win }
            isSpectator: false,
            isSeated: false,
            websocket: null,
            confettiCanvas: null,
            confettiCtx: null,
            chatVisible: false, // State for mobile chat toggle
            otherHandsVisible: false, // State for mobile other hands toggle
            // Add other state properties as needed
        };

        // --- DOM Elements ---
        const dom = {
            walletAddress: document.getElementById('wallet-address'),
            walletBalance: document.getElementById('wallet-balance'),
            connectWalletButton: document.getElementById('connect-wallet-button'),
            disconnectWalletButton: document.getElementById('disconnect-wallet-button'),
            phantomDeeplink: document.getElementById('phantom-deeplink'),
            walletGuidance: document.getElementById('wallet-guidance'),
            userLevel: document.getElementById('user-level'),
            xpBarFill: document.getElementById('xp-bar-fill'),
            userXP: document.getElementById('user-xp'),
            crateIcon: document.getElementById('crate-icon'),
            recentPlaysTicker: document.getElementById('recent-plays-ticker'),
            leaderboard: document.getElementById('leaderboard'), // New
            settingsDropdown: document.getElementById('settings-dropdown'), // Placeholder
            dealerCards: document.getElementById('dealer-cards'),
            playerSeats: document.getElementById('player-seats'),
            hotTableBanner: document.getElementById('hot-table-banner'), // New
            nearMissPopup: document.getElementById('near-miss-popup'), // New
            hotStreakBar: document.getElementById('hot-streak-bar'), // New
            toggleOtherHandsButton: document.getElementById('toggle-other-hands'), // New
            currentBetDisplay: document.getElementById('current-bet-display'),
            betSlider: document.getElementById('bet-slider'),
            quickBetButtons: document.querySelectorAll('.quick-bet-buttons button'),
            joinLeaveButton: document.getElementById('join-leave-button'),
            spectatorStatus: document.getElementById('spectator-status'),
            referFriendsButton: document.getElementById('refer-friends-button'), // New
            chatContainer: document.querySelector('.chat-container'), // New
            chatFeed: document.getElementById('chat-feed'),
            chatInput: document.getElementById('chat-input'),
            sendChatButton: document.getElementById('send-chat-button'),
            toggleChatButton: document.getElementById('toggle-chat'), // New
            nextHandButton: document.getElementById('next-hand-button'), // New
            confettiCanvas: document.getElementById('confetti-canvas'),
            // Audio Elements
            cardDealSound: document.getElementById('card-deal-sound'),
            winSound: document.getElementById('win-sound'),
            lossSound: document.getElementById('loss-sound'),
            buttonClickSound: document.getElementById('button-click-sound'),
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Confetti Canvas
            dom.confettiCtx = dom.confettiCanvas.getContext('2d');
            resizeCanvas(); // Set initial size
            window.addEventListener('resize', resizeCanvas); // Resize on window resize

            // Set initial UI state
            updateUI();

            // Setup Event Listeners
            setupEventListeners();

            // Attempt to auto-connect wallet
            checkAutoConnectWallet();

            // Connect to WebSocket
            connectWebSocket();

            // Check for Daily Reward
            checkForDailyReward();

            // Placeholder: Simulate some initial game state for testing UI layout
            simulateInitialGameState();
        });

        // Resize Canvas function
        function resizeCanvas() {
            dom.confettiCanvas.width = window.innerWidth;
            dom.confettiCanvas.height = window.innerHeight;
        }


        // --- Solana Wallet Integration (using window.solana) ---
        async function checkAutoConnectWallet() {
             const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);

            if (window.solana && window.solana.isConnected) {
                try {
                    // Attempt to connect silently if already authorized
                    await window.solana.connect({ onlyIfTrusted: true });
                    handleWalletConnected(window.solana.publicKey);
                } catch (error) {
                    console.error('Auto-connect failed:', error);
                     if (isIOS) {
                         showPhantomDeeplink();
                     } else {
                         showWalletGuidance('Please install Phantom wallet.');
                     }
                }
            } else if (isIOS) {
                 showPhantomDeeplink();
            } else {
                 showWalletGuidance('Please install Phantom wallet or another Solana wallet.');
            }
        }

        async function connectWallet() {
             const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);

            if (window.solana) {
                try {
                    const response = await window.solana.connect();
                    handleWalletConnected(response.publicKey);
                } catch (error) {
                    console.error('Wallet connection failed:', error);
                     if (isIOS) {
                         showPhantomDeeplink();
                     } else {
                         showWalletGuidance('Wallet connection failed. Please try again or install Phantom.');
                     }
                }
            } else {
                 if (isIOS) {
                     showPhantomDeeplink();
                 } else {
                     showWalletGuidance('Solana wallet not found! Please install Phantom, Backpack, Solflare, or Coinbase wallet.');
                 }
            }
        }

        async function disconnectWallet() {
            if (window.solana && window.solana.isConnected) {
                try {
                    await window.solana.disconnect();
                    handleWalletDisconnected();
                } catch (error) {
                    console.error('Wallet disconnection failed:', error);
                }
            }
        }

        function handleWalletConnected(publicKey) {
            gameState.walletAddress = publicKey.toBase58();
            dom.walletAddress.textContent = `${gameState.walletAddress.slice(0, 4)}...${gameState.walletAddress.slice(-4)}`;
            dom.connectWalletButton.style.display = 'none';
            dom.disconnectWalletButton.style.display = 'inline-block';
            dom.phantomDeeplink.style.display = 'none';
            dom.walletGuidance.style.display = 'none';
            // Placeholder: Fetch balance (requires more web3.js interaction)
            fetchWalletBalance(publicKey);
            updateUI(); // Update UI based on connected state
        }

        function handleWalletDisconnected() {
            gameState.walletAddress = null;
            gameState.walletBalance = 0;
            dom.walletAddress.textContent = 'Not Connected';
            dom.walletBalance.textContent = '-- SOL';
            dom.connectWalletButton.style.display = 'inline-block';
            dom.disconnectWalletButton.style.display = 'none';
             dom.phantomDeeplink.style.display = 'none'; // Hide deeplink on disconnect
             dom.walletGuidance.style.display = 'none'; // Hide guidance on disconnect
            updateUI(); // Update UI based on disconnected state
        }

        async function fetchWalletBalance(publicKey) {
             // Placeholder: In a real app, use Solana Web3.js Connection object
             // Example:
             // const connection = new Connection(Solana.Web3.clusterApiUrl('devnet'), 'confirmed');
             // const balance = await connection.getBalance(publicKey);
             // gameState.walletBalance = balance / 10**9; // Convert lamports to SOL
             // dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;

             // Simulate fetching balance
             setTimeout(() => {
                 gameState.walletBalance = Math.random() * 5 + 1; // Random balance between 1 and 6
                 dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;
             }, 500);
         }

         function showPhantomDeeplink() {
             const currentUrl = window.location.href;
             // IMPORTANT: Replace with your actual game URL
             const deeplinkUrl = `https://phantom.app/ul/v1/browse?url=${encodeURIComponent(currentUrl)}`;
             dom.phantomDeeplink.href = deeplinkUrl;
             dom.phantomDeeplink.style.display = 'inline-block';
             dom.walletGuidance.style.display = 'inline-block';
             dom.walletGuidance.textContent = 'For iOS, use Phantom\'s in-app browser:';
             dom.connectWalletButton.style.display = 'none'; // Hide connect button if deeplink shown
         }

         function showWalletGuidance(message) {
             dom.walletGuidance.textContent = message;
             dom.walletGuidance.style.display = 'inline-block';
             dom.phantomDeeplink.style.display = 'none';
         }


        // --- WebSocket Integration ---
        function connectWebSocket() {
            // Replace with your actual WebSocket server URL
            const wsUrl = "wss://your-game-server-url";
            gameState.websocket = new WebSocket(wsUrl);

            gameState.websocket.onopen = () => {
                console.log("WebSocket Connected");
                // Send initial message, e.g., join game, if wallet is connected
                if (gameState.walletAddress) {
                     sendMessage({ type: 'joinGame', wallet: gameState.walletAddress });
                } else {
                     // Maybe join as spectator if not connected? Depends on backend logic.
                     sendMessage({ type: 'joinGameAsSpectator' });
                }
            };

            gameState.websocket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                console.log("WebSocket Message:", msg);
                handleGameEvent(msg);
            };

            gameState.websocket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                // Handle errors, attempt reconnect
            };

            gameState.websocket.onclose = () => {
                console.log("WebSocket Disconnected");
                // Handle disconnection, attempt reconnect
            };
        }

        function sendMessage(message) {
            if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                gameState.websocket.send(JSON.stringify(message));
            } else {
                console.warn("WebSocket not connected. Cannot send message:", message);
                // Maybe queue messages or try to reconnect
            }
        }

        // Handle incoming WebSocket messages
        function handleGameEvent(msg) {
            switch (msg.type) {
                case 'table_state':
                    // Update entire table state
                    gameState.players = msg.data.players;
                    gameState.dealerHand = msg.data.dealerHand;
                    gameState.activePlayerId = msg.data.activePlayerId;
                    gameState.isSpectator = msg.data.isSpectator;
                    gameState.isSeated = msg.data.isSeated; // Assuming backend sends this
                    updateUI();
                    break;
                case 'card_dealt':
                    // Add card to specific player or dealer hand
                    // msg.data should contain { playerId, card } or { target: 'dealer', card }
                    if (msg.data.target === 'dealer') {
                        gameState.dealerHand.push(msg.data.card);
                        renderDealerHand();
                    } else {
                        const player = gameState.players.find(p => p.id === msg.data.playerId);
                        if (player) {
                            player.hand.push(msg.data.card);
                            renderPlayerSeats(); // Re-render all seats for simplicity
                        }
                    }
                    playSound(dom.cardDealSound); // Play card deal sound
                    break;
                case 'turn_changed':
                    gameState.activePlayerId = msg.data.playerId;
                    // Start or reset turn timer animation
                    startTurnTimer(msg.data.duration || gameState.turnTimerDuration);
                    renderPlayerSeats(); // Update active player highlight
                    break;
                case 'round_end':
                    // Handle round end logic (reveal dealer cards, show results)
                    gameState.dealerHand = msg.data.dealerHand; // Full dealer hand revealed
                    // Update player results (win/loss status)
                    // msg.data might contain results for each player
                    updateUI(); // Update all relevant UI elements

                    // Trigger confetti or other win/loss animations
                    if (msg.data.userWon) {
                         triggerConfetti();
                         playSound(dom.winSound); // Play win sound
                         triggerHaptic([100, 50, 100]); // Win haptic
                    } else if (msg.data.userLost) {
                         playSound(dom.lossSound); // Play loss sound
                         triggerHaptic([200]); // Loss haptic
                    }

                     // Show "Next Hand?" button
                     showNextHandButton();
                    break;
                case 'xp_update':
                    // Update user XP and level
                    gameState.userXP = msg.data.newXP;
                    gameState.userLevel = msg.data.newLevel;
                    localStorage.setItem('userXP', gameState.userXP); // Persist XP
                    localStorage.setItem('userLevel', gameState.userLevel); // Persist Level
                    updateXPBar();
                    if (msg.data.levelUp) {
                        showCrateIcon();
                    }
                    break;
                case 'crate_awarded':
                    // Trigger crate animation/display
                    showCrateIcon();
                    break;
                case 'chat_message':
                    // Add new chat message
                    gameState.chatMessages.push(msg.data);
                    addChatMessageToFeed(msg.data);
                    break;
                case 'recent_play':
                    // Add new recent play to the ticker
                    gameState.recentPlays.unshift(msg.data); // Add to the beginning
                    // Keep ticker length reasonable
                    if (gameState.recentPlays.length > 10) {
                        gameState.recentPlays.pop();
                    }
                    updateRecentPlaysTicker();
                    break;
                 case 'hot_table':
                     // Show/hide hot table banner
                     if (msg.data.isActive) {
                         dom.hotTableBanner.style.display = 'block';
                     } else {
                         dom.hotTableBanner.style.display = 'none';
                     }
                     break;
                 case 'near_miss':
                     // Trigger near miss animation
                     showNearMissPopup(msg.data.message || 'Almost!');
                     break;
                 case 'hot_streak_update':
                     // Update hot streak bar
                     updateHotStreakBar(msg.data.streakCount);
                     break;
                 case 'leaderboard_update':
                     // Update leaderboard
                     updateLeaderboard(msg.data.leaderboard);
                     break;
                 case 'mystery_event':
                     // Handle mystery event (e.g., Bonus Round)
                     showMysteryEvent(msg.data);
                     break;
                // Handle other event types as needed
                default:
                    console.warn("Unknown WebSocket message type:", msg.type);
            }
        }

        // --- UI Rendering Functions ---

        function updateUI() {
            // Update wallet info (already done in handleWalletConnected/Disconnected)
            // Update XP bar and level
            updateXPBar();
            // Update recent plays ticker
            updateRecentPlaysTicker();
            // Render game table elements
            renderDealerHand();
            renderPlayerSeats();
            // Update betting controls and join/leave button
            updateBettingControls();
            // Render chat messages (initial load)
            renderChatFeed();
             // Update chat container visibility based on state
             updateChatContainerVisibility();
             // Update other players hands visibility based on state
             updateOtherHandsVisibility();
             // Update leaderboard
             updateLeaderboard(gameState.leaderboard || []); // Pass current leaderboard state
        }

        function updateXPBar() {
            dom.userLevel.textContent = `Level ${gameState.userLevel}`;
            const xpProgress = gameState.userXP % 100; // Assuming 100 XP per level
            dom.xpBarFill.style.width = `${xpProgress}%`;
            dom.userXP.textContent = `${xpProgress}/100 XP`;
        }

        function showCrateIcon() {
            dom.crateIcon.style.display = 'inline-block';
            // Add logic for crate opening animation on click
            dom.crateIcon.onclick = openCrate; // Assign click handler
        }

        function openCrate() {
             console.log("Crate opened!");
             // Placeholder: Implement crate opening animation (Canvas or image sequence)
             // For now, just hide the icon
             dom.crateIcon.style.display = 'none';
             // Placeholder: Show crate contents (inline, no popup)
             // Maybe a temporary text display or simple animation near the icon
             alert("You got a reward!"); // Replace with inline display
        }


        function updateRecentPlaysTicker() {
            dom.recentPlaysTicker.innerHTML = ''; // Clear current ticker
            if (gameState.recentPlays.length === 0) {
                dom.recentPlaysTicker.textContent = 'No recent plays...';
                return;
            }
            gameState.recentPlays.forEach(play => {
                const span = document.createElement('span');
                span.classList.add('recent-play-item', play.win ? 'win' : 'loss');
                span.textContent = `${play.player}: ${play.win ? '+' : '-'}${play.amount.toFixed(2)} SOL`;
                dom.recentPlaysTicker.appendChild(span);
            });
            // Implement smooth scrolling animation for the ticker if needed
        }

        function updateLeaderboard(leaderboardData) {
             dom.leaderboard.innerHTML = ''; // Clear current leaderboard
             if (leaderboardData.length === 0) {
                 dom.leaderboard.textContent = 'Leaderboard: --';
                 return;
             }
             const leaderboardTitle = document.createElement('span');
             leaderboardTitle.textContent = 'Leaderboard: ';
             leaderboardTitle.style.fontWeight = 'bold';
             dom.leaderboard.appendChild(leaderboardTitle);

             leaderboardData.forEach((entry, index) => {
                 const entrySpan = document.createElement('span');
                 entrySpan.textContent = `${index + 1}. ${entry.player}: ${entry.wins} Wins | `;
                 dom.leaderboard.appendChild(entrySpan);
             });
        }


        function renderDealerHand() {
            dom.dealerCards.innerHTML = ''; // Clear current cards
             if (gameState.dealerHand.length === 0) {
                  const placeholder = document.createElement('div');
                  placeholder.classList.add('card', 'card-back');
                  dom.dealerCards.appendChild(placeholder);
                  return;
             }
            gameState.dealerHand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                 // For the first card, show back initially if not revealed
                 if (index === 0 && !card.revealed) { // Assuming a 'revealed' property on card objects
                      cardElement.classList.add('card-back');
                 } else {
                     cardElement.textContent = `${card.value}${card.suit}`; // Placeholder text
                     // In a real app, use an image: cardElement.style.backgroundImage = `url('/assets/cards/${card.value}_${card.suit}.png')`;
                     // cardElement.style.backgroundSize = 'cover';
                     // cardElement.style.color = 'transparent'; // Hide text if using image
                 }
                // Add card flip animation class if needed (e.g., if card.justDealt)
                // if (card.justDealt) { cardElement.classList.add('flipped'); }
                dom.dealerCards.appendChild(cardElement);
            });
        }

        function renderPlayerSeats() {
            dom.playerSeats.innerHTML = ''; // Clear current seats
            const isMobile = window.innerWidth <= 768;

            gameState.players.forEach(player => {
                const seatElement = document.createElement('div');
                seatElement.classList.add('player-seat');
                 if (player.id === gameState.walletAddress) {
                     seatElement.classList.add('is-user'); // Mark the user's seat
                 }
                if (player.id === gameState.activePlayerId) {
                    seatElement.classList.add('active');
                }

                // Player Info
                const playerInfo = document.createElement('div');
                playerInfo.classList.add('player-info');
                const avatar = document.createElement('div');
                avatar.classList.add('avatar');
                avatar.textContent = player.avatar || 'ðŸ˜Š'; // Placeholder avatar
                const username = document.createElement('span');
                username.classList.add('username');
                username.textContent = player.name || 'Player';
                const xpBadge = document.createElement('span');
                xpBadge.classList.add('xp-badge');
                xpBadge.textContent = player.level || 1;
                playerInfo.appendChild(avatar);
                playerInfo.appendChild(username);
                playerInfo.appendChild(xpBadge);
                seatElement.appendChild(playerInfo);

                // Player Hand
                const playerHand = document.createElement('div');
                playerHand.classList.add('player-hand');
                if (player.hand && player.hand.length > 0) {
                    player.hand.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.classList.add('card');
                         // On mobile, hide other players' cards unless toggled
                         if (isMobile && !player.isUser && !gameState.otherHandsVisible) {
                             cardElement.classList.add('card-back');
                         } else {
                             cardElement.textContent = `${card.value}${card.suit}`; // Placeholder text
                             // In a real app, use an image: cardElement.style.backgroundImage = `url('/assets/cards/${card.value}_${card.suit}.png')`;
                             // cardElement.style.backgroundSize = 'cover';
                             // cardElement.style.color = 'transparent';
                         }
                        playerHand.appendChild(cardElement);
                    });
                } else {
                     const placeholder = document.createElement('div');
                     placeholder.classList.add('card', 'card-back');
                     playerHand.appendChild(placeholder);
                }
                seatElement.appendChild(playerHand);

                // Action Buttons (Hit/Stand)
                const actionButtons = document.createElement('div');
                actionButtons.classList.add('action-buttons');
                actionButtons.style.display = (player.id === gameState.walletAddress && player.id === gameState.activePlayerId && !gameState.isSpectator) ? 'block' : 'none';

                const hitButton = document.createElement('button');
                hitButton.classList.add('hit-button');
                hitButton.textContent = 'Hit';
                hitButton.onclick = () => { sendPlayerAction('hit'); playSound(dom.buttonClickSound); triggerHaptic([50]); }; // Add sound and haptic

                const standButton = document.createElement('button');
                standButton.classList.add('stand-button');
                standButton.textContent = 'Stand';
                standButton.onclick = () => { sendPlayerAction('stand'); playSound(dom.buttonClickSound); triggerHaptic([50]); }; // Add sound and haptic

                actionButtons.appendChild(hitButton);
                actionButtons.appendChild(standButton);
                seatElement.appendChild(actionButtons);

                // Turn Timer Bar
                const timerBar = document.createElement('div');
                timerBar.classList.add('turn-timer-bar');
                timerBar.style.display = (player.id === gameState.activePlayerId) ? 'block' : 'none';
                const timerFill = document.createElement('div');
                timerFill.classList.add('turn-timer-fill');
                 // Timer fill width will be controlled by startTurnTimer function
                timerBar.appendChild(timerFill);
                seatElement.appendChild(timerBar);

                // Hot Streak Bar (Visible only for the user's seat)
                if (player.id === gameState.walletAddress) {
                    const hotStreakBar = document.createElement('div');
                    hotStreakBar.classList.add('hot-streak-bar');
                    hotStreakBar.id = 'user-hot-streak-bar'; // Assign an ID for easy access
                    const hotStreakFill = document.createElement('div');
                    hotStreakFill.classList.add('hot-streak-fill');
                    hotStreakBar.appendChild(hotStreakFill);
                    seatElement.appendChild(hotStreakBar);
                }


                dom.playerSeats.appendChild(seatElement);
            });

             // Add empty seats if less than 5 players
             for (let i = gameState.players.length; i < 5; i++) {
                 const emptySeat = document.createElement('div');
                 emptySeat.classList.add('player-seat');
                 emptySeat.style.backgroundColor = '#333'; // Slightly lighter for empty
                 emptySeat.style.border = '2px dashed #555';
                 emptySeat.innerHTML = `<div style="color: #777; font-size: 0.9em;">Empty Seat</div>`;
                 dom.playerSeats.appendChild(emptySeat);
             }
        }

        function startTurnTimer(duration) {
            const activePlayerSeatFill = document.querySelector('.player-seat.active .turn-timer-fill');
            if (activePlayerSeatFill) {
                // Reset timer animation
                activePlayerSeatFill.style.transition = 'none';
                activePlayerSeatFill.style.width = '100%';
                // Force reflow to apply width: 100% immediately
                activePlayerSeatFill.offsetHeight;
                // Start animation
                activePlayerSeatFill.style.transition = `width ${duration}s linear`;
                activePlayerSeatFill.style.width = '0%';
            }
        }

        function updateHotStreakBar(streakCount) {
             const userHotStreakFill = document.getElementById('user-hot-streak-bar')?.querySelector('.hot-streak-fill');
             if (userHotStreakFill) {
                 // Assuming streakCount is between 0 and some max value (e.g., 5 or 10)
                 // Adjust width calculation based on your max streak logic
                 const maxWidth = 10; // Example max streak before a bonus or reset
                 const widthPercentage = Math.min(streakCount / maxWidth * 100, 100);
                 userHotStreakFill.style.width = `${widthPercentage}%`;
                 userHotStreakFill.parentElement.style.display = streakCount > 0 ? 'block' : 'none'; // Show if streak > 0
             }
        }

        function showNearMissPopup(message) {
            dom.nearMissPopup.textContent = message;
            dom.nearMissPopup.classList.add('show');
            setTimeout(() => {
                dom.nearMissPopup.classList.remove('show');
            }, 1500); // Show for 1.5 seconds
        }


        function updateBettingControls() {
            dom.currentBetDisplay.textContent = `Bet: ${gameState.betAmount.toFixed(2)} SOL`;
            dom.betSlider.value = gameState.betAmount;

            if (gameState.isSeated) {
                dom.joinLeaveButton.textContent = 'Leave Table';
                dom.joinLeaveButton.classList.remove('join-button');
                dom.joinLeaveButton.classList.add('leave-button');
                // Disable betting controls if seated and not active player or spectator
                const disableBetting = gameState.isSeated && !gameState.isSpectator && gameState.activePlayerId !== gameState.walletAddress;
                 dom.betSlider.disabled = disableBetting;
                 dom.quickBetButtons.forEach(button => button.disabled = disableBetting);

            } else {
                dom.joinLeaveButton.textContent = 'Join Table';
                dom.joinLeaveButton.classList.remove('leave-button');
                dom.joinLeaveButton.classList.add('join-button');
                 // Enable betting controls if not seated
                 dom.betSlider.disabled = false;
                 dom.quickBetButtons.forEach(button => button.disabled = false);
            }

            // Show spectator status if applicable
            dom.spectatorStatus.style.display = gameState.isSpectator ? 'inline-block' : 'none';
             // Disable chat input for spectators
             dom.chatInput.disabled = gameState.isSpectator;
             dom.sendChatButton.disabled = gameState.isSpectator;
             dom.chatInput.placeholder = gameState.isSpectator ? "Spectators cannot chat" : "Type message...";
        }

        function renderChatFeed() {
            dom.chatFeed.innerHTML = ''; // Clear current feed
            gameState.chatMessages.forEach(msg => {
                addChatMessageToFeed(msg);
            });
             // Ensure chat container is visible on desktop, hidden on mobile initially
             if (window.innerWidth > 768) {
                 dom.chatContainer.classList.add('active');
                 gameState.chatVisible = true;
             } else {
                 dom.chatContainer.classList.remove('active');
                 gameState.chatVisible = false;
             }
        }

        function addChatMessageToFeed(msg) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message');
            messageElement.innerHTML = `<span class="chat-sender">[${msg.sender}]</span><span class="chat-badge">[${msg.badge}]</span> ${msg.message}`;
            dom.chatFeed.appendChild(messageElement);

             // Limit chat messages to prevent DOM bloat
             const maxChatMessages = 50;
             if (dom.chatFeed.children.length > maxChatMessages) {
                 dom.chatFeed.removeChild(dom.chatFeed.children[0]); // Remove the oldest message
             }

            // Auto-scroll to the bottom
            dom.chatFeed.scrollTop = dom.chatFeed.scrollHeight;
        }

        function updateChatContainerVisibility() {
             if (gameState.chatVisible) {
                 dom.chatContainer.classList.add('active');
             } else {
                 dom.chatContainer.classList.remove('active');
             }
        }

        function updateOtherHandsVisibility() {
             const isMobile = window.innerWidth <= 768;
             if (!isMobile) {
                 // Always show hands on desktop
                 document.querySelectorAll('.player-seat:not(.is-user) .player-hand').forEach(hand => {
                     hand.style.display = 'flex';
                     hand.querySelectorAll('.card').forEach(card => card.classList.remove('card-back'));
                 });
                 dom.toggleOtherHandsButton.style.display = 'none'; // Hide button on desktop
                 return;
             }

             // Mobile logic
             dom.toggleOtherHandsButton.style.display = 'block'; // Show button on mobile

             document.querySelectorAll('.player-seat:not(.is-user)').forEach(seat => {
                 const hand = seat.querySelector('.player-hand');
                 if (gameState.otherHandsVisible) {
                      hand.style.display = 'flex';
                      // Show cards face up (assuming card object has 'revealed' or similar)
                      seat.querySelectorAll('.card').forEach(cardElement => {
                           // In a real app, you'd check if the card is actually revealed by game state
                           // For simulation, just remove the back class
                           cardElement.classList.remove('card-back');
                           // Restore text content if using text placeholders
                           if (cardElement.textContent === '') {
                                // Find the corresponding card in gameState.players and set textContent
                                const playerId = seat.id; // Assuming player seat has ID matching player.id
                                const player = gameState.players.find(p => p.id === playerId);
                                if (player && player.hand.length > Array.from(seat.querySelectorAll('.card')).indexOf(cardElement)) {
                                     const card = player.hand[Array.from(seat.querySelectorAll('.card')).indexOf(cardElement)];
                                     cardElement.textContent = `${card.value}${card.suit}`;
                                }
                           }
                      });
                 } else {
                      hand.style.display = 'flex'; // Keep hand container visible
                      // Show cards face down
                      seat.querySelectorAll('.card').forEach(cardElement => {
                          cardElement.classList.add('card-back');
                          cardElement.textContent = ''; // Hide text
                      });
                 }
             });
        }

        function showNextHandButton() {
             dom.nextHandButton.style.display = 'block';
        }

        function hideNextHandButton() {
             dom.nextHandButton.style.display = 'none';
        }


        // --- Event Handlers ---

        function setupEventListeners() {
            dom.connectWalletButton.addEventListener('click', connectWallet);
            dom.disconnectWalletButton.addEventListener('click', disconnectWallet);

            dom.betSlider.addEventListener('input', (event) => {
                gameState.betAmount = parseFloat(event.target.value);
                dom.currentBetDisplay.textContent = `Bet: ${gameState.betAmount.toFixed(2)} SOL`;
                // Optional: Send bet update to server on slider change or on a separate "Place Bet" button
                 // sendMessage({ type: 'betChanged', amount: gameState.betAmount });
            });

            dom.quickBetButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const amount = event.target.dataset.betAmount;
                    if (amount === 'MAX') {
                        // Placeholder: Implement MAX bet logic (e.g., based on wallet balance or table limit)
                        gameState.betAmount = 10; // Example MAX bet
                    } else {
                        gameState.betAmount = Math.max(0, gameState.betAmount + parseFloat(amount));
                    }
                    // Clamp bet amount to max slider value
                    gameState.betAmount = Math.min(gameState.betAmount, parseFloat(dom.betSlider.max));
                    dom.betSlider.value = gameState.betAmount;
                    dom.currentBetDisplay.textContent = `Bet: ${gameState.betAmount.toFixed(2)} SOL`;
                     // Optional: Send bet update
                     // sendMessage({ type: 'betChanged', amount: gameState.betAmount });
                     playSound(dom.buttonClickSound); // Play sound
                     triggerHaptic([50]); // Haptic feedback
                });
            });

            dom.joinLeaveButton.addEventListener('click', () => {
                if (gameState.isSeated) {
                    sendMessage({ type: 'leaveTable' });
                } else {
                    sendMessage({ type: 'joinTable', bet: gameState.betAmount }); // Send bet when joining
                }
                 playSound(dom.buttonClickSound); // Play sound
                 triggerHaptic([50]); // Haptic feedback
            });

            dom.sendChatButton.addEventListener('click', sendChatMessage);
            dom.chatInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    sendChatMessage();
                }
            });

             // Placeholder for Settings Menu Toggle
             const menuIcon = document.querySelector('.menu-icon');
             menuIcon.addEventListener('click', () => {
                 const dropdown = dom.settingsDropdown;
                 dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
                  playSound(dom.buttonClickSound); // Play sound
             });

             // Close settings dropdown if clicked outside
             document.addEventListener('click', (event) => {
                 if (!menuIcon.contains(event.target) && !dom.settingsDropdown.contains(event.target)) {
                     dom.settingsDropdown.style.display = 'none';
                 }
             });

             // Mobile Chat Toggle
             dom.toggleChatButton.addEventListener('click', () => {
                 gameState.chatVisible = !gameState.chatVisible;
                 updateChatContainerVisibility();
                  playSound(dom.buttonClickSound); // Play sound
             });

             // Mobile Other Hands Toggle
             dom.toggleOtherHandsButton.addEventListener('click', () => {
                 gameState.otherHandsVisible = !gameState.otherHandsVisible;
                 updateOtherHandsVisibility();
                  playSound(dom.buttonClickSound); // Play sound
             });

             // Next Hand Button
             dom.nextHandButton.addEventListener('click', () => {
                 sendMessage({ type: 'nextHand' });
                 hideNextHandButton();
                  playSound(dom.buttonClickSound); // Play sound
                  triggerHaptic([50]); // Haptic feedback
             });

             // Refer Friends Button
             dom.referFriendsButton.addEventListener('click', shareReferral);
        }

        function sendPlayerAction(action) {
             if (gameState.walletAddress && gameState.walletAddress === gameState.activePlayerId && !gameState.isSpectator) {
                  sendMessage({ type: 'player_action', action: action });
             } else {
                 console.warn("Cannot send action: Not your turn, not connected, or spectator.");
             }
        }

        function sendChatMessage() {
            const message = dom.chatInput.value.trim();
            if (message && !gameState.isSpectator) {
                // In a real app, sender and badge would come from gameState or backend
                const sender = gameState.walletAddress ? `${gameState.walletAddress.slice(0, 4)}...` : 'Anon';
                const badge = gameState.userLevel;
                sendMessage({ type: 'chat_message', message: message, sender: sender, badge: badge });
                dom.chatInput.value = ''; // Clear input
            }
        }

        // --- Sound and Haptics ---
        function playSound(audioElement) {
             if (audioElement) {
                 audioElement.currentTime = 0; // Rewind to start
                 audioElement.play().catch(error => console.error("Error playing sound:", error));
             }
        }

        function triggerHaptic(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }


        // --- Animation Placeholders ---

        // Placeholder for Confetti Animation (Canvas)
        function triggerConfetti() {
            console.log("Triggering confetti!");
            const confettiCount = window.innerWidth < 768 ? 50 : 100; // Adjust count for mobile
            const colors = ['#10b981', '#ec4899', '#a78bfa', '#facc15']; // Green, Pink, Purple, Yellow
            const particles = [];

            for (let i = 0; i < confettiCount; i++) {
                particles.push({
                    x: Math.random() * dom.confettiCanvas.width,
                    y: dom.confettiCanvas.height, // Start from bottom
                    radius: Math.random() * 5 + 2,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speedX: Math.random() * 10 - 5, // Random horizontal speed
                    speedY: Math.random() * -15 - 5, // Upward speed
                    gravity: 0.5,
                    dampening: 0.9, // Reduce speed over time
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 20 - 10,
                });
            }

            function updateConfetti() {
                dom.confettiCtx.clearRect(0, 0, dom.confettiCanvas.width, dom.confettiCanvas.height);

                particles.forEach(p => {
                    p.speedY += p.gravity;
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.speedX *= p.dampening;
                    p.speedY *= p.dampening;
                    p.rotation += p.rotationSpeed;

                    // Draw particle (simplified square for now)
                    dom.confettiCtx.save();
                    dom.confettiCtx.translate(p.x, p.y);
                    dom.confettiCtx.rotate(p.rotation * Math.PI / 180);
                    dom.confettiCtx.fillStyle = p.color;
                    dom.confettiCtx.fillRect(-p.radius / 2, -p.radius / 2, p.radius, p.radius);
                    dom.confettiCtx.restore();
                });

                // Remove particles that are off-screen
                particles.filter(p => p.y < dom.confettiCanvas.height && p.x > 0 && p.x < dom.confettiCanvas.width); // Filter particles within bounds

                if (particles.length > 0) {
                    requestAnimationFrame(updateConfetti);
                }
            }

            updateConfetti(); // Start animation
        }


        // --- Additional Engagement Features ---

        function checkForDailyReward() {
             const lastLogin = localStorage.getItem('lastLogin');
             const today = new Date().toDateString();

             if (lastLogin !== today) {
                 let streak = parseInt(localStorage.getItem('loginStreak') || '0') + 1;
                 localStorage.setItem('lastLogin', today);
                 localStorage.setItem('loginStreak', streak);

                 if (streak >= 5) {
                     // Award daily reward (e.g., 0.01 SOL)
                     gameState.walletBalance += 0.01; // Simulate adding balance
                     localStorage.setItem('walletBalance', gameState.walletBalance); // Persist balance (simple)
                     dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;
                     alert('Daily Reward: 0.01 SOL Free Bet!'); // Replace with inline message
                     localStorage.setItem('loginStreak', '0'); // Reset streak after reward
                 }
             } else {
                 // Already logged in today, maybe show streak status?
                 const streak = localStorage.getItem('loginStreak') || '0';
                 console.log(`Login Streak: ${streak} days`);
             }
        }

        function shareReferral() {
             const referralLink = "YOUR_REFERRAL_LINK_HERE"; // Replace with your actual referral link
             const text = `Join DegenJack & get a bonus! Play blackjack on Solana. ${referralLink} ðŸš€`;

             if (navigator.share) {
                 navigator.share({
                     title: 'DegenJack Referral',
                     text: text,
                     url: referralLink, // Optional: share the link directly
                 }).catch(error => console.error('Error sharing:', error));
             } else {
                 // Fallback for browsers that don't support navigator.share
                 window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank'); // Example: Share on X (Twitter)
                 // Or copy to clipboard:
                 // navigator.clipboard.writeText(text).then(() => {
                 //     alert('Referral link copied to clipboard!'); // Replace with inline message
                 // }).catch(err => console.error('Failed to copy:', err));
             }
             playSound(dom.buttonClickSound); // Play sound
        }

        function updateLeaderboard(leaderboardData) {
            dom.leaderboard.innerHTML = ''; // Clear current leaderboard
            if (!leaderboardData || leaderboardData.length === 0) {
                dom.leaderboard.textContent = 'Leaderboard: --';
                return;
            }
            const leaderboardTitle = document.createElement('span');
            leaderboardTitle.textContent = 'Leaderboard: ';
            leaderboardTitle.style.fontWeight = 'bold';
            dom.leaderboard.appendChild(leaderboardTitle);

            leaderboardData.forEach((entry, index) => {
                const entrySpan = document.createElement('span');
                entrySpan.textContent = `${index + 1}. ${entry.player}: ${entry.wins} Wins | `;
                dom.leaderboard.appendChild(entrySpan);
            });
        }

        function showMysteryEvent(eventData) {
             console.log("Mystery Event Triggered:", eventData);
             // Placeholder: Implement UI for mystery event (e.g., Bonus Round banner)
             if (eventData.type === 'bonus_round') {
                 dom.hotTableBanner.textContent = `Bonus Round Active! ${eventData.message || 'Double Payouts!'}`;
                 dom.hotTableBanner.style.display = 'block';
                 // Optional: Hide after a duration
                 setTimeout(() => {
                     dom.hotTableBanner.style.display = 'none';
                 }, eventData.duration || 5000); // Hide after 5 seconds by default
             }
        }


        // --- Placeholder Simulation Data (for initial UI testing) ---
        function simulateInitialGameState() {
             // Load persisted state
             gameState.userXP = parseInt(localStorage.getItem('userXP') || '0');
             gameState.userLevel = parseInt(localStorage.getItem('userLevel') || '1');
             gameState.walletBalance = parseFloat(localStorage.getItem('walletBalance') || '0'); // Load simulated balance

             gameState.players = [
                 { id: 'player1', name: 'CryptoKing', level: 7, avatar: 'ðŸ˜Ž', hand: [{value: 'K', suit: 'â™¥'}, {value: '5', suit: 'â™¦'}], isUser: false, timer: 10, hotStreak: 3 },
                 { id: 'user-wallet-id', name: 'You', level: gameState.userLevel, avatar: 'ðŸ˜Š', hand: [{value: 'Q', suit: 'â™ '}, {value: '8', suit: 'â™£'}], isUser: true, timer: 10, hotStreak: 2 }, // Replace 'user-wallet-id' with actual connected wallet ID
                 { id: 'player3', name: 'DegenJane', level: 3, avatar: 'ðŸ˜‚', hand: [{value: '2', suit: 'â™¥'}, {value: '7', suit: 'â™¦'}], isUser: false, timer: 10, hotStreak: 0 },
             ];
             gameState.dealerHand = [{value: '?', suit: '?'}, {value: '10', suit: 'â™ '}]; // Dealer shows one card
             gameState.activePlayerId = 'user-wallet-id'; // Set user as active initially
             gameState.betAmount = parseFloat(localStorage.getItem('currentBet') || '0.5'); // Persist bet amount
             gameState.isSeated = true;
             gameState.chatMessages = [
                 { sender: 'Anon', message: 'gm degens!', badge: '1' },
                 { sender: 'CryptoKing', message: 'let\'s go!', badge: '7' },
             ];
             gameState.recentPlays = [
                 { player: 'Whale', amount: 2.0, win: true },
                 { player: 'You', amount: 0.5, win: false },
                 { player: 'DegenJane', amount: 0.1, win: true },
             ];

             // Simulate a leaderboard
             gameState.leaderboard = [
                 { player: 'CryptoKing', wins: 10 },
                 { player: 'DegenJane', wins: 8 },
                 { player: 'Anon', wins: 5 },
                 { player: 'You', wins: 4 },
                 { player: 'Whale', wins: 3 },
             ];


             // Update UI with simulated data
             updateUI();
             // Start the timer animation for the active player
             startTurnTimer(gameState.turnTimerDuration);

             // Simulate a fake chat message every few seconds
             setInterval(() => {
                 const fakeMessages = [
                     { sender: 'Anon' + Math.floor(Math.random() * 100), message: 'wow!', badge: Math.floor(Math.random() * 10) + 1 },
                     { sender: 'WhaleWatcher', message: 'big win!', badge: Math.floor(Math.random() * 20) + 5 },
                     { sender: 'Degen', message: 'lfg!', badge: Math.floor(Math.random() * 5) + 1 },
                 ];
                 const randomMsg = fakeMessages[Math.floor(Math.random() * fakeMessages.length)];
                 // Only add if chat is visible on desktop or chat container is active on mobile
                 if (window.innerWidth > 768 || gameState.chatVisible) {
                      addChatMessageToFeed(randomMsg);
                 }
             }, 10000); // Every 10 seconds

             // Simulate a fake recent play every few seconds
             setInterval(() => {
                 const fakePlays = [
                     { player: 'Anon' + Math.floor(Math.random() * 100), amount: parseFloat((Math.random() * 0.5 + 0.01).toFixed(2)), win: Math.random() > 0.5 },
                     { player: 'WhaleWatcher', amount: parseFloat((Math.random() * 1 + 0.1).toFixed(2)), win: Math.random() > 0.5 },
                 ];
                 const randomPlay = fakePlays[Math.floor(Math.random() * fakePlays.length)];
                 gameState.recentPlays.unshift(randomPlay);
                  if (gameState.recentPlays.length > 10) {
                      gameState.recentPlays.pop();
                  }
                  updateRecentPlaysTicker();
             }, 15000); // Every 15 seconds

             // Simulate Mystery Event (Bonus Round) periodically
             setInterval(() => {
                 showMysteryEvent({ type: 'bonus_round', message: 'Double Payouts!', duration: 10000 }); // Bonus round for 10 seconds
             }, 60000); // Every 60 seconds (1 minute)
        }


    </script>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>

</body>
</html>
