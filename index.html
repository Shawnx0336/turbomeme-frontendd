<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>DegenRoulette</title>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset and Body Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: #111; /* Dark background */
            color: #eee;
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            flex-direction: column;
            /* Use 100dvh for dynamic viewport height on mobile */
            height: 100dvh;
            min-height: 100vh; /* Fallback for browsers that don't support dvh */
            /* Ensure full coverage on mobile */
            width: 100%;
            box-sizing: border-box;

            /* Apply safe area insets */
            padding-top: env(safe-area-inset-top);
            /* padding-bottom will be handled by the fixed bottom bar */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);

            overscroll-behavior-y: contain; /* Prevent pull-to-refresh */
            scroll-behavior: smooth; /* Smooth scrolling */

            /* Subtle animated background glow */
            background: radial-gradient(circle at center, #2e003e 0%, transparent 80%), /* Darker core purple */
                        radial-gradient(circle at top left, rgba(139, 92, 246, 0.15) 0%, transparent 50%), /* Purple glow */
                        radial-gradient(circle at top right, rgba(232, 121, 249, 0.15) 0%, transparent 50%), /* Pink glow */
                        radial-gradient(circle at bottom left, rgba(16, 185, 129, 0.15) 0%, transparent 50%), /* Green glow */
                        #0d001a; /* Deep dark background */
             background-size: 200% 200%; /* Larger than viewport for animation */
             animation: background-pan 30s linear infinite alternate; /* Slower panning animation */
        }

        @keyframes background-pan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

         /* Optional: Subtle background flicker */
         /* animation: background-pan 30s linear infinite alternate, flicker 5s infinite; */

         /* @keyframes flicker {
             0%, 100% { opacity: 1; }
             50% { opacity: 0.98; }
         } */


        /* Utility classes for display toggling */
        .hidden { display: none !important; }
        .block { display: block !important; }
        .flex { display: flex !important; }
        .grid { display: grid !important; }


        /* Custom Scrollbar for Chat */
        .custom-scrollbar::-webkit-scrollbar {
            width: 0.375rem; /* Use rem */
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 0.1875rem; /* Use rem */
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 0.1875rem; /* Use rem */
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Layout Zones */
        #top-bar {
            flex-shrink: 0; /* Prevent shrinking */
            background-color: rgba(10, 10, 10, 0.9); /* Slightly darker, semi-transparent */
            backdrop-filter: blur(5px); /* Frosted glass effect */
            padding: 1rem 1rem; /* Use rem for padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #222;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 0.5rem; /* Use rem for border-radius */
            border-bottom-right-radius: 0.5rem;
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
            position: relative; /* Needed for absolute positioning of dropdown */
            z-index: 100; /* Ensure it's above other content */
             /* Ensure content is within safe areas */
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
        }

        #game-table {
            flex-grow: 1; /* Take available space */
            background-color: rgba(26, 26, 26, 0.8); /* Middle dark, semi-transparent */
            backdrop-filter: blur(3px); /* Subtle blur */
            display: flex;
            flex-direction: column; /* Changed to column for wheel and grid */
            align-items: center;
            justify-content: center;
            padding: 1rem; /* Use rem for padding */
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
            overflow: auto; /* Allow scrolling if content exceeds size */
            position: relative; /* Needed for absolute positioning of near-miss, next-hand */
            /* Add padding at the bottom to prevent game table content from being hidden by the fixed bottom bar */
            padding-bottom: calc(8rem + env(safe-area-inset-bottom)); /* Adjust 8rem based on bottom bar height */

            /* Game Table Texture */
            background-image: url('/assets/textures/green-felt.png'), radial-gradient(circle, rgba(255, 255, 255, 0.1), transparent); /* Felt texture + spotlight */
            background-size: cover, 100% 100%;
            background-position: center, center;
            background-blend-mode: overlay; /* Blend gradient over texture */
             /* Wood grain border (placeholder) */
             /* border: 0.5rem solid url('/assets/textures/wood-grain.png'); */
             /* border-image: url('/assets/textures/wood-grain.png') 30 repeat; */
             /* box-shadow: inset 0 0 6.25rem rgba(0, 0, 0, 0.8); */ /* Vignette effect */
        }

        #bottom-bar {
            flex-shrink: 0; /* Prevent shrinking */
            background-color: rgba(10, 10, 10, 0.9); /* Slightly darker, semi-transparent */
            backdrop-filter: blur(5px); /* Frosted glass effect */
            padding: 1rem; /* Use rem for padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #222;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);
            border-top-left-radius: 0.5rem; /* Use rem for border-radius */
            border-top-right-radius: 0.5rem;
            width: 100%; /* Ensure full width */
            box-sizing: border-box;
            position: fixed; /* Make it sticky at the bottom */
            bottom: env(safe-area-inset-bottom); /* Position above safe area */
            left: 0;
            z-index: 90; /* Ensure it's above game table but below top bar */
            /* Ensure content is within safe areas */
            padding-left: calc(1rem + env(safe-area-inset-left));
            padding-right: calc(1rem + env(safe-area-inset-right));
        }

        /* Top Bar Styles */
        .top-bar-section { /* Use a class for flex items in top bar */
            display: flex;
            align-items: center;
            /* Allow sections to shrink/grow */
            flex-shrink: 1;
            flex-grow: 1; /* Allow sections to grow */
            /* Add some spacing between sections */
            margin: 0 0.5rem; /* Use rem for margin */
        }

         .top-bar-section:first-child { margin-left: 0; }
         .top-bar-section:last-child { margin-right: 0; justify-content: flex-end; }
         .top-bar-section:nth-child(2) { justify-content: center; } /* Center the XP section */


        .wallet-info span {
            margin-right: 0.5rem; /* Use rem for margin */
            white-space: nowrap; /* Prevent wrapping */
            font-size: 0.875rem; /* Use rem for font size */
        }

         #wallet-icon {
             font-size: 1.2rem; /* Use rem */
             margin-right: 0.25rem; /* Use rem */
         }

        .xp-progress {
             flex-grow: 1; /* Allow XP progress to take available space */
             justify-content: center; /* Center content within its section */
        }

        .xp-bar-container {
            width: 10rem; /* Use rem for width */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            height: 0.5rem; /* Use rem for height */
            background-color: #333;
            border-radius: 0.25rem; /* Use rem for border-radius */
            overflow: hidden;
            margin: 0 0.5rem; /* Use rem for margin */
        }

        .xp-bar-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background: linear-gradient(90deg, #8b5cf6, #e879f9); /* Purple gradient */
            transition: width 0.5s ease-in-out;
        }

        .recent-plays-ticker {
            width: 12rem; /* Use rem for width */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            overflow: hidden;
            white-space: nowrap;
            font-style: italic;
            color: #aaa;
            font-size: 0.75rem; /* Use rem for font size */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }

        .recent-play-item {
            margin-right: 0.75rem; /* Use rem for margin */
            display: inline-block;
        }

        .win { color: #10b981; /* Green */ }
        .loss { color: #ef4444; /* Red */ }

        .menu-icon {
            width: 1.5rem; /* Use rem for width */
            height: 1.5rem; /* Use rem for height */
            cursor: pointer;
            fill: #eee;
            min-width: 2.75rem; /* Touch target (44px) */
            min-height: 2.75rem; /* Touch target (44px) */
            padding: 0.5rem; /* Add padding for easier tapping */
            box-sizing: border-box;
        }

        /* Game Table Styles */

        /* Roulette Wheel Container */
        #roulette-wheel-container {
            width: 25rem; /* Use rem */
            height: 25rem; /* Use rem */
            margin-bottom: 2rem; /* Use rem */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Add some 3D perspective */
            transform: perspective(1000px) rotateX(15deg);
        }

        #roulette-wheel-canvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #000; /* Black center */
            box-shadow: 0 0 2rem rgba(255, 215, 0, 0.5); /* Gold glow */
             /* Add wood grain texture to the wheel edge */
             border: 1rem solid transparent; /* Placeholder for border image */
             border-image: url('/assets/textures/wood-grain.png') 30 round; /* Placeholder */
             box-sizing: border-box;
        }

        #winning-number-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem; /* Use rem */
            font-weight: bold;
            color: #ffd700; /* Gold */
            text-shadow: 0 0 1rem rgba(255, 215, 0, 0.8);
            z-index: 5;
             /* Add a subtle bounce animation on update */
             animation: bounce-text 0.5s ease-out;
        }

         @keyframes bounce-text {
             0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
             50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
             100% { transform: translate(-50%, -50%) scale(1); }
         }


        /* Betting Grid */
        #betting-grid-container {
             width: 100%;
             max-width: 50rem; /* Max width for the grid */
             margin: 0 auto; /* Center the grid */
             display: flex;
             flex-direction: column;
             align-items: center; /* Center grid content */
             padding: 1rem; /* Use rem */
             background-color: rgba(0, 50, 0, 0.8); /* Dark green felt */
             border-radius: 1rem; /* Use rem */
             box-shadow: inset 0 0 2rem rgba(0, 0, 0, 0.5); /* Inner shadow */
        }

        #betting-grid {
            display: grid;
            grid-template-columns: repeat(12, 3rem) 3rem; /* 12 columns for numbers + 1 for 3x */
            grid-template-rows: repeat(3, 3rem) 3rem 3rem; /* 3 rows for numbers + 1 for 2x + 1 for 1-18/etc */
            gap: 0.25rem; /* Use rem for gap */
             font-family: 'Luckiest Guy', cursive; /* Casino font */
             font-size: 1.2rem; /* Use rem */
             color: #eee;
        }

        .grid-cell {
            background-color: rgba(20, 20, 20, 0.8); /* Dark cell background */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.25rem; /* Use rem */
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative; /* For chip placement */
             /* Add subtle border */
             border: 1px solid #333;
        }

        .grid-cell:hover {
            background-color: rgba(50, 50, 50, 0.8);
            box-shadow: 0 0 0.5rem rgba(255, 215, 0, 0.5); /* Gold hover glow */
        }

        .cell-0 {
            grid-column: 1 / span 1;
            grid-row: 1 / span 3;
            background-color: #006400; /* Dark green for 0 */
        }

        .cell-number {
            /* Colors for numbers */
        }

        .cell-red { background-color: #b22222; /* Firebrick Red */ }
        .cell-black { background-color: #1a1a1a; /* Very dark black */ }

        .cell-2x {
            grid-column: 13 / span 1;
        }

        .cell-bottom-row {
             grid-row: 4 / span 1;
        }

         .cell-bottom-row.full-width {
             grid-column: 1 / span 13;
             display: grid;
             grid-template-columns: repeat(3, 1fr); /* 3 columns for 1-18, Even, Red */
             gap: 0.25rem; /* Use rem */
         }

         .cell-bottom-row.full-width > .grid-cell {
             grid-column: span 1;
         }

         .cell-bottom-row.full-width.second-row {
             grid-row: 5 / span 1;
         }

         .cell-bottom-row.full-width.second-row > .grid-cell {
              grid-column: span 1;
         }


        /* Chip on Grid */
        .placed-chip {
            position: absolute;
            width: 1.5rem; /* Use rem */
            height: 1.5rem; /* Use rem */
            border-radius: 50%;
            background-color: gold; /* Placeholder */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem; /* Use rem */
            font-weight: bold;
            color: #333;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
             /* Subtle pulse animation */
             animation: chip-pulse 1s infinite alternate;
        }

         @keyframes chip-pulse {
             0% { transform: scale(1); box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
             100% { transform: scale(1.05); box-shadow: 0 0 5px rgba(255, 215, 0, 0.8); }
         }


        /* Player Seats (Simplified for Roulette) */
        .player-seats {
            display: flex; /* Use flex for a horizontal row below the grid */
            justify-content: center;
            width: 100%;
            margin-top: 1rem; /* Use rem */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 0.5rem; /* Use rem */
        }

        .player-seat {
            height: auto; /* Auto height */
            max-width: 10rem; /* Max width for seat */
            margin: 0; /* Remove individual seat margin, use flex gap */
            padding: 0.5rem; /* Use rem */
            background-color: #2a2a2a;
            border-radius: 0.5rem; /* Use rem */
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid transparent;
            transition: border-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            font-size: 0.875rem; /* Use rem */
             overflow: hidden; /* Prevent content overflow */
             overflow-wrap: anywhere; /* Allow breaking long words */
             /* Entry animation */
             animation: fade-in 0.3s ease-in-out;

             /* Seat Design Enhancements */
             background-image: url('/assets/textures/velvet-purple.png'); /* Velvet texture */
             background-size: cover;
             border: 2px solid #d4af37; /* Gold trim */
             box-shadow: inset 0 0 0.3125rem #a78bfa; /* Inner glow */
             flex-shrink: 0; /* Prevent shrinking */
        }

        @keyframes fade-in {
           from { opacity: 0; transform: scale(0.95); }
           to { opacity: 1; transform: scale(1); }
        }


        .player-seat.active {
            border-color: #ffd700; /* Pulsating gold glow */
            box-shadow: 0 0 0.9375rem #ffd700; /* Use rem */
            animation: glow 1.5s infinite ease-in-out; /* Pulsating glow animation */
             /* Subtle spotlight effect above active seat */
             background: radial-gradient(circle at top center, rgba(255, 215, 0, 0.2), transparent), url('/assets/textures/velvet-purple.png');
             background-size: 100% 100%, cover;
             background-position: center, center;
             background-blend-mode: overlay;
        }

         @keyframes glow {
             0%, 100% { box-shadow: 0 0 0.9375rem #ffd700; }
             50% { box-shadow: 0 0 1.25rem #ffd700; }
         }


        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; /* Use rem for margin */
        }

        .avatar {
            width: 2rem; /* Use rem */
            height: 2rem; /* Use rem */
            background-color: #5b21b6; /* Violet */
            border-radius: 50%;
            margin-right: 0.25rem; /* Use rem */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem; /* Use rem */
             /* Avatar pop-in animation */
             animation: pop-in 0.3s ease-out;
             position: relative; /* For badge overlay */
        }

         @keyframes pop-in {
             0% { transform: scale(0); }
             80% { transform: scale(1.1); }
             100% { transform: scale(1); }
         }

         /* VIP Badge Overlay */
         .avatar.vip::after {
             content: '';
             position: absolute;
             top: -0.25rem; /* Use rem */
             right: -0.25rem; /* Use rem */
             width: 1rem; /* Use rem */
             height: 1rem; /* Use rem */
             background-image: url('/assets/ui/vip-crown.png'); /* Placeholder VIP crown */
             background-size: cover;
             animation: sparkle 1.5s infinite ease-in-out; /* Subtle sparkle animation */
         }

         @keyframes sparkle {
             0%, 100% { opacity: 1; }
             50% { opacity: 0.5; }
         }


        .username {
            font-size: 0.875rem; /* Use rem */
            font-weight: bold;
            color: #fff;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .xp-badge {
            background-color: #facc15; /* Yellow */
            color: #333;
            font-size: 0.7rem; /* Use rem */
            padding: 0.125rem 0.375rem; /* Use rem */
            border-radius: 0.625rem; /* Use rem */
            margin-left: 0.25rem; /* Use rem */
            white-space: nowrap; /* Prevent wrapping */
        }

         /* Hide player hand in compressed view initially */
         .player-seat .player-hand {
             display: none; /* No hands in Roulette seats */
         }


        .action-buttons {
            margin-top: 0.5rem; /* Use rem */
            display: flex; /* Use flex for button layout */
            justify-content: center;
            width: 100%; /* Ensure buttons take full width of seat */
        }

        .action-buttons button {
            padding: 0.75rem 1.25rem; /* Increased padding for touch (12px 20px) */
            border: none;
            border-radius: 0.3125rem; /* Use rem (5px) */
            cursor: pointer;
            font-size: 1rem; /* Increased font size */
            font-weight: bold;
            transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            min-width: 3rem; /* Ensure touch target size (48px) */
            min-height: 3rem; /* Ensure touch target size (48px) */
            flex-grow: 1; /* Allow buttons to grow */
            margin: 0 0.25rem; /* Add spacing between buttons (4px) */
             /* Remove 300ms click delay */
            touch-action: manipulation;
             /* Optional: Disable tap highlight */
            -webkit-tap-highlight-color: transparent;

            /* Button Pulse Animation (Idle Feedback) */
            /* Applied via JS class .pulse-button */
        }

         @keyframes pulse {
             0%, 100% { box-shadow: 0 0 0 0 rgba(0,255,150,0.4); } /* Green glow */
             50% { box-shadow: 0 0 0 0.625rem rgba(0,255,150,0); } /* Use rem */
         }

         .pulse-button {
             animation: pulse 2s infinite;
         }

         /* Remove pulse animation when disabled or not active player's turn */
         .action-buttons button:disabled,
         .player-seat:not(.active) .action-buttons button {
             animation: none;
             box-shadow: none;
         }

         /* Button Active State */
         button:active {
             transform: scale(0.96);
             filter: brightness(1.1);
         }


        .turn-timer-bar {
            width: 100%;
            height: 0.1875rem; /* Use rem (3px) */
            background-color: #333;
            margin-top: 0.3125rem; /* Use rem (5px) */
            border-radius: 0.125rem; /* Use rem (2px) */
            overflow: hidden;
        }

        .turn-timer-fill {
            height: 100%;
            width: 100%; /* Initial width */
            background-color: #3b82f6; /* Blue */
            transition: width linear; /* Transition handled by JS */
        }

        /* Hot Streak Placeholder */
        .hot-streak-bar {
            width: 80%;
            height: 0.3125rem; /* Use rem (5px) */
            background-color: #333;
            border-radius: 0.15625rem; /* Use rem */
            margin-top: 0.3125rem; /* Use rem */
            overflow: hidden;
        }

        .hot-streak-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #facc15, #ef4444); /* Yellow to Red */
            transition: width 0.3s ease-in-out;
        }

        /* Near Miss Placeholder */
        .near-miss-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 0, 0.8); /* Yellowish semi-transparent */
            color: #333;
            padding: 0.625rem 1.25rem; /* Use rem */
            border-radius: 0.3125rem; /* Use rem */
            font-weight: bold;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none; /* Don't block clicks */
             /* Near miss background gradient */
             background: linear-gradient(45deg, #e63946, #facc15); /* Red to Yellow */
             color: #0a0a0a;
        }

        .near-miss-popup.show {
            opacity: 1;
        }

        /* Dealer Anchor - Repurposed for Roulette Info */
        .dealer-anchor {
            background: radial-gradient(circle at center, #2e2e2e, transparent);
            border-radius: 0.75rem; /* Use rem */
            padding: 0.5rem; /* Use rem */
            margin-bottom: 0.75rem; /* Use rem */
            display: flex;
            flex-direction: column;
            align-items: center;
             /* Optional: Dealer glow animation */
             /* animation: dealer-glow 3s infinite ease-in-out; */
        }

        /* Dealer Glow Animation Placeholder */
        @keyframes dealer-glow {
             0%, 100% { box-shadow: 0 0 5px rgba(167, 139, 250, 0.3); } /* Subtle purple glow */
             50% { box-shadow: 0 0 15px rgba(167, 139, 250, 0.6); }
        }

        .dealer-anchor.glowing {
            animation: dealer-glow 3s infinite ease-in-out;
        }


        /* Bottom Bar Styles */
        .bottom-bar-section { /* Use a class for flex items in bottom bar */
            display: flex;
            align-items: center;
            /* Allow sections to shrink/grow */
            flex-shrink: 1;
            flex-grow: 1; /* Allow both sections to grow */
            /* Add some spacing between sections */
            margin: 0 0.5rem; /* Use rem */
        }

         .bottom-bar-section:first-child { margin-left: 0; justify-content: flex-start; }
         .bottom-bar-section:last-child { margin-right: 0; justify-content: flex-end; }


        .betting-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Allow controls to wrap */
            justify-content: center; /* Center controls */
            flex-grow: 1; /* Allow betting controls to grow */
        }

        .betting-controls > span {
            white-space: nowrap; /* Prevent wrapping */
            margin-right: 0.5rem; /* Use rem */
            font-size: 1rem; /* Use rem */
        }

        .betting-controls input[type="range"] {
            width: 9.375rem; /* Use rem (150px) */
            max-width: 100%; /* Ensure it doesn't exceed container */
            margin: 0 0.5rem; /* Use rem */
            accent-color: #10b981; /* Green accent */
             min-height: 3rem; /* Ensure touch target (48px) */
             box-sizing: border-box;
        }

        .quick-bet-buttons {
            display: flex;
            align-items: center;
            margin-left: 0.5rem; /* Use rem */
        }

        .quick-bet-buttons button {
            padding: 0.625rem 0.9375rem; /* Increased padding (10px 15px) */
            border: none;
            border-radius: 0.25rem; /* Use rem (4px) */
            background-color: #333;
            color: #eee;
            cursor: pointer;
            font-size: 0.9rem; /* Use rem */
            margin-right: 0.5rem; /* Increased margin (8px) */
            transition: background-color 0.3s ease-in-out;
            min-width: 3rem; /* Ensure touch target size (48px) */
            min-height: 3rem; /* Ensure touch target size (48px) */
             /* Remove 300ms click delay */
            touch-action: manipulation;
             /* Optional: Disable tap highlight */
            -webkit-tap-highlight-color: transparent;
        }

        .quick-bet-buttons button:last-child {
            margin-right: 0;
        }

        .quick-bet-buttons button:hover {
            background-color: #555;
        }

         /* Chip Button Styles */
         .chip-button {
             background-size: cover;
             background-position: center;
             color: transparent; /* Hide text if using image background */
             font-size: 0; /* Hide text if using image background */
             position: relative; /* For pseudo-elements or overlays */
         }

         .green-chip { background-image: url('/assets/ui/green-chip.png'); } /* Placeholder */
         .purple-chip { background-image: url('/assets/ui/purple-chip.png'); } /* Placeholder */
         .max-chip {
             background-image: url('/assets/ui/max-chip.png'); /* Placeholder */
             color: #fff; /* Show text for MAX button */
             font-size: 0.9rem; /* Use rem */
             text-align: center;
         }


        .join-leave-button {
             padding: 0.75rem 1.5625rem; /* Increased padding (12px 25px) */
             border: none;
             border-radius: 0.5rem; /* Use rem (8px) */
             cursor: pointer;
             font-size: 1rem; /* Increased font size */
             font-weight: bold;
             transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
             margin-left: 1.25rem; /* Use rem (20px) */
             min-width: 3rem; /* Ensure touch target size (48px) */
             min-height: 3rem; /* Ensure touch target size (48px) */
              /* Remove 300ms click delay */
            touch-action: manipulation;
             /* Optional: Disable tap highlight */
            -webkit-tap-highlight-color: transparent;
         }

         .join-button {
            background-color: #10b981; /* Green */
            color: #0a0a0a;
         }

         .join-button:hover {
            background-color: #059669;
            box-shadow: 0 0 0.5rem #10b981; /* Use rem */
         }

         .leave-button {
            background-color: #ef4444; /* Red */
            color: #0a0a0a;
         }

         .leave-button:hover {
            background-color: #d92d2d;
            box-shadow: 0 0 0.5rem #ef4444; /* Use rem */
         }

        .chat-container {
            width: 18.75rem; /* Default width (300px) */
            max-width: 100%; /* Ensure it doesn't overflow */
            height: 7.5rem; /* Default height (120px) */
            background-color: rgba(26, 26, 26, 0.8); /* Semi-transparent */
            backdrop-filter: blur(3px); /* Subtle blur */
            border-radius: 0.5rem; /* Use rem */
            padding: 0.625rem; /* Use rem */
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 0.3125rem rgba(0, 0, 0, 0.5); /* Use rem */
            box-sizing: border-box;
             flex-grow: 1; /* Allow chat to grow */
             margin-left: 1rem; /* Add margin to separate from betting controls */
        }

        .chat-feed {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.875rem; /* Use rem */
            color: #bbb;
            margin-bottom: 0.3125rem; /* Use rem */
            padding-right: 0.3125rem; /* Add padding to prevent scrollbar overlaying text */
             overflow-wrap: anywhere; /* Allow breaking long words */
        }

        .chat-message {
            margin-bottom: 0.1875rem; /* Use rem */
            word-break: break-word; /* Break long words */
        }

         /* New Message Flash Animation */
         @keyframes flash-bg {
             0% { background-color: #333; }
             50% { background-color: transparent; }
             100% { background-color: #333; }
         }

         .chat-message.flash {
             animation: flash-bg 1s ease-in-out;
         }


        .chat-sender {
            font-weight: bold;
            color: #60a5fa; /* Blue */
            margin-right: 0.3125rem; /* Use rem */
        }

         .chat-badge {
             color: #facc15; /* Yellow */
             margin-right: 0.3125rem; /* Use rem */
         }

        .chat-input-area {
            display: flex;
            align-items: center;
            margin-top: 0.3125rem; /* Use rem */
        }

        .chat-input-area input[type="text"] {
            flex-grow: 1;
            padding: 0.625rem; /* Increased padding (10px) */
            border: none;
            border-radius: 0.25rem 0 0 0.25rem; /* Use rem */
            background-color: #333;
            color: #eee;
            font-size: 1rem; /* Increased font size */
            outline: none;
             min-height: 3rem; /* Ensure touch target size (48px) */
             box-sizing: border-box;
        }

        .chat-input-area button {
            padding: 0.625rem 0.9375rem; /* Increased padding (10px 15px) */
            border: none;
            border-radius: 0 0.25rem 0.25rem 0; /* Use rem */
            background-color: #3b82f6; /* Blue */
            color: #fff;
            cursor: pointer;
            font-size: 1rem; /* Increased font size */
            transition: background-color 0.3s ease-in-out;
            min-width: 3rem; /* Ensure touch target size (48px) */
            min-height: 3rem; /* Ensure touch target size (48px) */
             /* Remove 300ms click delay */
            touch-action: manipulation;
             /* Optional: Disable tap highlight */
            -webkit-tap-highlight-color: transparent;
        }

        .chat-input-area button:hover {
            background-color: #2563eb;
        }

        /* Crate Animation Placeholder */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-0.625rem); /* Use rem */
            }
            60% {
                transform: translateY(-0.3125rem); /* Use rem */
            }
        }

        .crate-icon {
            width: 1.875rem; /* Use rem */
            height: 1.875rem; /* Use rem */
            fill: #facc15; /* Yellow */
            cursor: pointer;
            animation: bounce 1s infinite;
            margin-left: 0.625rem; /* Use rem */
             min-width: 2.75rem; /* Touch target (44px) */
             min-height: 2.75rem; /* Touch target (44px) */
             padding: 0.5rem; /* Add padding for easier tapping */
             box-sizing: border-box;
        }

        /* Placeholder for Confetti Canvas */
        #confetti-canvas {
            position: fixed; /* Use fixed for full viewport coverage */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks through */
            z-index: 10; /* Above game elements */
        }

        /* Hot Table Banner Placeholder */
        #hot-table-banner {
            position: fixed;
            top: calc(3.75rem + env(safe-area-inset-top)); /* Position below top bar (60px), accounting for safe area */
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(90deg, #ff6bec, #a78bfa); /* Neon pink to purple gradient */
            color: #0a0a0a;
            padding: 0.3125rem 0.9375rem; /* Use rem */
            border-radius: 0.3125rem; /* Use rem */
            font-weight: bold;
            z-index: 15;
            display: none; /* Hidden by default */
            box-shadow: 0 0 0.625rem #ff6bec; /* Use rem */
             /* Blinking border animation */
             border: 2px solid #ffd700; /* Gold border */
             animation: blink 1s infinite;
             text-shadow: 0 0 0.3125rem #ff6bec, 0 0 0.625rem #ff6bec; /* Neon text glow */
        }

         @keyframes blink {
             0%, 100% { border-color: #ffd700; }
             50% { border-color: transparent; }
         }


         /* Next Hand Button Placeholder - Repurposed for Spin */
         #spin-button {
             position: absolute;
             bottom: calc(9.375rem + env(safe-area-inset-bottom)); /* Position above bottom bar (150px), accounting for safe area */
             left: 50%;
             transform: translateX(-50%);
             padding: 0.75rem 1.5625rem; /* Use rem */
             border: none;
             border-radius: 0.5rem; /* Use rem */
             background-color: #10b981; /* Green */
             color: #0a0a0a;
             font-size: 1.1rem; /* Use rem */
             font-weight: bold;
             cursor: pointer;
             z-index: 15;
             display: none; /* Hidden by default */
             box-shadow: 0 0 0.9375rem #10b981; /* Use rem */
             transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
             min-width: 3rem; /* Ensure touch target size (48px) */
             min-height: 3rem; /* Ensure touch target size (48px) */
              /* Remove 300ms click delay */
            touch-action: manipulation;
             /* Optional: Disable tap highlight */
            -webkit-tap-highlight-color: transparent;
         }

         #spin-button:hover {
            background-color: #059669;
            box-shadow: 0 0 1.25rem #059669; /* Use rem */
         }

         /* Coin Shower Animation Placeholder */
         .coin {
             position: fixed;
             width: 1.25rem; /* Use rem */
             height: 1.25rem; /* Use rem */
             background-color: gold; /* Gold coin color */
             border-radius: 50%;
             z-index: 20; /* Above everything */
             animation: coin-fall 2s ease-in forwards;
             opacity: 0.8;
              /* Optional: Add coin sprite */
             /* background-image: url('/assets/ui/coin-sprite.png'); */
             /* background-size: cover; */
             /* background-color: transparent; */
             /* Add rotation with shadows */
             /* box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5); */
         }

         @keyframes coin-fall {
             0% { transform: translateY(-100vh) translateX(0) rotate(0deg); opacity: 0.5; }
             100% { transform: translateY(100vh) translateX(var(--end-x, 0)) rotate(var(--end-rotate, 360deg)); opacity: 0; }
         }

         /* Optional: Coin bounce animation */
         /* @keyframes bounce {
             0%, 100% { transform: translateY(0); }
             50% { transform: translateY(-0.5rem); }
         } */


         /* Ticker Strip Animation Placeholder */
         @keyframes slide-left {
             0% { transform: translateX(100%); }
             100% { transform: translateX(-100%); }
         }

         .ticker {
             overflow: hidden;
             white-space: nowrap;
             box-sizing: border-box;
             width: 100%;
             background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
             padding: 0.25rem 0; /* Use rem */
             font-size: 0.8rem; /* Use rem */
             color: #10b981; /* Green neon */
             margin-top: 0.5rem; /* Use rem */
         }

         .ticker span {
             display: inline-block;
             padding-left: 100%;
             animation: slide-left 15s linear infinite; /* Adjust duration as needed */
         }

         /* Phase 2 - Profile/Lounge Section Placeholders */
         #profile-lounge-section {
             position: fixed;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent dark background */
             z-index: 200; /* Above everything */
             display: none; /* Hidden by default */
             flex-direction: column;
             align-items: center;
             justify-content: center;
             padding-top: env(safe-area-inset-top);
             padding-bottom: env(safe-area-inset-bottom);
             box-sizing: border-box;
         }

         #profile-lounge-content {
             background-color: #1a1a1a;
             border-radius: 1rem;
             padding: 1.5rem;
             max-width: 90%;
             max-height: 90%;
             overflow-y: auto;
             box-sizing: border-box;
         }

         #profile-lounge-close {
             position: absolute;
             top: calc(1rem + env(safe-area-inset-top));
             right: calc(1rem + env(safe-area-inset-right));
             font-size: 2rem;
             color: #eee;
             cursor: pointer;
         }


        /* Mobile Specific Styles */
        @media (max-width: 768px) {
            body {
                font-size: 16px;
            }
            #top-bar { flex-direction: column; align-items: flex-start; padding: 10px; height: auto; }
            .top-bar-section { width: 100%; justify-content: space-between; margin: 5px 0; }
            .wallet-info span { margin-right: 5px; }
            .xp-bar-container { flex-grow: 1; margin: 0 8px; }
            .recent-plays-ticker { width: 120px; font-size: 0.7em; }
            #game-table { padding: 10px; justify-content: flex-start; }
            #roulette-wheel-container { width: 15rem; height: 15rem; margin-bottom: 1rem; } /* Smaller wheel on mobile */
            #winning-number-display { font-size: 2rem; }
            #betting-grid-container { padding: 0.5rem; }
            #betting-grid {
                grid-template-columns: repeat(12, 2rem) 2rem; /* Smaller grid cells */
                grid-template-rows: repeat(3, 2rem) 2rem 2rem;
                gap: 0.15rem;
                font-size: 0.8rem;
            }
            .grid-cell { border-radius: 0.15rem; }
            .placed-chip { width: 1rem; height: 1rem; font-size: 0.6rem; }

            .player-seats { flex-direction: column; align-items: center; }
            .player-seat { width: 95%; margin: 5px 0; padding: 8px; max-width: none; } /* Allow seats to take more width */
            .player-info { width: 100%; justify-content: center; margin-bottom: 8px; }

            #bottom-bar { flex-direction: column; align-items: center; height: auto; padding: 10px; }
            .bottom-bar-section { width: 100%; margin: 5px 0; justify-content: center; }
            .betting-controls { width: 100%; flex-direction: column; align-items: center; margin-bottom: 10px; }
            .betting-controls > span { margin-bottom: 8px; }
            .chip-selection-buttons { width: 100%; justify-content: center; }
            .chip-selection-buttons button { flex-grow: 1; margin: 0 4px; padding: 10px 5px; font-size: 0.8em; }

            .join-leave-button, #clear-bets-button, #refer-friends-button { margin-left: 0; width: 100%; padding: 12px 20px; margin-top: 5px; }

            .chat-container {
                width: 100%;
                height: 200px;
                position: fixed;
                bottom: 0;
                left: 0;
                border-radius: 8px 8px 0 0;
                transform: translateY(100%);
                transition: transform 0.3s ease-in-out;
                z-index: 95; /* Above bottom bar */
                box-sizing: border-box;
                padding-bottom: calc(50px + env(safe-area-inset-bottom)); /* Adjust for input area height */
                padding-top: 10px; /* Add some padding at the top */
            }
            .chat-container.active { transform: translateY(0); height: 50vh; }
            .chat-feed { height: calc(100% - 40px); margin-bottom: 0; padding-bottom: 10px; } /* Add padding to feed */
            .chat-input-area { position: absolute; bottom: env(safe-area-inset-bottom); left: 0; width: 100%; padding: 5px; background-color: #1a1a1a; box-sizing: border-box; }
            .chat-input-area input[type="text"] { font-size: 1em; min-height: 44px; }
            .chat-input-area button { min-height: 44px; }

            #toggle-chat { display: block; padding: 8px 15px; border: none; border-radius: 5px; background-color: #3b82f6; color: #fff; font-weight: bold; cursor: pointer; margin-top: 10px; min-width: 48px; min-height: 48px; }
             /* Position toggle chat button */
             #toggle-chat {
                 position: fixed;
                 bottom: calc(1rem + env(safe-area-inset-bottom));
                 right: calc(1rem + env(safe-area-inset-right));
                 z-index: 100; /* Above chat container */
             }


            #toggle-other-hands { display: block; margin-top: 10px; padding: 8px 15px; border: none; border-radius: 5px; background-color: #555; color: #eee; cursor: pointer; min-width: 48px; min-height: 48px; }
             /* Position toggle other players button */
             #toggle-other-hands {
                 position: fixed;
                 bottom: calc(1rem + 48px + 1rem + env(safe-area-inset-bottom)); /* Below chat toggle */
                 right: calc(1rem + env(safe-area-inset-right));
                 z-index: 100;
             }
             /* Ensure betting grid is visible when other players are hidden */
             #game-table { overflow-y: auto; } /* Allow scrolling */
        }

        /* Hide toggle button on desktop */
        @media (min-width: 769px) {
             #toggle-chat, #toggle-other-hands {
                 display: none;
             }
        }


        /* Ensure elements are within safe areas even if not fixed */
        /* This is handled by padding on body and fixed elements */
        /* .wallet-info, .xp-progress, .recent-plays,
        .betting-controls, .chat-container {
            padding-left: env(safe-area-inset-left, 0);
            padding-right: env(safe-area-inset-right, 0);
        } */

         /* Added animations */
         @keyframes shake {
             0%, 100% { transform: translateX(0); }
             20%, 60% { transform: translateX(-5px); }
             40%, 80% { transform: translateX(5px); }
         }

         @keyframes float-up {
             0% { transform: translate(-50%, 0); opacity: 1; }
             100% { transform: translate(-50%, -50px); opacity: 0; } /* Adjust distance */
         }
         @keyframes flashWarning {
             0%, 100% { background-color: #ef4444; } /* Red */
             50% { background-color: transparent; }
         }


    </style>
</head>
<body>

    <div id="top-bar">
        <div class="top-bar-section wallet-info">
            <span id="wallet-icon">👤</span> <span id="wallet-address">Not Connected</span>
            <span id="wallet-balance">-- SOL</span>
            <button id="connect-wallet-button">Connect Wallet</button>
            <button id="disconnect-wallet-button" class="hidden">Disconnect</button>
             <a id="phantom-deeplink" href="#" class="hidden" style="color: #a78bfa; font-size: 0.8em; margin-left: 10px;">Open in Phantom App</a>
             <span id="wallet-guidance" class="hidden" style="color: #facc15; font-size: 0.8em; margin-left: 10px;"></span>
        </div>
        <div class="top-bar-section xp-progress">
            <span id="user-level">Level 1</span>
            <div class="xp-bar-container">
                <div id="xp-bar-fill" class="xp-bar-fill"></div>
            </div>
            <span id="user-xp">0/100 XP</span>
            <svg id="crate-icon" class="crate-icon hidden" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" d="M7.293 2.293a1 1 0 011.414 0L10 3.586l1.293-1.293a1 1 0 111.414 1.414L11.414 5l1.293 1.293a1 1 0 11-1.414 1.414L10 6.414l-1.293 1.293a1 1 0 01-1.414-1.414L8.586 5l-1.293-1.293a1 1 0 010-1.414zM10 14a1 1 0 100-2 1 1 0 000 2zm0 4a1 1 0 100-2 1 1 0 000 2zM5 10a1 1 0 11-2 0 1 1 0 012 0zm10 0a1 1 0 11-2 0 1 1 0 012 0z" clip-rule="evenodd"></path>
            </svg>
        </div>
        <div class="top-bar-section recent-plays">
            <div id="recent-plays-ticker" class="ticker">
                <span>No recent plays...</span>
            </div>
             <div id="leaderboard" style="font-size: 0.8em; margin-left: 10px;">
                 </div>
             <span id="referral-count" style="color: #facc15; font-size: 0.8em; margin-left: 10px;">👥 0 referrals</span>

            <svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
            <div id="settings-dropdown" class="hidden" style="position: absolute; top: 50px; right: 20px; background-color: #333; border-radius: 5px; padding: 10px; z-index: 20;">
                <div style="margin-bottom: 10px;">
                    <span>Game Mode:</span>
                    <button id="free-mode-toggle" style="background: #555; color: #eee; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">🔁 SOL Mode</button>
                </div>
                <div style="display: flex; flex-direction: column;">
                    <button id="profile-tab-button" style="background: none; border: none; color: #eee; text-align: left; padding: 5px; cursor: pointer;">👤 Profile</button>
                    <button data-game="roulette" class="game-tab-button" style="background: none; border: none; color: #eee; text-align: left; padding: 5px; cursor: pointer;">🎰 Roulette</button> <button data-game="blackjack" class="game-tab-button" style="background: none; border: none; color: #eee; text-align: left; padding: 5px; cursor: pointer;">🃏 Blackjack</button> <button data-game="dice" class="game-tab-button" style="background: none; border: none; color: #eee; text-align: left; padding: 5px; cursor: pointer;">🎲 Dice (Soon)</button> </div>
            </div>
        </div>
    </div>

    <div id="game-table">
        <div id="roulette-wheel-container">
            <canvas id="roulette-wheel-canvas"></canvas>
            <div id="winning-number-display">--</div>
        </div>

        <div id="betting-grid-container">
            <div id="betting-grid">
                </div>
             <div class="cell-bottom-row full-width">
                 <div class="grid-cell" data-bet-type="1-18">1-18</div>
                 <div class="grid-cell cell-black" data-bet-type="even">EVEN</div>
                 <div class="grid-cell cell-red" data-bet-type="red">RED</div>
             </div>
             <div class="cell-bottom-row full-width second-row">
                 <div class="grid-cell cell-red" data-bet-type="black">BLACK</div>
                 <div class="grid-cell cell-odd" data-bet-type="odd">ODD</div>
                 <div class="grid-cell" data-bet-type="19-36">19-36</div>
             </div>
             <div class="cell-bottom-row">
                 <div class="grid-cell" data-bet-type="1st12">1st 12</div>
                 <div class="grid-cell" data-bet-type="2nd12">2nd 12</div>
                 <div class="grid-cell" data-bet-type="3rd12">3rd 12</div>
             </div>
             <div class="cell-bottom-row">
                 <div class="grid-cell cell-2x" data-bet-type="2to1-1">2 to 1</div>
                 <div class="grid-cell cell-2x" data-bet-type="2to1-2">2 to 1</div>
                 <div class="grid-cell cell-2x" data-bet-type="2to1-3">2 to 1</div>
             </div>
        </div>


        <div id="player-seats" class="player-seats">
            </div>
         <div id="hot-table-banner" class="hidden">Hot Table!</div>
         <div id="near-miss-popup" class="near-miss-popup">Almost!</div>
         <div id="hot-streak-bar" class="hot-streak-bar hidden">
             <div class="hot-streak-fill"></div>
         </div>

         <button id="toggle-other-hands" class="hidden">Show/Hide Other Players</button> </div>

    <div id="bottom-bar">
        <div class="bottom-bar-section betting-controls">
            <span id="current-bet-display">Chip Value: 0.01 SOL</span> <div class="chip-selection-buttons">
                 <button data-chip-value="0.01" class="chip-button green-chip">+0.01</button>
                 <button data-chip-value="0.1" class="chip-button purple-chip">+0.1</button>
                 <button data-chip-value="1" class="chip-button gold-chip">+1</button> <button data-chip-value="5" class="chip-button red-chip">+5</button> <button data-chip-value="MAX" class="chip-button max-chip">🔥MAX</button>
            </div>
            <button id="clear-bets-button" style="margin-left: 10px; padding: 8px 15px; border: none; border-radius: 5px; background-color: #ef4444; color: #0a0a0a; font-weight: bold; cursor: pointer; min-width: 48px; min-height: 48px; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">Clear Bets</button> <button id="join-leave-button" class="join-leave-button join-button">Join Table</button>
             <span id="spectator-status" class="hidden" style="color: #facc15; font-size: 0.9em; margin-left: 10px;">You are a spectator.</span>
             <button id="refer-friends-button" style="margin-left: 10px; padding: 8px 15px; border: none; border-radius: 5px; background-color: #5b21b6; color: #fff; font-weight: bold; cursor: pointer; min-width: 48px; min-height: 48px; touch-action: manipulation; -webkit-tap-highlight-color: transparent;">🎁 Invite & Earn 0.05 SOL</button> </div>
        <div class="bottom-bar-section chat-container">
            <div id="chat-feed" class="chat-feed custom-scrollbar">
                </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Type message...">
                <button id="send-chat-button">Send</button>
            </div>
        </div>
         <button id="toggle-chat" class="hidden">Chat</button>
         <button id="spin-button" class="hidden">Spin!</button> </div>

    <canvas id="confetti-canvas"></canvas>
    <canvas id="background-particles" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0;"></canvas> <div id="profile-lounge-section" class="hidden">
        <div id="profile-lounge-content">
            <span id="profile-lounge-close">&times;</span>
            <h2>Profile / Lounge</h2>
            <div id="profile-content">
                <h3>👤 Your Profile</h3>
                <p>Avatar: <span id="profile-avatar">😊</span></p>
                <p>Level: <span id="profile-level">1</span></p>
                <div class="xp-bar-container" style="width: 100%;">
                    <div id="profile-xp-bar-fill" class="xp-bar-fill"></div>
                </div>
                <p>XP: <span id="profile-xp">0/100</span></p>
                <p>Win %: <span id="profile-win-rate">--</span></p>
                <p>Highest Wager: <span id="profile-highest-wager">--</span></p>
                <p>Longest Streak: <span id="profile-longest-streak">--</span></p>
                <h4>Badges:</h4>
                <ul id="profile-badges">
                    </ul>
                <p>Favorite Game: <span id="profile-favorite-game">Blackjack</span></p>
            </div>
            <div id="lounge-content" class="hidden">
                <h3>🛋️ Lounge</h3>
                <h4>Games:</h4>
                <div id="game-tabs">
                    <button data-game="blackjack" class="game-tab-button">Blackjack</button>
                    <button data-game="dice" class="game-tab-button">Dice (Coming Soon)</button>
                    <button data-game="roulette" class="game-tab-button">Roulette (Coming Soon)</button>
                    <button data-game="war" class="game-tab-button">War (Coming Soon)</button>
                </div>
                <h4>Live Leaderboards:</h4>
                <div id="lounge-leaderboards">
                    </div>
                <div id="lounge-chat" style="height: 200px; background: #222; margin-top: 10px; padding: 10px; overflow-y: auto;">
                    Lounge chat messages...
                </div>
            </div>
        </div>
    </div>


    <audio id="roulette-spin-sound" src="/assets/sounds/roulette-spin.mp3" preload="none"></audio> <audio id="ball-drop-sound" src="/assets/sounds/ball-drop.mp3" preload="none"></audio> <audio id="win-sound" src="/assets/sounds/win.mp3" preload="none"></audio>
    <audio id="loss-sound" src="/assets/sounds/loss.mp3" preload="none"></audio>
    <audio id="button-click-sound" src="/assets/sounds/button-click.mp3" preload="none"></audio>
    <audio id="coin-drop-sound" src="/assets/sounds/coin-drop.mp3" preload="none"></audio>
    <audio id="background-loop-sound" src="/assets/sounds/background-loop.mp3" preload="none" loop></audio>
    <audio id="chip-sound" src="/assets/sounds/chip.mp3" preload="none"></audio>
    <audio id="whoosh-sound" src="/assets/sounds/whoosh.mp3" preload="none"></audio>
    <audio id="card-thud-sound" src="/assets/sounds/card-thud.mp3" preload="none"></audio>
    <audio id="jackpot-sound" src="/assets/sounds/jackpot.mp3" preload="none"></audio>
    <audio id="crowd-cheer-sound" src="/assets/sounds/crowd-cheer.mp3" preload="none"></audio>
    <div id="floating-emoji-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20;"></div>


    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <script>
        // --- Constants ---
        const WS_RECONNECT_DELAY = 3000; // Milliseconds before attempting WebSocket reconnect
        const MAX_CHAT_MESSAGES = 50; // Maximum number of chat messages to display
        const XP_PER_LEVEL = 100; // XP required to level up
        const MAX_HOT_STREAK_DISPLAY = 10; // Max streak count for hot streak bar display
        const ROULETTE_SPIN_DURATION = 5000; // Default roulette spin duration in ms
        const BETTING_PHASE_DURATION = 20; // Default betting phase duration in seconds

        // --- Global State ---
        const gameState = {
            walletAddress: null,
            walletBalance: 0,
            userXP: parseInt(localStorage.getItem('userXP') || '0'), // Load from localStorage
            userLevel: parseInt(localStorage.getItem('userLevel') || '1'), // Load from localStorage
            // Roulette specific state
            rouletteNumbers: [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26], // European Roulette
            rouletteColors: { // Mapping numbers to colors
                0: 'green', 32: 'red', 15: 'black', 19: 'red', 4: 'black', 21: 'red', 2: 'black', 25: 'red', 17: 'black', 34: 'red', 6: 'black', 27: 'red', 13: 'black', 36: 'red', 11: 'black', 30: 'red', 8: 'black', 23: 'red', 10: 'black', 5: 'red', 24: 'black', 16: 'red', 33: 'black', 1: 'red', 20: 'black', 14: 'red', 31: 'black', 9: 'red', 22: 'black', 18: 'red', 29: 'black', 7: 'red', 28: 'black', 12: 'red', 35: 'black', 3: 'red', 26: 'black'
            },
            currentChipValue: 0.01, // Selected chip value for betting
            currentBets: {}, // Object storing bets: { 'betType': amount, 'number_X': amount, ... }
            winningNumber: null,
            spinAnimation: null, // For controlling the wheel animation
            spinDuration: ROULETTE_SPIN_DURATION, // milliseconds
            players: [], // Array of player objects { id, name, level, avatar, bets: {}, totalBet: 0 }
            activePlayerId: null, // Could represent the player whose turn it is to bet (optional)
            bettingPhaseDuration: BETTING_PHASE_DURATION, // seconds
            bettingPhaseTimer: null, // Interval timer for betting phase
            chatMessages: [], // Array of { sender, message, badge }
            recentPlays: [], // Array of { winningNumber, payout }
            isSpectator: false,
            isSeated: false,
            websocket: null,
            websocketReconnectAttempts: 0,
            websocketMaxReconnectAttempts: 10, // Limit reconnect attempts
            confettiCanvas: null,
            confettiCtx: null,
            backgroundParticlesCanvas: null, // New background particles canvas
            backgroundParticlesCtx: null, // New background particles context
            chatVisible: window.innerWidth > 768, // Chat visible by default on desktop
            otherHandsVisible: false, // State for mobile other hands toggle - repurposed for other players display
            backgroundSoundPlaying: false,
            isFreeMode: false, // Phase 2: Free Mode state
            referralCount: parseInt(localStorage.getItem('referralCount') || '0'), // New: Referral count
            // Add other state properties as needed
        };

        // --- DOM Elements ---
        const dom = {
            walletIcon: document.getElementById('wallet-icon'), // New wallet icon
            walletAddress: document.getElementById('wallet-address'),
            walletBalance: document.getElementById('wallet-balance'),
            connectWalletButton: document.getElementById('connect-wallet-button'),
            disconnectWalletButton: document.getElementById('disconnect-wallet-button'),
            phantomDeeplink: document.getElementById('phantom-deeplink'),
            walletGuidance: document.getElementById('wallet-guidance'),
            userLevel: document.getElementById('user-level'),
            xpBarFill: document.getElementById('xp-bar-fill'),
            userXP: document.getElementById('user-xp'),
            crateIcon: document.getElementById('crate-icon'),
            recentPlaysTicker: document.getElementById('recent-plays-ticker'),
            leaderboard: document.getElementById('leaderboard'), // New
            referralCount: document.getElementById('referral-count'), // New: Referral count
            settingsDropdown: document.getElementById('settings-dropdown'), // Placeholder
            freeModeToggle: document.getElementById('free-mode-toggle'), // Phase 2: Free Mode Toggle
            profileTabButton: document.getElementById('profile-tab-button'), // Phase 2: Profile Tab Button
            // Lounge tabs moved to settings dropdown for better organization
            // loungeTabButton: document.getElementById('lounge-tab-button'), // Phase 2: Lounge Tab Button
            profileLoungeSection: document.getElementById('profile-lounge-section'), // Phase 2: Profile/Lounge Section
            profileLoungeClose: document.getElementById('profile-lounge-close'), // Phase 2: Profile/Lounge Close Button
            profileContent: document.getElementById('profile-content'), // Phase 2: Profile Content
            loungeContent: document.getElementById('lounge-content'), // Phase 2: Lounge Content
            profileAvatar: document.getElementById('profile-avatar'), // Phase 2: Profile Avatar
            profileLevel: document.getElementById('profile-level'), // Phase 2: Profile Level
            profileXpBarFill: document.getElementById('profile-xp-bar-fill'), // Phase 2: Profile XP Bar
            profileXP: document.getElementById('profile-xp'), // Phase 2: Profile XP
            profileWinRate: document.getElementById('profile-win-rate'), // Phase 2: Profile Win Rate
            profileHighestWager: document.getElementById('profile-highest-wager'), // Phase 2: Profile Highest Wager
            profileLongestStreak: document.getElementById('profile-longest-streak'), // Phase 2: Profile Longest Streak
            profileBadges: document.getElementById('profile-badges'), // Phase 2: Profile Badges
            profileFavoriteGame: document.getElementById('profile-favorite-game'), // Phase 2: Profile Favorite Game
            gameTabs: document.getElementById('game-tabs'), // Phase 2: Game Tabs
            loungeLeaderboards: document.getElementById('lounge-leaderboards'), // Phase 2: Lounge Leaderboards
            loungeChat: document.getElementById('lounge-chat'), // Phase 2: Lounge Chat

            // Roulette specific DOM
            rouletteWheelContainer: document.getElementById('roulette-wheel-container'),
            rouletteWheelCanvas: document.getElementById('roulette-wheel-canvas'),
            winningNumberDisplay: document.getElementById('winning-number-display'),
            bettingGridContainer: document.getElementById('betting-grid-container'),
            bettingGrid: document.getElementById('betting-grid'),
            chipSelectionButtons: document.querySelectorAll('.chip-selection-buttons button'), // New
            clearBetsButton: document.getElementById('clear-bets-button'), // New
            spinButton: document.getElementById('spin-button'), // Renamed

            playerSeats: document.getElementById('player-seats'), // Still used for player list
            dealerAnchor: document.querySelector('.dealer-anchor'), // Repurposed
            dealerEmoji: document.getElementById('dealer-emoji'), // Repurposed
            hotTableBanner: document.getElementById('hot-table-banner'), // New
            nearMissPopup: document.getElementById('near-miss-popup'), // New
            hotStreakBar: document.getElementById('hot-streak-bar'), // New
            toggleOtherHandsButton: document.getElementById('toggle-other-hands'), // New
            currentBetDisplay: document.getElementById('current-bet-display'), // Repurposed for chip value

            joinLeaveButton: document.getElementById('join-leave-button'),
            spectatorStatus: document.getElementById('spectator-status'),
            referFriendsButton: document.getElementById('refer-friends-button'), // New
            chatContainer: document.querySelector('.chat-container'), // New
            chatFeed: document.getElementById('chat-feed'),
            chatInput: document.getElementById('chat-input'),
            sendChatButton: document.getElementById('send-chat-button'),
            toggleChatButton: document.getElementById('toggle-chat'), // New

            confettiCanvas: document.getElementById('confetti-canvas'),
            backgroundParticlesCanvas: document.getElementById('background-particles'), // New background particles canvas
            floatingEmojiContainer: document.getElementById('floating-emoji-container'), // New: Floating emoji container
            // Audio Elements
            rouletteSpinSound: document.getElementById('roulette-spin-sound'), // New
            ballDropSound: document.getElementById('ball-drop-sound'), // New
            winSound: document.getElementById('win-sound'),
            lossSound: document.getElementById('loss-sound'),
            buttonClickSound: document.getElementById('button-click-sound'),
            coinDropSound: document.getElementById('coin-drop-sound'), // New Coin Drop Sound
            backgroundLoopSound: document.getElementById('background-loop-sound'), // New Background Loop
            chipSound: document.getElementById('chip-sound'), // New Chip Sound
            whooshSound: document.getElementById('whoosh-sound'), // New Whoosh Sound
            cardThudSound: document.getElementById('card-thud-sound'), // New Card Thud Sound - maybe not needed for roulette
            jackpotSound: document.getElementById('jackpot-sound'), // New Jackpot Sound
            crowdCheerSound: document.getElementById('crowd-cheer-sound'), // New Crowd Cheer Sound
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Canvases
            dom.confettiCanvas = document.getElementById('confetti-canvas');
            dom.confettiCtx = dom.confettiCanvas.getContext('2d');
            dom.backgroundParticlesCanvas = document.getElementById('background-particles');
            dom.backgroundParticlesCtx = dom.backgroundParticlesCanvas.getContext('2d');
            dom.rouletteWheelCanvas = document.getElementById('roulette-wheel-canvas');
            gameState.rouletteWheelCtx = dom.rouletteWheelCanvas.getContext('2d'); // Store wheel context in gameState

            resizeCanvases(); // Set initial size
            window.addEventListener('resize', resizeCanvases); // Resize on window resize

            // Start background particles animation
            startBackgroundParticlesAnimation();

            // Draw the initial roulette wheel
            drawRouletteWheel();

            // Generate the betting grid
            generateBettingGrid();

            // Set initial UI state
            updateUI();

            // Setup Event Listeners
            setupEventListeners();

            // Attempt to auto-connect wallet
            checkAutoConnectWallet();

            // Connect to WebSocket
            connectWebSocket();

            // Check for Daily Reward
            checkForDailyReward();

            // Placeholder: Simulate some initial game state for testing UI layout
            simulateInitialGameStateRoulette(); // Use a different simulation function

             // Play background sound on first user interaction (e.g., click anywhere)
             document.body.addEventListener('click', playBackgroundSound, { once: true });
             document.body.addEventListener('touchstart', playBackgroundSound, { once: true }); // Add touchstart fallback
        });

        // Resize Canvases function
        function resizeCanvases() {
            dom.confettiCanvas.width = window.innerWidth;
            dom.confettiCanvas.height = window.innerHeight;
            dom.backgroundParticlesCanvas.width = window.innerWidth;
            dom.backgroundParticlesCanvas.height = window.innerHeight;
            // Resize roulette wheel canvas while maintaining aspect ratio
            const wheelContainerSize = Math.min(dom.rouletteWheelContainer.offsetWidth, dom.rouletteWheelContainer.offsetHeight);
            dom.rouletteWheelCanvas.width = wheelContainerSize;
            dom.rouletteWheelCanvas.height = wheelContainerSize;
            drawRouletteWheel(); // Redraw wheel after resizing
        }


        // --- Solana Wallet Integration (using window.solana) ---
        async function checkAutoConnectWallet() {
             const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);

            if (window.solana && window.solana.isConnected) {
                try {
                    // Attempt to connect silently if already authorized
                    await window.solana.connect({ onlyIfTrusted: true });
                    handleWalletConnected(window.solana.publicKey);
                } catch (error) {
                    console.error('Auto-connect failed:', error);
                     if (isIOS) {
                         showPhantomDeeplink();
                     } else {
                         showWalletGuidance('Please install Phantom wallet.');
                     }
                }
            } else if (isIOS) {
                 showPhantomDeeplink();
            } else {
                 showWalletGuidance('Please install Phantom wallet or another Solana wallet.');
            }
        }

        async function connectWallet() {
             const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);

            if (window.solana) {
                try {
                    const response = await window.solana.connect();
                    handleWalletConnected(response.publicKey);
                } catch (error) {
                    console.error('Wallet connection failed:', error);
                     if (isIOS) {
                         showPhantomDeeplink();
                     } else {
                         showWalletGuidance(`Wallet connection failed: ${error.message}. Please try again or install Phantom.`); // More specific error
                     }
                }
            } else {
                 if (isIOS) {
                     showPhantomDeeplink();
                 } else {
                     showWalletGuidance('Solana wallet not found! Please install Phantom, Backpack, Solflare, or Coinbase wallet.');
                 }
            }
        }

        async function disconnectWallet() {
            if (window.solana && window.solana.isConnected) {
                try {
                    await window.solana.disconnect();
                    handleWalletDisconnected();
                } catch (error) {
                    console.error('Wallet disconnection failed:', error);
                }
            }
        }

        function handleWalletConnected(publicKey) {
            gameState.walletAddress = publicKey.toBase58();
            dom.walletAddress.textContent = `${gameState.walletAddress.slice(0, 4)}...${gameState.walletAddress.slice(-4)}`;
            dom.connectWalletButton.classList.add('hidden');
            dom.disconnectWalletButton.classList.remove('hidden');
            dom.phantomDeeplink.classList.add('hidden');
            dom.walletGuidance.classList.add('hidden');
            dom.walletIcon.classList.remove('hidden'); // Show wallet icon
            fetchWalletBalance(publicKey); // Fetch balance on connect
            updateUI(); // Update UI based on connected state
        }

        function handleWalletDisconnected() {
            gameState.walletAddress = null;
            gameState.walletBalance = 0;
            dom.walletAddress.textContent = 'Not Connected';
            dom.walletBalance.textContent = '-- SOL';
            dom.connectWalletButton.classList.remove('hidden');
            dom.disconnectWalletButton.classList.add('hidden');
             dom.phantomDeeplink.classList.add('hidden'); // Hide deeplink on disconnect
             dom.walletGuidance.classList.add('hidden'); // Hide guidance on disconnect
             dom.walletIcon.classList.add('hidden'); // Hide wallet icon
            updateUI(); // Update UI based on disconnected state
        }

        async function fetchWalletBalance(publicKey) {
             // Placeholder: In a real app, use Solana Web3.js Connection object
             // Example:
             // const connection = new Connection(Solana.Web3.clusterApiUrl('devnet'), 'confirmed');
             // try {
             //   const balance = await connection.getBalance(publicKey);
             //   gameState.walletBalance = balance / 10**9; // Convert lamports to SOL
             //   dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;
             // } catch (error) {
             //   console.error('Failed to fetch balance:', error);
             //   dom.walletBalance.textContent = 'Error';
             // }


             // Simulate fetching balance
             setTimeout(() => {
                 gameState.walletBalance = Math.random() * 5 + 1; // Random balance between 1 and 6
                 dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;
             }, 500);
         }

         function showPhantomDeeplink() {
             const currentUrl = window.location.href;
             // IMPORTANT: Replace with your actual game URL
             const deeplinkUrl = `https://phantom.app/ul/v1/browse?url=${encodeURIComponent(currentUrl)}`;
             dom.phantomDeeplink.href = deeplinkUrl;
             dom.phantomDeeplink.classList.remove('hidden');
             dom.walletGuidance.classList.remove('hidden');
             dom.walletGuidance.textContent = 'For iOS, use Phantom\'s in-app browser:';
             dom.connectWalletButton.classList.add('hidden'); // Hide connect button if deeplink shown
         }

         function showWalletGuidance(message) {
             dom.walletGuidance.textContent = message;
             dom.walletGuidance.classList.remove('hidden');
             dom.phantomDeeplink.classList.add('hidden');
         }


        // --- WebSocket Integration ---
        function connectWebSocket() {
            // Replace with your actual WebSocket server URL
            const wsUrl = "wss://your-game-server-url"; // TODO: Replace with actual server URL
            gameState.websocket = new WebSocket(wsUrl);

            gameState.websocket.onopen = () => {
                console.log("WebSocket Connected");
                gameState.websocketReconnectAttempts = 0; // Reset reconnect attempts on successful connection
                 // Display connection status
                 updateConnectionStatus(true);

                // Send initial message, e.g., join game, if wallet is connected
                if (gameState.walletAddress) {
                     sendMessage({ type: 'joinRoulette', wallet: gameState.walletAddress }); // Changed message type
                } else {
                     // Maybe join as spectator if not connected? Depends on backend logic.
                     sendMessage({ type: 'joinRouletteAsSpectator' }); // Changed message type
                }
                 // Trigger confetti on join (optional addictive UX)
                triggerConfettiOnJoin();
            };

            gameState.websocket.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    console.log("WebSocket Message:", msg);
                    handleGameEvent(msg);
                } catch (error) {
                    console.error("Error parsing WebSocket message:", error);
                    showErrorMessage("Received invalid data from server.");
                }
            };

            gameState.websocket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                 // Display connection status and error message
                 updateConnectionStatus(false, "Connection Error");
                // Handle errors, attempt reconnect
            };

            gameState.websocket.onclose = (event) => {
                console.log("WebSocket Disconnected:", event.code, event.reason);
                 // Display connection status
                 updateConnectionStatus(false, `Disconnected: ${event.code}`);
                // Attempt to reconnect if not a clean close or if reconnect attempts are within limit
                if (!event.wasClean && gameState.websocketReconnectAttempts < gameState.websocketMaxReconnectAttempts) {
                    gameState.websocketReconnectAttempts++;
                    console.log(`Attempting WebSocket reconnect ${gameState.websocketReconnectAttempts}/${gameState.websocketMaxReconnectAttempts}...`);
                    setTimeout(connectWebSocket, WS_RECONNECT_DELAY);
                } else if (!event.wasClean) {
                    showErrorMessage("Lost connection to the game server. Please refresh the page.");
                }
            };
        }

        function sendMessage(message) {
            if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                gameState.websocket.send(JSON.stringify(message));
            } else {
                console.warn("WebSocket not connected. Cannot send message:", message);
                 // Display error message to user (placeholder)
                 showErrorMessage("Game server not connected. Please try refreshing.");
                // Maybe queue messages or try to reconnect
            }
        }

        // New: Update Connection Status Display
        function updateConnectionStatus(isConnected, message = "") {
             const statusElement = document.getElementById('connection-status'); // Assuming you add this element in HTML
             if (statusElement) {
                 statusElement.textContent = isConnected ? "Online" : `Offline: ${message}`;
                 statusElement.style.color = isConnected ? '#10b981' : '#ef4444';
             }
        }

        // New: Show User-Facing Error Message (Placeholder)
        function showErrorMessage(message) {
             console.error("User Error:", message);
             // Implement a temporary message display in the UI (e.g., a small banner)
             alert(message); // Replace with inline display
        }

        // Basic input sanitization to prevent XSS
        function sanitizeInput(input) {
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML; // Returns sanitized string
        }


        // Handle incoming WebSocket messages (Roulette specific)
        function handleGameEvent(msg) {
            switch (msg.type) {
                case 'table_state':
                    // Update entire table state
                    gameState.players = msg.data.players;
                    gameState.currentBets = msg.data.currentBets || {}; // Update current bets
                    gameState.winningNumber = msg.data.winningNumber || null; // Update winning number
                    gameState.isSpectator = msg.data.isSpectator;
                    gameState.isSeated = msg.data.isSeated; // Assuming backend sends this
                    // Update betting phase timer display
                    updateBettingPhaseTimer(msg.data.bettingPhaseRemaining || 0);

                    updateUI();
                    // If winning number is present, animate the wheel to it
                    if (gameState.winningNumber !== null) {
                         animateRouletteWheelTo(gameState.winningNumber);
                    } else {
                         // Reset wheel position if no winning number
                         resetRouletteWheel();
                    }
                    break;
                case 'bet_placed':
                    // Update specific bet on the grid
                    const bet = msg.data; // { playerId, betType, amount }
                    // Find the player and update their bets
                    const player = gameState.players.find(p => p.id === bet.playerId);
                    if (player) {
                         player.bets[bet.betType] = (player.bets[bet.betType] || 0) + bet.amount;
                         player.totalBet = (player.totalBet || 0) + bet.amount;
                         renderPlayerSeats(); // Update player seat display
                    }
                    // If the bet is by the current user, update their local bets and display
                    if (bet.playerId === gameState.walletAddress) {
                         gameState.currentBets[bet.betType] = (gameState.currentBets[bet.betType] || 0) + bet.amount;
                         renderPlacedChips(); // Re-render chips on the grid
                         playSound(dom.chipSound); // Play chip sound
                         triggerHaptic([50]); // Haptic feedback
                    }
                    break;
                case 'betting_phase_start':
                    // Start the betting phase timer and enable betting
                    gameState.winningNumber = null; // Clear previous winning number
                    dom.winningNumberDisplay.textContent = '--';
                    gameState.currentBets = {}; // Clear local bets
                    renderPlacedChips(); // Remove chips from grid
                    enableBetting();
                    startBettingPhaseTimer(msg.data.duration || gameState.bettingPhaseDuration);
                    hideSpinButton(); // Hide spin button during betting
                    // Add dealer glow during betting phase (placeholder)
                    dom.dealerAnchor.classList.add('glowing');
                    break;
                case 'betting_phase_end':
                    // Stop the betting phase timer and disable betting
                    disableBetting();
                    stopBettingPhaseTimer();
                    showSpinButton(); // Show spin button (or wait for server spin command)
                    dom.dealerAnchor.classList.remove('glowing'); // Remove dealer glow
                    break;
                case 'spin_start':
                    // Start the wheel spin animation
                    animateRouletteWheel(msg.data.spinDuration || gameState.spinDuration);
                    playSound(dom.rouletteSpinSound); // Play spin sound
                    hideSpinButton(); // Hide spin button
                    break;
                case 'spin_result':
                    // Stop the wheel animation at the winning number and show result
                    gameState.winningNumber = msg.data.winningNumber;
                    dom.winningNumberDisplay.textContent = gameState.winningNumber;
                    animateRouletteWheelTo(gameState.winningNumber);
                    playSound(dom.ballDropSound); // Play ball drop sound
                    // Trigger win/loss animations and sounds based on result
                    if (msg.data.userWon) { // Assuming backend sends userWon flag and payout
                         triggerConfetti();
                         triggerCoinShower();
                         playSound(dom.winSound);
                         playSound(dom.jackpotSound);
                         playSound(dom.crowdCheerSound);
                         triggerHaptic([100, 50, 100]); // Win haptic
                         showWinBanner(msg.data.payout);
                         triggerFloatingWinEmojis();
                         // Add shake animation to user's seat (placeholder)
                         const userSeat = document.getElementById(`player-seat-${gameState.walletAddress}`);
                         if (userSeat) {
                             userSeat.style.animation = 'none';
                             userSeat.offsetHeight;
                             userSeat.style.animation = 'shake 0.5s ease-in-out';
                         }
                    } else {
                         playSound(dom.lossSound);
                         triggerHaptic([200]); // Loss haptic
                         showLossAversionMessage();
                    }
                    // Update recent plays ticker with result
                    updateRecentPlaysTicker(); // Will need to adapt this function for Roulette results
                    break;
                case 'xp_update':
                    // Update user XP and level
                    gameState.userXP = msg.data.newXP;
                    gameState.userLevel = msg.data.newLevel;
                    localStorage.setItem('userXP', gameState.userXP); // Persist XP
                    localStorage.setItem('userLevel', gameState.userLevel); // Persist Level
                    updateXPBar();
                    if (msg.data.levelUp) {
                        showCrateIcon();
                         triggerLevelUpAnimation();
                    }
                    break;
                case 'crate_awarded':
                    showCrateIcon();
                    break;
                case 'chat_message':
                    // Sanitize incoming chat message
                    msg.data.message = sanitizeInput(msg.data.message);
                    gameState.chatMessages.push(msg.data);
                    addChatMessageToFeed(msg.data);
                    break;
                 case 'hot_table':
                     if (msg.data.isActive) {
                         dom.hotTableBanner.textContent = msg.data.message || 'Hot Table!';
                         dom.hotTableBanner.classList.remove('hidden');
                     } else {
                         dom.hotTableBanner.classList.add('hidden');
                     }
                     break;
                 case 'near_miss':
                     // Near miss concept is different in Roulette, might need adaptation
                     showNearMissPopup(msg.data.message || 'Close Call!'); // Changed message
                     triggerHaptic([100, 100, 100, 100]); // Heartbeat haptic for near miss
                     break;
                 case 'hot_streak_update':
                     updateHotStreakBar(msg.data.streakCount);
                     if (msg.data.milestone) {
                         triggerHaptic([100, 50, 100, 50, 100]);
                     }
                     break;
                 case 'leaderboard_update':
                     updateLeaderboard(msg.data.leaderboard);
                     break;
                 case 'mystery_event':
                     showMysteryEvent(msg.data);
                     break;
                // Handle other event types as needed
                default:
                    console.warn("Unknown WebSocket message type:", msg.type);
            }
        }

        // --- UI Rendering Functions ---

        function updateUI() {
            updateXPBar();
            updateRecentPlaysTicker(); // Needs adaptation for Roulette results
            renderPlayerSeats(); // Needs adaptation for Roulette player info
            updateBettingControls(); // Needs adaptation for chip selection
            renderChatFeed();
            updateChatContainerVisibility();
            updateOtherHandsVisibility(); // Needs adaptation for showing other players/bets
            updateLeaderboard(gameState.leaderboard || []);
            updateFreeModeToggleText();
            updateReferralCountDisplay();
            renderPlacedChips(); // Render chips based on currentBets
        }

        function updateXPBar() {
            dom.userLevel.textContent = `Level ${gameState.userLevel}`;
            const xpProgress = gameState.userXP % XP_PER_LEVEL; // Using constant
            dom.xpBarFill.style.width = `${xpProgress}%`;
            dom.userXP.textContent = `${xpProgress}/${XP_PER_LEVEL} XP`; // Using constant
        }

        function showCrateIcon() {
            dom.crateIcon.classList.remove('hidden');
            dom.crateIcon.onclick = openCrate; // Assign click handler
        }

        function openCrate() {
             console.log("Crate opened!");
             dom.crateIcon.classList.add('hidden');
             showInfoMessage("You got a reward!"); // Use a better message display
         }

         function triggerLevelUpAnimation() {
             console.log("Triggering level up animation!");
             dom.userLevel.style.transition = 'color 0.3s ease-in-out';
             dom.userLevel.style.color = '#facc15'; // Yellow sparkle color
             setTimeout(() => {
                 dom.userLevel.style.color = '#eee'; // Revert color
             }, 500);
         }


        function updateRecentPlaysTicker() {
            dom.recentPlaysTicker.innerHTML = ''; // Clear current ticker
            if (gameState.recentPlays.length === 0) {
                dom.recentPlaysTicker.textContent = 'No recent plays...';
                return;
            }
            const tickerContent = document.createElement('span');
            gameState.recentPlays.forEach(play => {
                const span = document.createElement('span');
                 // Adapt for Roulette results: Winning Number and Payout
                span.classList.add('recent-play-item', play.payout > 0 ? 'win' : 'loss'); // Win if payout > 0
                span.textContent = `Result: ${play.winningNumber} • Payout: ${play.payout.toFixed(2)} SOL • `; // Example format
                tickerContent.appendChild(span);
            });
             if (tickerContent.lastChild) {
                 tickerContent.lastChild.textContent = tickerContent.lastChild.textContent.slice(0, -2);
             }
            dom.recentPlaysTicker.appendChild(tickerContent);

            tickerContent.style.animation = 'none'; // Reset animation
            tickerContent.offsetHeight; // Trigger reflow
            tickerContent.style.animation = `slide-left 15s linear infinite`; // Apply animation
        }

        function updateLeaderboard(leaderboardData) {
             dom.leaderboard.innerHTML = ''; // Clear current leaderboard
             if (!leaderboardData || leaderboardData.length === 0) {
                 dom.leaderboard.textContent = 'Leaderboard: --';
                 return;
             }
             const leaderboardTitle = document.createElement('span');
             leaderboardTitle.textContent = 'Leaderboard: ';
             leaderboardTitle.style.fontWeight = 'bold';
             dom.leaderboard.appendChild(leaderboardTitle);

             leaderboardData.forEach((entry, index) => {
                 const entrySpan = document.createElement('span');
                 // Adapt for Roulette leaderboard (e.g., total won, biggest win)
                 entrySpan.textContent = `${index + 1}. ${entry.player}: ${entry.totalWon.toFixed(2)} SOL | `; // Example format
                 dom.leaderboard.appendChild(entrySpan);
             });
        }

        function updateReferralCountDisplay() {
            dom.referralCount.textContent = `👥 ${gameState.referralCount} referrals`;
        }

        // --- Roulette Specific Rendering ---

        function drawRouletteWheel() {
            const canvas = dom.rouletteWheelCanvas;
            const ctx = gameState.rouletteWheelCtx;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9; // Wheel radius
            const segmentAngle = (Math.PI * 2) / gameState.rouletteNumbers.length;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            gameState.rouletteNumbers.forEach((number, index) => {
                const startAngle = index * segmentAngle;
                const endAngle = (index + 1) * segmentAngle;
                const color = gameState.rouletteColors[number];

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();

                ctx.fillStyle = color;
                ctx.fill();

                // Draw number text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2); // Rotate to the center of the segment
                ctx.textAlign = 'center';
                ctx.fillStyle = '#eee'; // Text color
                ctx.font = `${radius * 0.1}px Arial`; // Adjust font size based on radius
                ctx.fillText(number, radius * 0.7, 0); // Position text
                ctx.restore();

                 // Draw separators
                 ctx.beginPath();
                 ctx.moveTo(centerX, centerY);
                 ctx.arc(centerX, centerY, radius, startAngle, startAngle);
                 ctx.lineTo(centerX + Math.cos(startAngle) * radius, centerY + Math.sin(startAngle) * radius);
                 ctx.strokeStyle = '#333'; // Separator color
                 ctx.lineWidth = 2;
                 ctx.stroke();
            });

             // Draw inner circle (for the ball path)
             const innerRadius = radius * 0.8;
             ctx.beginPath();
             ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
             ctx.fillStyle = '#1a1a1a'; // Dark inner circle
             ctx.fill();
             ctx.strokeStyle = '#555'; // Border
             ctx.lineWidth = 3;
             ctx.stroke();

             // Draw the ball (placeholder)
             drawRouletteBall(centerX, centerY, innerRadius);
        }

        function drawRouletteBall(centerX, centerY, innerRadius, angle = 0) {
             const ctx = gameState.rouletteWheelCtx;
             const ballRadius = innerRadius * 0.1; // Ball size relative to inner circle
             const ballX = centerX + Math.cos(angle) * (innerRadius - ballRadius - 5); // Position slightly inside the path
             const ballY = centerY + Math.sin(angle) * (innerRadius - ballRadius - 5);

             ctx.beginPath();
             ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
             ctx.fillStyle = '#eee'; // White ball
             ctx.shadowColor = '#ffd700'; // Gold glow
             ctx.shadowBlur = 10;
             ctx.fill();
             ctx.shadowColor = 'transparent'; // Reset shadow
        }

        function animateRouletteWheel(duration) {
            const canvas = dom.rouletteWheelCanvas;
            const ctx = gameState.rouletteWheelCtx;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9;
            const innerRadius = radius * 0.8;
            const startTime = performance.now();
            let currentRotation = 0;
            let ballAngle = 0; // Ball position

            function spin(currentTime) {
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1); // Animation progress (0 to 1)

                // Easing function for spin (starts fast, slows down)
                const easedProgress = 1 - Math.pow(1 - progress, 3); // Cubic easing out

                // Calculate rotation - Spin multiple times
                const totalRotations = 10; // Spin 10 full times
                currentRotation = (totalRotations * easedProgress) * (Math.PI * 2); // Total rotation in radians

                 // Calculate ball movement (opposite direction of wheel)
                 const ballSpeedFactor = 1.5; // Ball moves faster than wheel
                 ballAngle = (totalRotations * easedProgress * ballSpeedFactor) * (Math.PI * 2);


                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(currentRotation);

                // Redraw wheel segments (without numbers for performance during spin)
                const segmentAngle = (Math.PI * 2) / gameState.rouletteNumbers.length;
                 gameState.rouletteNumbers.forEach((number, index) => {
                     const startAngle = index * segmentAngle;
                     const endAngle = (index + 1) * segmentAngle;
                     const color = gameState.rouletteColors[number];

                     ctx.beginPath();
                     ctx.moveTo(0, 0); // Translate already applied
                     ctx.arc(0, 0, radius, startAngle, endAngle);
                     ctx.closePath();
                     ctx.fillStyle = color;
                     ctx.fill();
                      // Draw separators
                     ctx.beginPath();
                     ctx.moveTo(0, 0);
                     ctx.arc(0, 0, radius, startAngle, startAngle);
                     ctx.lineTo(Math.cos(startAngle) * radius, Math.sin(startAngle) * radius);
                     ctx.strokeStyle = '#333';
                     ctx.lineWidth = 2;
                     ctx.stroke();
                 });

                 // Redraw inner circle
                 ctx.beginPath();
                 ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                 ctx.fillStyle = '#1a1a1a';
                 ctx.fill();
                 ctx.strokeStyle = '#555';
                 ctx.lineWidth = 3;
                 ctx.stroke();

                ctx.restore();

                 // Draw the ball (relative to the canvas, not rotated)
                 drawRouletteBall(centerX, centerY, innerRadius, ballAngle);


                if (progress < 1) {
                    gameState.spinAnimation = requestAnimationFrame(spin);
                } else {
                    // Animation finished, wait for spin_result message
                    gameState.spinAnimation = null;
                }
            }

            gameState.spinAnimation = requestAnimationFrame(spin);
        }

         function animateRouletteWheelTo(winningNumber) {
             cancelAnimationFrame(gameState.spinAnimation); // Stop current animation if any

             const canvas = dom.rouletteWheelCanvas;
             const ctx = gameState.rouletteWheelCtx;
             const centerX = canvas.width / 2;
             const centerY = canvas.height / 2;
             const radius = Math.min(centerX, centerY) * 0.9;
             const innerRadius = radius * 0.8;
             const segmentAngle = (Math.PI * 2) / gameState.rouletteNumbers.length;

             // Find the angle for the winning number
             const winningIndex = gameState.rouletteNumbers.indexOf(winningNumber);
             // Calculate the target angle. Need to account for the wheel's current rotation
             // and make sure the ball lands in the correct segment.
             // This is a simplified calculation. A real implementation would need more precise physics.
             const targetAngle = winningIndex * segmentAngle + segmentAngle / 2; // Center of the winning segment
             const currentRotation = 0; // Assuming wheel is reset or we track its rotation
             const startAngle = currentRotation; // Start from current position

             const animationDuration = 3000; // Duration to slow down and stop
             const startTime = performance.now();

             function stopSpin(currentTime) {
                 const elapsedTime = currentTime - startTime;
                 const progress = Math.min(elapsedTime / animationDuration, 1); // Animation progress

                 // Easing function for stopping (starts fast, slows down)
                 const easedProgress = Math.pow(progress, 3); // Cubic easing in

                 // Calculate rotation - Slow down to the target angle
                 // This is a simplified approach. A more realistic spin-down is complex.
                 // We'll just interpolate from a fast spin to the target angle.
                 const initialSpinSpeed = 5 * (Math.PI * 2); // Start with a few fast rotations
                 const currentAngle = startAngle + (targetAngle - startAngle + initialSpinSpeed) * (1 - easedProgress);

                 // Ball movement - Slow down with the wheel
                 const ballAngle = (currentAngle + Math.PI / 2) % (Math.PI * 2); // Keep ball ahead slightly


                 ctx.save();
                 ctx.translate(centerX, centerY);
                 ctx.rotate(currentAngle);

                 // Redraw wheel segments with numbers
                 const segmentAngle = (Math.PI * 2) / gameState.rouletteNumbers.length;
                 gameState.rouletteNumbers.forEach((number, index) => {
                     const startAngle = index * segmentAngle;
                     const endAngle = (index + 1) * segmentAngle;
                     const color = gameState.rouletteColors[number];

                     ctx.beginPath();
                     ctx.moveTo(0, 0);
                     ctx.arc(0, 0, radius, startAngle, endAngle);
                     ctx.closePath();
                     ctx.fillStyle = color;
                     ctx.fill();
                      // Draw separators
                     ctx.beginPath();
                     ctx.moveTo(0, 0);
                     ctx.arc(0, 0, radius, startAngle, startAngle);
                     ctx.lineTo(Math.cos(startAngle) * radius, Math.sin(startAngle) * radius);
                     ctx.strokeStyle = '#333';
                     ctx.lineWidth = 2;
                     ctx.stroke();

                     // Draw number text
                     ctx.save();
                     ctx.rotate(startAngle + segmentAngle / 2); // Rotate to the center of the segment
                     ctx.textAlign = 'center';
                     ctx.fillStyle = '#eee'; // Text color
                     ctx.font = `${radius * 0.1}px Arial`; // Adjust font size based on radius
                     ctx.fillText(number, radius * 0.7, 0); // Position text
                     ctx.restore();
                 });

                 // Redraw inner circle
                 ctx.beginPath();
                 ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                 ctx.fillStyle = '#1a1a1a';
                 ctx.fill();
                 ctx.strokeStyle = '#555';
                 ctx.lineWidth = 3;
                 ctx.stroke();

                ctx.restore();

                 // Draw the ball (relative to the canvas, not rotated)
                 drawRouletteBall(centerX, centerY, innerRadius, ballAngle);


                 if (progress < 1) {
                     gameState.spinAnimation = requestAnimationFrame(stopSpin);
                 } else {
                     // Animation finished
                     gameState.spinAnimation = null;
                     // Ensure the wheel is drawn correctly at the final position with numbers
                     drawRouletteWheel();
                 }
             }

             gameState.spinAnimation = requestAnimationFrame(stopSpin);
         }

         function resetRouletteWheel() {
             cancelAnimationFrame(gameState.spinAnimation);
             drawRouletteWheel(); // Draw the wheel in its default state
             dom.winningNumberDisplay.textContent = '--';
         }


        function generateBettingGrid() {
            const grid = dom.bettingGrid;
            grid.innerHTML = ''; // Clear existing grid

            // Numbers 1-36
            const numbers = Array.from({ length: 36 }, (_, i) => i + 1);
            numbers.forEach(number => {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell', 'cell-number');
                cell.textContent = number;
                cell.dataset.betType = `number_${number}`;
                 // Add color class
                 if (gameState.rouletteColors[number] === 'red') {
                     cell.classList.add('cell-red');
                 } else {
                     cell.classList.add('cell-black');
                 }
                grid.appendChild(cell);
            });

            // Add the 0 cell
            const cell0 = document.createElement('div');
            cell0.classList.add('grid-cell', 'cell-0');
            cell0.textContent = '0';
            cell0.dataset.betType = 'number_0';
            grid.insertBefore(cell0, grid.firstChild); // Insert at the beginning

             // Add click listeners to grid cells for betting
             dom.bettingGridContainer.querySelectorAll('.grid-cell').forEach(cell => {
                 cell.addEventListener('click', handleBetPlacement);
             });
        }

        function handleBetPlacement(event) {
             if (!gameState.isSeated || gameState.isSpectator) {
                 showErrorMessage("You must be seated to place bets.");
                 return;
             }
             if (gameState.currentChipValue <= 0) {
                 showErrorMessage("Select a chip value first.");
                 return;
             }
             // Client-side validation: Check if user has enough balance
             if (gameState.walletBalance < gameState.currentChipValue) {
                 showErrorMessage("Insufficient balance to place this bet.");
                 return;
             }


             const betType = event.target.dataset.betType;
             const amount = gameState.currentChipValue;

             // Placeholder: Send bet to server
             sendMessage({ type: 'placeBet', betType: betType, amount: amount });

             // Optimistic UI update (assuming server will confirm)
             gameState.currentBets[betType] = (gameState.currentBets[betType] || 0) + amount;
             // Deduct bet amount from local balance optimistically
             gameState.walletBalance -= amount;
             dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;

             renderPlacedChips(); // Re-render chips
             playSound(dom.chipSound); // Play chip sound
             triggerHaptic([50]); // Haptic feedback
        }

        function renderPlacedChips() {
             // Remove existing chips
             dom.bettingGridContainer.querySelectorAll('.placed-chip').forEach(chip => chip.remove());

             // Place new chips based on gameState.currentBets
             for (const betType in gameState.currentBets) {
                 if (gameState.currentBets[betType] > 0) {
                     const targetCell = dom.bettingGridContainer.querySelector(`[data-bet-type="${betType}"]`);
                     if (targetCell) {
                         const chip = document.createElement('div');
                         chip.classList.add('placed-chip');
                         chip.textContent = gameState.currentBets[betType]; // Display bet amount
                         // Position chip randomly within the cell for multiple chips
                         chip.style.left = `${Math.random() * 50 + 25}%`; // Random left position
                         chip.style.top = `${Math.random() * 50 + 25}%`; // Random top position
                         // Add color based on chip value (placeholder)
                         chip.style.backgroundColor = getChipColor(gameState.currentBets[betType]);

                         targetCell.appendChild(chip);
                     }
                 }
             }
        }

        function getChipColor(amount) {
             // Placeholder: Map bet amount to chip color
             if (amount >= 5) return 'red';
             if (amount >= 1) return 'gold';
             if (amount >= 0.1) return 'purple';
             return 'green';
        }


        function renderPlayerSeats() {
            dom.playerSeats.innerHTML = ''; // Clear current seats
            const isMobile = window.innerWidth <= 768;

            gameState.players.forEach(player => {
                 // Only show other players if otherHandsVisible is true (on mobile) or always on desktop
                 if (player.id !== gameState.walletAddress && isMobile && !gameState.otherHandsVisible) {
                     return; // Skip rendering other players if hidden on mobile
                 }

                const seatElement = document.createElement('div');
                seatElement.classList.add('player-seat');
                 seatElement.id = `player-seat-${player.id}`;

                 if (player.id === gameState.walletAddress) {
                     seatElement.classList.add('is-user'); // Mark the user's seat
                 }
                if (player.id === gameState.activePlayerId) { // Active player might be the one whose turn it is to bet
                    seatElement.classList.add('active');
                }

                // Player Info
                const playerInfo = document.createElement('div');
                playerInfo.classList.add('player-info');
                const avatar = document.createElement('div');
                avatar.classList.add('avatar');
                 if (player.isVIP) {
                     avatar.classList.add('vip');
                 }
                avatar.textContent = player.avatar || '😊'; // Placeholder avatar
                const username = document.createElement('span');
                username.classList.add('username');
                username.textContent = player.name || 'Player';
                const xpBadge = document.createElement('span');
                xpBadge.classList.add('xp-badge');
                xpBadge.textContent = player.level || 1;
                playerInfo.appendChild(avatar);
                playerInfo.appendChild(username);
                playerInfo.appendChild(xpBadge);

                 const flair = document.createElement('span');
                 flair.classList.add('player-flair');
                 flair.style.fontSize = '0.8em';
                 flair.style.marginLeft = '0.25rem';
                 if (player.hotStreak >= 5) flair.textContent = '🔥';
                 else if (player.isVIP) flair.textContent = '👑';
                 else flair.textContent = '👍';
                 playerInfo.appendChild(flair);


                seatElement.appendChild(playerInfo);

                 // Display total bet for the player (Roulette specific)
                 const totalBetDisplay = document.createElement('div');
                 totalBetDisplay.classList.add('player-total-bet');
                 totalBetDisplay.textContent = `Bet: ${(player.totalBet || 0).toFixed(2)} SOL`; // Assuming totalBet property
                 totalBetDisplay.style.fontSize = '0.8em';
                 totalBetDisplay.style.marginTop = '0.25rem';
                 seatElement.appendChild(totalBetDisplay);


                // Action Buttons (Spin - only for the player who can spin, or server triggered)
                // In Roulette, the spin is usually server triggered or by one designated player.
                // We'll hide these action buttons for now and use the main Spin button.
                const actionButtons = document.createElement('div');
                actionButtons.classList.add('action-buttons', 'hidden'); // Hide action buttons
                seatElement.appendChild(actionButtons);

                // Turn Timer Bar (for betting phase)
                const timerBar = document.createElement('div');
                timerBar.classList.add('turn-timer-bar');
                 // Show timer only during betting phase
                 if (!gameState.bettingPhaseTimer) { // Assuming timer is active during betting phase
                     timerBar.classList.add('hidden');
                 } else {
                     timerBar.classList.remove('hidden');
                 }

                const timerFill = document.createElement('div');
                timerFill.classList.add('turn-timer-fill');
                 // Timer fill width will be controlled by startBettingPhaseTimer function
                timerBar.appendChild(timerFill);
                seatElement.appendChild(timerBar);

                // Hot Streak Bar (Visible only for the user's seat)
                if (player.id === gameState.walletAddress) {
                    const hotStreakBar = document.createElement('div');
                    hotStreakBar.classList.add('hot-streak-bar');
                    hotStreakBar.id = 'user-hot-streak-bar'; // Assign an ID for easy access
                     if (!(player.hotStreak > 0)) { // Use class 'hidden'
                         hotStreakBar.classList.add('hidden');
                     } else {
                         hotStreakBar.classList.remove('hidden');
                     }

                    const hotStreakFill = document.createElement('div');
                    hotStreakFill.classList.add('hot-streak-fill');
                    hotStreakBar.appendChild(hotStreakFill);
                    seatElement.appendChild(hotStreakBar);
                }

                 // Add Streak Emoji Placeholder
                 const streakEmoji = document.createElement('span');
                 streakEmoji.classList.add('streak-emoji', 'hidden'); // Hidden by default
                 streakEmoji.style.fontSize = '1.5rem'; // Use rem
                 streakEmoji.style.marginLeft = '0.5rem'; // Use rem
                 streakEmoji.textContent = '🔥'; // Default streak emoji
                 seatElement.appendChild(streakEmoji);


                dom.playerSeats.appendChild(seatElement);
            });

             // Add empty seats if less than 5 players (optional for Roulette)
             // For Roulette, showing empty seats might be less relevant than Blackjack.
             // We can skip this or show a simplified "Waiting for players" message.
             // Let's keep it for now for consistency, but simplify the content.
             for (let i = gameState.players.length; i < 5; i++) {
                 const emptySeat = document.createElement('div');
                 emptySeat.classList.add('player-seat');
                 emptySeat.style.backgroundColor = '#333'; // Slightly lighter for empty
                 emptySeat.style.border = '2px dashed #555';
                 emptySeat.innerHTML = `<div style="color: #777; font-size: 0.9em;">Empty Seat</div>`;
                 dom.playerSeats.appendChild(emptySeat);
             }
        }

        function startBettingPhaseTimer(duration) {
             // Find the timer bar element (maybe just one for the table, or on the user's seat)
             // Let's use a single timer bar for the betting phase, maybe in the dealer anchor area or near the grid.
             // For now, we'll update the timer bar on the user's seat if they are seated.
            const userSeatTimerFill = document.querySelector('.player-seat.is-user .turn-timer-fill');
            if (userSeatTimerFill) {
                userSeatTimerFill.parentElement.classList.remove('hidden'); // Show timer bar
                userSeatTimerFill.style.transition = 'none';
                userSeatTimerFill.style.width = '100%';
                userSeatTimerFill.offsetHeight;
                userSeatTimerFill.style.transition = `width ${duration}s linear`;
                userSeatTimerFill.style.width = '0%';

                 // Add timer urgency animation when 3 seconds remain (placeholder)
                 const timerElement = userSeatTimerFill.parentElement;
                 if (timerElement) {
                     setTimeout(() => {
                         timerElement.style.animation = 'none';
                         timerElement.offsetHeight;
                         timerElement.style.animation = 'flashWarning 1s infinite';
                     }, (duration - 3) * 1000);

                      setTimeout(() => {
                          timerElement.style.animation = 'none';
                      }, duration * 1000);
                 }
            }
             // Store the timer interval ID if needed for stopping
             // gameState.bettingPhaseTimer = setInterval(updateTimerDisplay, 1000); // Example interval
        }

        function stopBettingPhaseTimer() {
             // Clear the interval timer
             // clearInterval(gameState.bettingPhaseTimer);
             // gameState.bettingPhaseTimer = null;
             // Hide the timer bar
             const userSeatTimerBar = document.querySelector('.player-seat.is-user .turn-timer-bar');
             if (userSeatTimerBar) {
                 userSeatTimerBar.classList.add('hidden');
                 userSeatTimerBar.style.animation = 'none'; // Remove urgency animation
             }
        }

        function updateBettingPhaseTimer(remainingTime) {
             // Update the visual display of the timer bar based on remainingTime
             const userSeatTimerFill = document.querySelector('.player-seat.is-user .turn-timer-fill');
             if (userSeatTimerFill) {
                  const percentage = (remainingTime / gameState.bettingPhaseDuration) * 100;
                  userSeatTimerFill.style.width = `${percentage}%`;
                  // Optional: Update a text display of remaining time
             }
        }


        function updateHotStreakBar(streakCount) {
             const userHotStreakFill = document.getElementById('user-hot-streak-bar')?.querySelector('.hot-streak-fill');
             const userStreakEmoji = document.querySelector('.player-seat.is-user .streak-emoji');

             if (userHotStreakFill) {
                 const maxWidth = MAX_HOT_STREAK_DISPLAY; // Using constant
                 const widthPercentage = Math.min(streakCount / maxWidth * 100, 100);
                 userHotStreakFill.style.width = `${widthPercentage}%`;
                 if (streakCount > 0) {
                     userHotStreakFill.parentElement.classList.remove('hidden');
                     if (userStreakEmoji) userStreakEmoji.classList.remove('hidden');
                     if (streakCount >= 5) userStreakEmoji.textContent = '👑';
                     else if (streakCount >= 3) userStreakEmoji.textContent = '🔥';
                     else userStreakEmoji.textContent = '👍';
                 } else {
                     userHotStreakFill.parentElement.classList.add('hidden');
                     if (userStreakEmoji) userStreakEmoji.classList.add('hidden');
                 }
             }
        }

        function showNearMissPopup(message) {
            dom.nearMissPopup.textContent = message;
            dom.nearMissPopup.classList.add('show');
            setTimeout(() => {
                dom.nearMissPopup.classList.remove('show');
            }, 1500);
             triggerHaptic([100, 100, 100, 100]);
        }

        function showWinBanner(amount) {
            console.log(`Showing Win Banner for ${amount} SOL`);
            // Implement a temporary banner or badge animation here
        }

        // Update betting controls for Roulette (chip selection)
        function updateBettingControls() {
             // Update displayed chip value
            dom.currentBetDisplay.textContent = `Chip Value: ${gameState.currentChipValue.toFixed(2)} SOL`;

            if (gameState.isSeated) {
                dom.joinLeaveButton.textContent = 'Leave Table';
                dom.joinLeaveButton.classList.remove('join-button');
                dom.joinLeaveButton.classList.add('leave-button');
                // Enable/disable betting controls based on betting phase and spectator status
                 const canBet = gameState.bettingPhaseTimer !== null && !gameState.isSpectator; // Can bet if timer is active and not spectator
                 dom.chipSelectionButtons.forEach(button => button.disabled = !canBet);
                 dom.clearBetsButton.disabled = !canBet;
                 // Spin button visibility handled by specific functions (showSpinButton/hideSpinButton)

            } else {
                dom.joinLeaveButton.textContent = 'Join Table';
                dom.joinLeaveButton.classList.remove('leave-button');
                dom.joinLeaveButton.classList.add('join-button');
                 // Disable betting controls if not seated
                 dom.chipSelectionButtons.forEach(button => button.disabled = true);
                 dom.clearBetsButton.disabled = true;
                 hideSpinButton(); // Hide spin button if not seated
            }

            if (gameState.isSpectator) {
                dom.spectatorStatus.classList.remove('hidden');
            } else {
                dom.spectatorStatus.classList.add('hidden');
            }

             dom.chatInput.disabled = gameState.isSpectator;
             dom.sendChatButton.disabled = gameState.isSpectator;
             dom.chatInput.placeholder = gameState.isSpectator ? "Spectators cannot chat" : "Type message...";
        }

        function renderChatFeed() {
            dom.chatFeed.innerHTML = ''; // Clear current feed
            gameState.chatMessages.forEach(msg => {
                addChatMessageToFeed(msg);
            });
             updateChatContainerVisibility();
        }

        function addChatMessageToFeed(msg) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message');
            // Sanitize message content before displaying
            const sanitizedMessage = sanitizeInput(msg.message);
            messageElement.innerHTML = `<span class="chat-sender">[${msg.sender}]</span><span class="chat-badge">[${msg.badge}]</span> ${sanitizedMessage}`;
            dom.chatFeed.appendChild(messageElement);

             const maxChatMessages = MAX_CHAT_MESSAGES; // Using constant
             if (dom.chatFeed.children.length > maxChatMessages) {
                 dom.chatFeed.removeChild(dom.chatFeed.children[0]);
             }

            dom.chatFeed.scrollTop = dom.chatFeed.scrollHeight;

            messageElement.classList.add('flash');
            messageElement.addEventListener('animationend', () => {
                messageElement.classList.remove('flash');
            }, { once: true });
        }

        function updateChatContainerVisibility() {
             const isMobile = window.innerWidth <= 768;
             if (isMobile) {
                 if (gameState.chatVisible) {
                     dom.chatContainer.classList.add('active');
                     dom.chatContainer.classList.remove('hidden');
                 } else {
                     dom.chatContainer.classList.remove('active');
                     dom.chatContainer.classList.add('hidden');
                 }
                  dom.toggleChatButton.classList.remove('hidden');
             } else {
                 dom.chatContainer.classList.add('active');
                 dom.chatContainer.classList.remove('hidden');
                 dom.toggleChatButton.classList.add('hidden');
             }
        }

        function updateOtherHandsVisibility() {
             const isMobile = window.innerWidth <= 768;
             const otherPlayerSeats = document.querySelectorAll('.player-seat:not(.is-user)');

             if (!isMobile) {
                 // Always show other players on desktop
                 otherPlayerSeats.forEach(seat => {
                      seat.classList.remove('hidden'); // Ensure seat is not hidden
                 });
                 dom.toggleOtherHandsButton.classList.add('hidden');
                 return;
             }

             // Mobile logic
             dom.toggleOtherHandsButton.classList.remove('hidden'); // Show button on mobile

             otherPlayerSeats.forEach(seat => {
                 if (gameState.otherHandsVisible) {
                      seat.classList.remove('hidden'); // Show seat
                 } else {
                      seat.classList.add('hidden'); // Hide seat
                 }
             });
        }

        function showSpinButton() {
             dom.spinButton.classList.remove('hidden');
             dom.spinButton.classList.add('pulse-button');
        }

        function hideSpinButton() {
             dom.spinButton.classList.add('hidden');
             dom.spinButton.classList.remove('pulse-button');
        }

        function enableBetting() {
             dom.bettingGridContainer.querySelectorAll('.grid-cell').forEach(cell => {
                 cell.style.pointerEvents = 'auto'; // Enable clicks
                 cell.style.opacity = 1;
             });
             dom.chipSelectionButtons.forEach(button => button.disabled = false);
             dom.clearBetsButton.disabled = false;
             // Optional: Add visual feedback for betting phase
             dom.bettingGridContainer.style.boxShadow = '0 0 1rem rgba(16, 185, 129, 0.5)'; // Green glow
        }

        function disableBetting() {
             dom.bettingGridContainer.querySelectorAll('.grid-cell').forEach(cell => {
                 cell.style.pointerEvents = 'none'; // Disable clicks
                 cell.style.opacity = 0.8; // Dim cells
             });
             dom.chipSelectionButtons.forEach(button => button.disabled = true);
             dom.clearBetsButton.disabled = true;
             // Optional: Remove visual feedback
             dom.bettingGridContainer.style.boxShadow = 'inset 0 0 2rem rgba(0, 0, 0, 0.5)'; // Revert shadow
        }


        // --- Event Handlers ---

        function setupEventListeners() {
            dom.connectWalletButton.addEventListener('click', connectWallet);
            dom.disconnectWalletButton.addEventListener('click', disconnectWallet);

            // Chip selection button listeners
            dom.chipSelectionButtons.forEach(button => {
                 button.addEventListener('click', (event) => {
                     const value = event.target.dataset.chipValue;
                     if (value === 'MAX') {
                          // Placeholder: Implement MAX chip value logic
                          gameState.currentChipValue = gameState.walletBalance; // Example: MAX is wallet balance
                     } else {
                          gameState.currentChipValue = parseFloat(value);
                     }
                     // Update display and highlight active chip button (optional)
                     dom.currentBetDisplay.textContent = `Chip Value: ${gameState.currentChipValue.toFixed(2)} SOL`;
                     playSound(dom.buttonClickSound);
                     triggerHaptic([50]);
                 });
            });

            // Clear Bets button listener
            dom.clearBetsButton.addEventListener('click', () => {
                 gameState.currentBets = {}; // Clear local bets
                 renderPlacedChips(); // Remove chips from grid
                 // Placeholder: Send clear bets message to server
                 sendMessage({ type: 'clearBets' });
                 playSound(dom.buttonClickSound);
                 triggerHaptic([50]);
            });


            dom.joinLeaveButton.addEventListener('click', () => {
                if (gameState.isSeated) {
                    sendMessage({ type: 'leaveTable' });
                } else {
                    // In Roulette, joining might not require an initial bet,
                    // betting happens during the betting phase.
                    sendMessage({ type: 'joinRoulette' }); // Changed message type
                }
                 playSound(dom.buttonClickSound);
                 triggerHaptic([50]);
            });

            dom.sendChatButton.addEventListener('click', sendChatMessage);
            dom.chatInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    sendChatMessage();
                }
            });

             const menuIcon = document.querySelector('.menu-icon');
             menuIcon.addEventListener('click', () => {
                 const dropdown = dom.settingsDropdown;
                 dropdown.classList.toggle('hidden');
                  playSound(dom.buttonClickSound);
             });

             document.addEventListener('click', (event) => {
                 if (!menuIcon.contains(event.target) && !dom.settingsDropdown.contains(event.target)) {
                     dom.settingsDropdown.classList.add('hidden');
                 }
             });

             dom.toggleChatButton.addEventListener('click', () => {
                 gameState.chatVisible = !gameState.chatVisible;
                 updateChatContainerVisibility();
                  playSound(dom.buttonClickSound);
             });

             // Toggle Other Players button
             dom.toggleOtherHandsButton.addEventListener('click', () => {
                 gameState.otherHandsVisible = !gameState.otherHandsVisible;
                 updateOtherHandsVisibility();
                  playSound(dom.buttonClickSound);
             });

             // Spin Button
             dom.spinButton.addEventListener('click', () => {
                 // Placeholder: Send spin request to server
                 sendMessage({ type: 'requestSpin' }); // Server will validate and trigger spin
                 hideSpinButton(); // Hide button immediately
                 playSound(dom.buttonClickSound);
                 triggerHaptic([50]);
             });

             dom.referFriendsButton.addEventListener('click', shareReferral);

             dom.freeModeToggle.addEventListener('click', () => {
                 gameState.isFreeMode = !gameState.isFreeMode;
                 updateFreeModeToggleText();
                 console.log(`Free Mode: ${gameState.isFreeMode}`);
                 playSound(dom.buttonClickSound);
             });

             // Game Tab Buttons (within Settings/Lounge)
             dom.settingsDropdown.querySelectorAll('.game-tab-button').forEach(button => {
                 button.addEventListener('click', (event) => {
                     const game = event.target.dataset.game;
                     console.log(`Switched to game tab: ${game}`);
                     // Placeholder: Navigate or load content for the selected game
                     // This would likely involve changing the entire game view
                      showInfoMessage(`Switched to ${game.charAt(0).toUpperCase() + game.slice(1)} (Placeholder)`);
                      dom.settingsDropdown.classList.add('hidden'); // Hide dropdown
                      playSound(dom.buttonClickSound);
                 });
             });

             // Profile Tab Button
             dom.profileTabButton.addEventListener('click', () => {
                 showProfileLoungeSection('profile');
                 playSound(dom.buttonClickSound);
             });

             // Close Profile/Lounge Section
             dom.profileLoungeClose.addEventListener('click', () => {
                 dom.profileLoungeSection.classList.add('hidden');
                 playSound(dom.buttonClickSound);
             });
        }

        function sendChatMessage() {
            const message = dom.chatInput.value.trim();
            if (message && !gameState.isSpectator) {
                // Sanitize outgoing message
                const sanitizedMessage = sanitizeInput(message);
                const sender = gameState.walletAddress ? `${gameState.walletAddress.slice(0, 4)}...` : 'Anon';
                const badge = gameState.userLevel;
                sendMessage({ type: 'chat_message', message: sanitizedMessage, sender: sender, badge: badge });
                dom.chatInput.value = '';
            }
        }

        function updateFreeModeToggleText() {
             dom.freeModeToggle.textContent = gameState.isFreeMode ? '✅ Free Mode' : '🔁 SOL Mode';
        }

        // Unified function to show Profile or Lounge section
        function showProfileLoungeSection(section) {
             dom.profileLoungeSection.classList.remove('hidden');
             // Hide all lounge content initially
             dom.profileContent.classList.add('hidden');
             dom.loungeContent.classList.add('hidden');

             if (section === 'profile') {
                 dom.profileContent.classList.remove('hidden');
                 updateProfileDisplay();
             } else if (section === 'lounge') {
                 dom.loungeContent.classList.remove('hidden');
                 loadLoungeContent('roulette'); // Load default lounge content for Roulette
             }
        }

        function updateProfileDisplay() {
             dom.profileAvatar.textContent = gameState.players.find(p => p.id === gameState.walletAddress)?.avatar || '😊';
             dom.profileLevel.textContent = gameState.userLevel;
             const xpProgress = gameState.userXP % XP_PER_LEVEL; // Using constant
             dom.profileXpBarFill.style.width = `${xpProgress}%`;
             dom.profileXP.textContent = `${xpProgress}/${XP_PER_LEVEL}`; // Using constant
             // Placeholder: Fetch and display other profile data (Win %, Wager, Streak, Badges)
             dom.profileWinRate.textContent = '--'; // Needs real data
             dom.profileHighestWager.textContent = '--'; // Needs real data
             dom.longestStreak.textContent = '--'; // Needs real data
             dom.profileFavoriteGame.textContent = 'Roulette'; // Example
             dom.profileBadges.innerHTML = '<li>Coming Soon</li>'; // Example badges
        }

        function loadLoungeContent(game) {
             console.log(`Loading lounge content for: ${game}`);
             dom.loungeLeaderboards.innerHTML = `Live Leaderboard for ${game}...`; // Updated text
             dom.loungeChat.innerHTML = `Lounge chat for ${game}...`; // Updated text
             // Placeholder: Fetch and display leaderboards and chat for the selected game
        }


        // --- Sound and Haptics ---
        function playSound(audioElement) {
             if (audioElement) {
                 audioElement.currentTime = 0; // Rewind to start
                 audioElement.play().catch(error => console.error("Error playing sound:", error));
             }
        }

         function playBackgroundSound() {
             if (dom.backgroundLoopSound && !gameState.backgroundSoundPlaying) {
                 dom.backgroundLoopSound.volume = 0.05; // Lower volume for subtle ambient loop
                 dom.backgroundLoopSound.play().then(() => {
                     gameState.backgroundSoundPlaying = true;
                 }).catch(error => console.error("Error playing background sound:", error));
             }
         }


        function triggerHaptic(pattern) {
            if ('vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        }


        // --- Animation Placeholders ---

        function triggerConfetti() {
            console.log("Triggering confetti!");
            const confettiCount = window.innerWidth < 768 ? 50 : 100; // Adjust count for mobile
            const colors = ['#10b981', '#ec4899', '#a78bfa', '#facc15']; // Green, Pink, Purple, Yellow
            const particles = [];

            for (let i = 0; i < confettiCount; i++) {
                particles.push({
                    x: Math.random() * dom.confettiCanvas.width,
                    y: dom.confettiCanvas.height, // Start from bottom
                    radius: Math.random() * 5 + 2,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speedX: Math.random() * 10 - 5, // Random horizontal speed
                    speedY: Math.random() * -15 - 5, // Upward speed
                    gravity: 0.5,
                    dampening: 0.9, // Reduce speed over time
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 20 - 10,
                     shape: 'circle', // or 'star', 'chip', 'dollar'
                });
            }

            function updateConfetti() {
                dom.confettiCtx.clearRect(0, 0, dom.confettiCanvas.width, dom.confettiCtx.canvas.height);

                particles.forEach(p => {
                    p.speedY += p.gravity;
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.speedX *= p.dampening;
                    p.speedY *= p.dampening;
                    p.rotation += p.rotationSpeed;

                    dom.confettiCtx.save();
                    dom.confettiCtx.translate(p.x, p.y);
                    dom.confettiCtx.rotate(p.rotation * Math.PI / 180);
                    dom.confettiCtx.fillStyle = p.color;
                    dom.confettiCtx.fillRect(-p.radius / 2, -p.radius / 2, p.radius, p.radius);

                    dom.confettiCtx.restore();
                });

                // Filter out particles that are off-screen
                const remainingParticles = particles.filter(p => p.y < dom.confettiCanvas.height && p.x > 0 && p.x < dom.confettiCanvas.width);
                particles.length = 0; // Clear the original array
                particles.push(...remainingParticles); // Add remaining particles back


                if (particles.length > 0) {
                    requestAnimationFrame(updateConfetti);
                }
            }

            updateConfetti();
        }

        function triggerCoinShower() {
            console.log("Triggering coin shower!");
            const coinCount = window.innerWidth < 768 ? 30 : 50; // Adjust count for mobile
            const coins = [];

            for (let i = 0; i < coinCount; i++) {
                const coin = document.createElement('div');
                coin.classList.add('coin');
                coin.style.left = `${Math.random() * 100}vw`;
                coin.style.setProperty('--end-x', `${(Math.random() - 0.5) * 200}px`);
                 coin.style.setProperty('--end-rotate', `${Math.random() * 720 - 360}deg`);

                document.body.appendChild(coin);
                coins.push(coin);

                coin.addEventListener('animationend', () => {
                    coin.remove();
                }, { once: true });
            }
            playSound(dom.coinDropSound);
        }

        function triggerFloatingWinEmojis() {
             console.log("Triggering floating win emojis!");
             const emojiCount = window.innerWidth < 768 ? 10 : 20;
             const emojis = ['🎉', '💰', '💸', '✨', '👑', '🎰', '🤑', '💎', '🎴'];
             const container = dom.floatingEmojiContainer;

             for (let i = 0; i < emojiCount; i++) {
                 const emoji = document.createElement('span');
                 emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                 emoji.classList.add('floating-emoji');
                 emoji.style.position = 'absolute'; // Ensure absolute positioning
                 emoji.style.left = `${50 + (Math.random() - 0.5) * 20}vw`;
                 emoji.style.bottom = `${Math.random() * 10}vh`;
                 emoji.style.fontSize = `${Math.random() * 1 + 1}rem`;
                 emoji.style.opacity = Math.random() * 0.5 + 0.5;
                 emoji.style.animation = 'float-up 2s ease-out forwards'; // Apply float-up animation


                 container.appendChild(emoji);

                 emoji.addEventListener('animationend', () => {
                     emoji.remove();
                 }, { once: true });
             }
        }

         function triggerMaxBetAnimation() {
             console.log("Triggering MAX Bet animation!");
             const maxBetButton = document.querySelector('.chip-selection-buttons button[data-chip-value="MAX"]'); // Changed selector
             if (maxBetButton) {
                 maxBetButton.style.animation = 'none';
                 maxBetButton.offsetHeight;
                 maxBetButton.style.animation = 'shake 0.3s ease-in-out';
             }
         }

         function startBackgroundParticlesAnimation() {
             console.log("Starting background particles animation...");
             const canvas = dom.backgroundParticlesCanvas;
             const ctx = dom.backgroundParticlesCtx;
             const particles = [];
             const particleCount = navigator.hardwareConcurrency ? Math.min(50, navigator.hardwareConcurrency * 5) : 50;


             for (let i = 0; i < particleCount; i++) {
                 particles.push({
                     x: Math.random() * canvas.width,
                     y: Math.random() * canvas.height,
                     size: Math.random() * 5 + 2,
                     color: Math.random() > 0.5 ? '#ffd700' : '#a78bfa', // Gold or Purple
                     speedY: Math.random() * 1 + 0.5, // Float downwards
                     speedX: (Math.random() - 0.5) * 0.5, // Drift horizontally
                     opacity: Math.random() * 0.5 + 0.2, // Semi-transparent
                 });
             }

             function drawParticles() {
                 ctx.clearRect(0, 0, canvas.width, canvas.height);

                 particles.forEach(p => {
                     p.y += p.speedY;
                     p.x += p.speedX;

                     if (p.y > canvas.height) {
                         p.y = -p.size;
                         p.x = Math.random() * canvas.width;
                     }

                     ctx.fillStyle = p.color;
                     ctx.globalAlpha = p.opacity;
                     ctx.beginPath();
                     ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                     ctx.fill();
                 });

                 requestAnimationFrame(drawParticles);
             }

             drawParticles();
         }


        // --- Additional Engagement Features ---

        function checkForDailyReward() {
             const lastLogin = localStorage.getItem('lastLogin');
             const today = new Date().toDateString();

             if (lastLogin !== today) {
                 let streak = parseInt(localStorage.getItem('loginStreak') || '0') + 1;
                 localStorage.setItem('lastLogin', today);
                 localStorage.setItem('loginStreak', streak);

                 if (streak >= 5) {
                     // Award daily reward (e.g., 0.01 SOL)
                     const rewardAmount = 0.01; // Define reward amount
                     gameState.walletBalance += rewardAmount; // Simulate adding balance
                     localStorage.setItem('walletBalance', gameState.walletBalance); // Persist balance (simple)
                     dom.walletBalance.textContent = `${gameState.walletBalance.toFixed(2)} SOL`;
                     showInfoMessage(`Daily Reward: ${rewardAmount.toFixed(2)} SOL Free Bet!`); // Use a better message display
                     localStorage.setItem('loginStreak', '0'); // Reset streak after reward
                 } else {
                      showInfoMessage(`Login Streak: ${streak} days. Keep it up for a reward!`); // Inform about streak
                 }
             } else {
                 // Already logged in today, maybe show streak status?
                 const streak = localStorage.getItem('loginStreak') || '0';
                 console.log(`Login Streak: ${streak} days`);
             }
        }

        function shareReferral() {
             const referralLink = "YOUR_REFERRAL_LINK_HERE"; // TODO: Replace with your actual referral link
             const text = `Join DegenRoulette & get a bonus! Play roulette on Solana. ${referralLink} 🚀`; // Changed text

             if (navigator.share) {
                 navigator.share({
                     title: 'DegenRoulette Referral', // Changed title
                     text: text,
                     url: referralLink,
                 }).catch(error => console.error('Error sharing:', error));
             } else {
                 window.open(`https://x.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
             }
             playSound(dom.buttonClickSound);
             triggerFloatingReferralReward();
        }

        function triggerFloatingReferralReward() {
             console.log("Triggering floating referral reward animation!");
             const rewardElement = document.createElement('span');
             rewardElement.textContent = "+0.05 SOL";
             rewardElement.style.position = 'absolute';
             rewardElement.style.bottom = '5rem';
             rewardElement.style.left = '50%';
             rewardElement.style.transform = 'translateX(-50%)';
             rewardElement.style.color = '#10b981';
             rewardElement.style.fontSize = '1.5rem';
             rewardElement.style.fontWeight = 'bold';
             rewardElement.style.zIndex = 100;
             rewardElement.style.animation = 'float-up 1.5s ease-out forwards';
             dom.bottomBar.appendChild(rewardElement);

             rewardElement.addEventListener('animationend', () => {
                 rewardElement.remove();
             }, { once: true });
        }


        function showMysteryEvent(eventData) {
             console.log("Mystery Event Triggered:", eventData);
             if (eventData.type === 'bonus_round') {
                 dom.hotTableBanner.textContent = `Bonus Round Active! ${eventData.message || 'Double Payouts!'}`;
                 dom.hotTableBanner.classList.remove('hidden');
                 setTimeout(() => {
                     dom.hotTableBanner.classList.add('hidden');
                 }, eventData.duration || 5000);
             }
        }

        function triggerConfettiOnJoin() {
             console.log("Triggering confetti on join!");
             triggerConfetti();
        }

        // Placeholder for Auto-Play Timer/Spinner (Less relevant for Roulette)
        function startAutoPlayTimer() {
             console.log("Starting auto-play timer...");
        }

        // Placeholder for a generic info/message display (replace alerts)
        function showInfoMessage(message) {
            console.log("Info:", message);
            // Implement a temporary message display in the UI (e.g., a small banner or toast)
            alert(message); // Still using alert for now, replace this.
        }


        // --- Simulation for Testing (Roulette Specific) ---
        function simulateInitialGameStateRoulette() {
             // Simulate a few players and their bets
             gameState.players = [
                 { id: 'user123', name: 'You', level: 5, avatar: '😎', bets: { 'number_7': 0.5, 'red': 0.2 }, totalBet: 0.7, hotStreak: 3, isVIP: true },
                 { id: 'player456', name: 'CryptoKing', level: 10, avatar: '👑', bets: { '1st12': 1, 'number_0': 0.1 }, totalBet: 1.1, hotStreak: 0, isVIP: false },
                 { id: 'player789', name: 'SolanaSpin', level: 2, avatar: '🦄', bets: { 'odd': 0.3 }, totalBet: 0.3, hotStreak: 0, isVIP: false },
             ];
             // Set user's bets in gameState.currentBets
             const currentUser = gameState.players.find(p => p.id === 'user123');
             if (currentUser) {
                 gameState.currentBets = currentUser.bets;
                 gameState.walletAddress = currentUser.id; // Simulate connected wallet
                 handleWalletConnected({ toBase58: () => currentUser.id }); // Simulate wallet connection UI update
             }

             // Simulate a recent play result
             gameState.recentPlays = [
                 { winningNumber: 17, payout: 1.5 },
                 { winningNumber: 0, payout: 0 },
                 { winningNumber: 24, payout: 0.5 },
             ];

             // Simulate betting phase start
             // Clear previous timer if it exists
             if (gameState.bettingPhaseTimer) {
                 clearTimeout(gameState.bettingPhaseTimer);
             }
             gameState.bettingPhaseTimer = setTimeout(() => {
                 console.log("Simulated betting phase end");
                 // In a real app, server sends 'betting_phase_end'
                 disableBetting();
                 stopBettingPhaseTimer();
                 showSpinButton();
             }, gameState.bettingPhaseDuration * 1000); // Timer for simulation
             enableBetting(); // Enable betting at simulation start
             startBettingPhaseTimer(gameState.bettingPhaseDuration);

             // Update UI based on simulated state
             updateUI();
             // Simulate initial leaderboard data
             updateLeaderboard([
                 { player: 'CryptoKing', totalWon: 150 },
                 { player: 'You', totalWon: 80 },
                 { player: 'WhaleBets', totalWon: 50 },
             ]);
        }

         // Placeholder for Loss Aversion Message
         function showLossAversionMessage() {
             console.log("Showing loss aversion message...");
             // Implement a temporary message display (e.g., "Better luck next time!", "Try betting on Red!")
             // Similar to near miss popup but with different text/styling
         }


    </script>
</body>
</html>
