<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<title>SolRoulette LIVE - Spin to Win</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;display=swap" rel="stylesheet"/>
<style>
        /* Reset and Base Styles */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
            background: linear-gradient(180deg, #0A0A0A, #1A1A1A);
            color: #FFFFFF;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            position: relative; /* Needed for absolute positioning of overlays */
        }
        :root {
            --primary: #9945FF; /* Purple branding */
            --danger: #FF375F; /* Red for losses */
            --success: #14F195; /* Green for wins */
            --accent: #FFD700; /* Gold for highlights */
            --secondary: #1A1A1A; /* Dark panels */
            --text: #FFFFFF;
            --background-gradient: linear-gradient(180deg, #0A0A0A, #1A1A1A);
            --panel-background: rgba(26, 26, 26, 0.8); /* Semi-transparent dark */
            --panel-border-radius: 12px;
            --button-border-radius: 8px;
            --input-border-radius: 8px;
        }
        .container {
            max-width: 100%;
            height: 100%;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1; /* Ensure content is above background effects */
        }

        /* Background Effects */
        .background-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(153, 69, 255, 0.1) 0%, rgba(10, 10, 10, 0) 50%);
            pointer-events: none;
            z-index: 0;
            overflow: hidden; /* Hide particles outside */
        }

        /* Particle FX */
        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: var(--accent);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 5s infinite ease-out;
            opacity: 0;
        }

        @keyframes particle-float {
            0% { transform: translateY(0) translateX(0) scale(1); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-200px) translateX(50px) scale(0.5); opacity: 0; }
        }

         .background-overlay.intensify-particles .particle {
             animation-duration: 3s; /* Faster float */
             animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Different easing */
             opacity: 1; /* Always visible during intensification */
         }


        /* Money Rain Effect */
        .money-rain {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: var(--success);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%); /* Simple triangle coin */
            pointer-events: none;
            animation: money-fall 2s ease-in forwards;
            opacity: 0;
        }

        @keyframes money-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Strobe Effect during spin */
        .strobe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1); /* Subtle white overlay */
            pointer-events: none;
            z-index: 0;
            opacity: 0;
        }

        .strobe-overlay.active {
            animation: strobe 0.2s infinite alternate;
        }

        @keyframes strobe {
            0% { opacity: 0; }
            100% { opacity: 0.1; }
        }


        /* Animations */
        @keyframes pulse-glow {
            0% { filter: drop-shadow(0 0 4px var(--primary)); }
            100% { filter: drop-shadow(0 0 16px var(--primary)); }
        }
         @keyframes pulse-glow-red {
            0% { filter: drop-shadow(0 0 4px var(--danger)); }
            100% { filter: drop-shadow(0 0 16px var(--danger)); }
         }
        @keyframes enter {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-60px); opacity: 0; }
        }
        /* Spin animation will be controlled by JS for precise landing */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            }
        @keyframes vibrate {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
            }
         @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
         @keyframes timer-pulse-fast {
             0% { transform: translateX(-50%) scale(1); }
             50% { transform: translateX(-50%) scale(1.1); }
             100% { transform: translateX(-50%) scale(1); }
         }
         @keyframes pointer-pulse {
             0% { filter: drop-shadow(0 0 4px var(--accent)); }
             50% { filter: drop-shadow(0 0 20px var(--accent)); }
             100% { filter: drop-shadow(0 0 4px var(--accent)); }
         }
         @keyframes subtle-vibrate {
             0%, 100% { transform: translateX(0); }
             25% { transform: translateX(-1px); }
             75% { transform: translateX(1px); }
         }
         /* Glow effect for onboarding tooltip target */
         @keyframes onboarding-glow {
             0% { box-shadow: 0 0 5px var(--accent); }
             50% { box-shadow: 0 0 20px var(--accent), 0 0 30px var(--accent); }
             100% { box-shadow: 0 0 5px var(--accent); }
         }
         /* Wheel Pulse during countdown */
         @keyframes wheel-pulse-glow {
             0% { box-shadow: 0 0 64px rgba(153, 69, 255, 0.3), 0 0 32px rgba(255, 215, 0, 0.3); }
             50% { box-shadow: 0 0 80px rgba(153, 69, 255, 0.5), 0 0 40px rgba(255, 215, 0, 0.5); }
             100% { box-shadow: 0 0 64px rgba(153, 69, 255, 0.3), 0 0 32px rgba(255, 215, 0, 0.3); }
         }


        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--panel-background);
            border-radius: var(--panel-border-radius);
            margin: 10px;
            width: calc(100% - 20px); /* Adjust for margin */
            max-width: 800px; /* Limit header width on larger screens */
            backdrop-filter: blur(6px);
            z-index: 10;
            /* Added gap for spacing between header elements */
            gap: 10px;
        }
         .site-title {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary);
            text-shadow: 0 0 8px rgba(153, 69, 255, 0.5);
            /* Prevent shrinking */
            flex-shrink: 0;
        }
        .players-online, .user-profile {
            background: rgba(26, 26, 26, 0.5); /* More transparent */
            padding: 8px 12px;
            border-radius: var(--button-border-radius);
            font-size: 0.9em;
             /* Added gap for spacing inside these elements */
            gap: 8px;
             /* Allow shrinking */
            flex-shrink: 1;
             min-width: 0; /* Allow flex items to shrink below content size */
        }
        .user-profile {
            display: flex;
            align-items: center;
            cursor: pointer; /* Indicate clickable */
             transition: transform 0.2s;
             /* Added gap for spacing inside user profile */
             gap: 8px;
             /* Added flex-wrap for smaller screens */
             flex-wrap: wrap;
        }
        .user-profile:hover {
             transform: translateY(-2px);
        }
        .avatar {
            width: 28px; /* Slightly larger */
            height: 28px;
            border-radius: 50%;
            background: var(--accent);
            display: grid;
            place-items: center;
            font-size: 0.9em;
            border: 2px solid var(--text);
             flex-shrink: 0; /* Prevent shrinking */
        }
         .user-info {
             display: flex;
             flex-direction: column;
             min-width: 0; /* Allow text to wrap */
         }
        .xp-bar {
            width: 70px; /* Slightly wider */
            height: 8px; /* Taller */
            background: #333;
            border-radius: 4px; /* More rounded */
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
             flex-shrink: 0; /* Prevent shrinking */
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #7A37CC); /* Gradient fill */
            transition: width 0.3s ease-in-out;
        }
         .sol-balance-display {
             font-weight: bold;
             /* Added gap for icon spacing */
             display: flex;
             align-items: center;
             gap: 4px;
             flex-shrink: 0; /* Prevent shrinking */
         }
         .fake-winnings-display {
              font-size: 0.8em;
              color: #aaa;
              margin-left: 10px;
              flex-shrink: 0; /* Prevent shrinking */
         }
         /* Verified Badge */
         .verified-badge {
             display: none; /* Hidden by default */
             color: var(--success);
             margin-left: 5px;
         }


         /* Demo Mode Banner */
         .guest-banner {
             position: absolute; /* Changed to absolute for better control */
             top: 60px; /* Position below header */
             left: 50%;
             transform: translateX(-50%);
             background: var(--primary);
             color: var(--text);
             padding: 5px 10px;
             border-radius: var(--button-border-radius);
             font-size: 0.8em; /* Slightly smaller font */
             font-weight: bold;
             z-index: 15; /* Above most elements */
             box-shadow: 0 2px 5px rgba(0,0,0,0.3);
             white-space: nowrap; /* Prevent wrapping */
         }


        /* Global Timer */
        .global-timer {
            position: absolute !important;
            top: 135px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            font-size: 0.8em !important;
            padding: 4px 8px !important;
            white-space: nowrap !important;
            max-width: 180px;
            z-index: 25;
            text-align: center !important;
        }
         .global-timer.urgent {
             background: linear-gradient(45deg, var(--danger), #FF6B8A); /* Red gradient */
             animation: timer-pulse-fast 0.5s ease-in-out infinite alternate; /* Faster pulse */
         }

         /* Pre-Spin CTA */
         .pre-spin-cta {
             position: absolute !important;
             top: 160px !important;
             left: 50% !important;
             transform: translateX(-50%) !important;
             font-size: 0.8em !important;
             padding: 4px 8px !important;
             white-space: nowrap !important;
             max-width: 180px;
             z-index: 25;
             text-align: center !important;
         }


        /* Roulette Wheel */
        .wheel-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 40px auto 20px auto; /* More space */
            perspective: 1000px;
            animation: enter 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 5; /* Below timer, above background */
             margin-top: 10px !important;
        }
         #rouletteCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 12px solid #222; /* Thicker border */
            box-shadow: 0 0 64px rgba(153, 69, 255, 0.3), 0 0 32px rgba(255, 215, 0, 0.3); /* Multiple shadows */
            /* No conic gradient here, drawn on canvas */
            /* Metallic texture overlay handled by canvas drawing or filter */
             transition: box-shadow 0.3s ease-in-out; /* Smooth transition for glow */
         }
         #rouletteCanvas.countdown-glow {
             animation: wheel-pulse-glow 1s infinite alternate;
         }


        .pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 40px;
            clip-path: polygon(50% 100%, 0% 0%, 100% 0%);
            background: var(--accent);
            filter: drop-shadow(0 0 12px var(--accent));
            z-index: 2;
        }
        .pointer.vibrate {
            animation: vibrate 0.2s infinite;
        }
        .wheel-container.bounce {
            animation: bounce 0.3s;
        }
         .pointer.pulse {
             animation: pointer-pulse 1s infinite alternate;
         }

         /* Recent Spins Display */
         .recent-spins {
             position: absolute;
             bottom: 10px;
             left: 50%;
             transform: translateX(-50%);
             background: var(--panel-background);
             padding: 8px 12px;
             border-radius: var(--button-border-radius);
             font-size: 0.8em;
             z-index: 10;
             box-shadow: 0 2px 10px rgba(0,0,0,0.3);
             display: flex;
             gap: 5px;
             align-items: center;
             /* Allow wrapping on small screens */
             flex-wrap: wrap;
             justify-content: center;
         }
         .recent-spins .label {
             font-weight: bold;
             color: var(--accent);
             flex-shrink: 0; /* Prevent shrinking */
         }
         .recent-spins .outcome {
             padding: 3px 6px;
             border-radius: 4px;
             font-weight: bold;
             /* Animation for slide-in */
             animation: slideInFromRight 0.3s ease-out;
             flex-shrink: 0; /* Prevent shrinking */
         }
         .recent-spins .outcome.win { background-color: var(--success); color: #000; }
         .recent-spins .outcome.lose { background-color: var(--danger); color: #fff; }
         .recent-spins .outcome.primary { background-color: var(--primary); color: #fff; }
         .recent-spins .outcome.accent { background-color: var(--accent); color: #000; }


         @keyframes slideInFromRight {
             0% { transform: translateX(10px); opacity: 0; }
             100% { transform: translateX(0); opacity: 1; }
         }

        /* Chat System Fixes - REMOVED SEPARATE CHAT BUBBLE/CONTAINER */


        /* Unified Live Panel (Bets + Chat) */
        .live-panel-container {
            position: fixed; /* Changed to fixed for mobile drawer */
            top: 0; /* Position from top */
            right: 0; /* Position from right */
            width: 300px; /* Fixed width */
            height: 100%; /* Full height */
            z-index: 1000; /* High z-index */
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            /* Initial state (closed) - slide out from right */
            transform: translateX(100%);
        }

        .live-panel-container.active {
            /* Active state (open) */
            transform: translateX(0);
        }
         /* Removed .live-panel-container.closed as active/non-active handles state */


        .live-panel-toggle-btn {
            position: fixed; /* Changed to fixed */
            top: 120px; /* Position mid-right */
            right: 10px; /* Position from right edge */
            width: 44px; /* Increased touch target size */
            height: 44px; /* Increased touch target size */
            background: var(--panel-background);
            color: var(--accent);
            border: none;
            border-radius: 8px 0 0 8px; /* Rounded left side */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001; /* Above the panel */
            box-shadow: -2px 0 5px rgba(0,0,0,0.3); /* Shadow on the left */
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth transition */
        }
         /* Position toggle button when panel is open */
         .live-panel-container.active + .live-panel-toggle-btn {
             transform: translateX(-300px); /* Move button with the panel */
         }


         .live-panel-toggle-btn .unread-dot {
             position: absolute;
             top: 5px;
             right: 5px;
             width: 8px;
             height: 8px;
             background-color: var(--danger); /* Red dot */
             border-radius: 50%;
             display: none; /* Hidden by default */
         }


        /* Bet Controls */
        .bet-controls {
            /* position: absolute; */ /* Removed absolute positioning */
            background: var(--panel-background);
            padding: 15px;
            border-radius: var(--panel-border-radius);
            margin: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Increased gap */
            width: calc(100% - 20px);
            max-width: 600px;
            backdrop-filter: blur(6px);
            z-index: 10;
             position: relative; /* Needed for onboarding tooltip */
             /* Added margin-top for desktop layout */
             margin-top: 20px;
        }
         .bet-label {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--accent);
         }
        .multiplier-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); /* Responsive grid */
            gap: 8px;
             /* Onboarding glow */
             transition: box-shadow 0.3s ease-in-out;
        }
         .multiplier-options.onboarding-glow {
             animation: onboarding-glow 1.5s infinite alternate;
         }

        .multiplier-btn {
            background: #333;
            color: var(--text);
            padding: 10px;
            border: none;
            border-radius: var(--button-border-radius);
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
             display: flex; /* Enable flex for label alignment */
             flex-direction: column;
             align-items: center;
             justify-content: center;
             gap: 4px;
        }
        .multiplier-btn:hover:not(:disabled) {
            background: var(--primary);
            transform: scale(1.05);
             box-shadow: 0 4px 10px rgba(153, 69, 255, 0.5);
             animation: subtle-vibrate 0.3s infinite alternate; /* Subtle vibrate on hover */
        }
        .multiplier-btn.active:not(:disabled) {
            background: var(--success);
            transform: scale(1.1);
            box-shadow: 0 44px 10px rgba(20, 241, 149, 0.5);
        }
        .multiplier-btn:disabled {
            background: #555;
            cursor: not-allowed;
             transform: scale(1);
             box-shadow: none;
             opacity: 0.6; /* Indicate disabled state */
             animation: none; /* No vibrate when disabled */
        }
         .multiplier-btn:disabled[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 0.8em;
            margin-bottom: 5px;
            z-index: 11; /* Above controls */
         }
         .multiplier-btn small {
             font-size: 0.6em;
             font-weight: normal;
             color: #aaa; /* Subtle gray */
         }


        .bet-amount {
            display: flex;
            flex-direction: column; /* Stack label and input/value */
            gap: 5px;
        }
         .bet-amount-top {
             display: flex;
             align-items: center;
             gap: 10px;
         }
         .bet-amount-label {
            font-weight: bold;
         }
        .bet-slider {
            flex: 1;
            -webkit-appearance: none; /* Override default appearance */
            appearance: none;
            height: 10px; /* Thicker slider */
            background: #333;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            cursor: pointer;
        }
        .bet-slider:hover:not(:disabled) {
            opacity: 1;
        }
        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; /* Thumb size */
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         .bet-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         .bet-slider:disabled {
             opacity: 0.6;
             cursor: not-allowed;
         }
         .bet-slider:disabled[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 0.8em;
            margin-bottom: 5px;
            z-index: 11; /* Above controls */
         }

        .bet-value {
            font-size: 1.2em; /* Larger value */
            font-weight: bold;
            color: var(--accent);
             min-width: 80px; /* Prevent jumping */
             text-align: right;
        }
         .max-win-text {
             font-size: 0.8em;
             color: #aaa;
             text-align: right;
             margin-top: -10px; /* Pull it closer to the slider */
         }
         .bet-summary {
             font-size: 0.9em;
             color: #ccc;
             margin-top: 10px;
             text-align: center;
         }


        .place-bet, .connect-wallet-btn {
            background: var(--primary);
            color: var(--text);
            padding: 12px;
            border: none;
            border-radius: var(--button-border-radius);
            font-size: 1.1em; /* Larger font */
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
            width: 100%;
             box-shadow: 0 4px 10px rgba(153, 69, 255, 0.5);
        }
        .place-bet:hover:not(:disabled), .connect-wallet-btn:hover:not(:disabled) {
            background: #7A37CC;
            transform: scale(1.02);
             box-shadow: 0 6px 12px rgba(153, 69, 255, 0.7);
        }
        .place-bet:disabled, .connect-wallet-btn:disabled {
            background: #555;
            cursor: not-allowed;
             transform: scale(1);
             box-shadow: none;
             opacity: 0.6; /* Indicate disabled state */
        }
         .place-bet:disabled[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            font-size: 0.8em;
            margin-bottom: 5px;
            z-index: 11; /* Above controls */
         }

         /* Onboarding Tooltip */
         .onboarding-tooltip {
             position: absolute;
             bottom: 100%; /* Position above the target */
             left: 50%;
             transform: translateX(-50%);
             background: var(--accent);
             color: #000;
             padding: 8px 12px;
             border-radius: var(--button-border-radius);
             font-size: 0.9em;
             font-weight: bold;
             white-space: nowrap;
             pointer-events: none; /* Don't block clicks */
             opacity: 0;
             transition: opacity 0.3s ease-in-out;
             margin-bottom: 10px; /* Space between tooltip and target */
             z-index: 11; /* Above controls */
         }
         .onboarding-tooltip.visible {
             opacity: 1;
         }
         .onboarding-tooltip::after {
             content: '';
             position: absolute;
             top: 100%;
             left: 50%;
             transform: translateX(-50%);
             width: 0;
             height: 0;
             border-left: 8px solid transparent;
             border-right: 8px solid transparent;
             border-top: 8px solid var(--accent);
         }


        /* Unified Live Panel Styling */
        .live-panel {
            background: var(--panel-background);
            padding: 12px;
            border-radius: var(--panel-border-radius);
            max-height: 100%; /* Allow panel to take full height of container */
            overflow: hidden; /* Hide content overflow */
            backdrop-filter: blur(6px);
            width: 100%; /* Take full width of container */
            height: 100%; /* Take full height of container */
            font-size: 0.85em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        .live-panel-tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
        }

        .live-panel-tab {
            flex-grow: 1;
            text-align: center;
            padding: 8px 0; /* Increased padding */
            cursor: pointer;
            font-weight: bold;
            color: #aaa;
            border-bottom: 2px solid transparent;
            transition: color 0.2s, border-bottom-color 0.2s;
            position: relative; /* Needed for unread dot */
        }

        .live-panel-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
         .live-panel-tab .unread-dot {
             position: absolute;
             top: 5px;
             right: 5px;
             width: 8px;
             height: 8px;
             background-color: var(--danger); /* Red dot */
             border-radius: 50%;
             display: none; /* Hidden by default */
         }


        .live-panel-content {
            flex-grow: 1;
            overflow-y: auto; /* Allow content to scroll */
            padding-right: 5px; /* Space for scrollbar */
        }
         .live-panel-content::-webkit-scrollbar {
            width: 6px;
         }
         .live-panel-content::-webkit-scrollbar-track {
            background: #333;
            border-radius: 3px;
         }
         .live-panel-content::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
         }


        /* Live Bets Feed (inside live-panel-content) */
        #liveBetsContent {
            display: none; /* Hidden by default */
        }
         #liveBetsContent.active {
            display: block; /* Show when active */
         }

        .bet-entry {
            padding: 8px 0;
            border-bottom: 1px solid #333;
            display: flex;
            gap: 6px;
            animation: enter 0.3s ease-out;
        }
         .bet-entry:last-child {
            border-bottom: none;
         }
         .bet-entry i {
            color: var(--success); /* Coin icon color */
         }
         .bet-entry .user {
            font-weight: bold;
            color: var(--primary);
         }
         .bet-entry .amount {
            color: var(--accent);
         }
         .bet-entry .multiplier {
            font-weight: bold;
         }

        /* Chat Box (inside live-panel-content) */
        #liveChatContent {
             display: none; /* Hidden by default */
             flex-direction: column; /* Use flex column for chat layout */
             height: 100%; /* Fill parent height */
        }
         #liveChatContent.active {
            display: flex; /* Show and use flex layout when active */
         }

         .chat-feed {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 10px;
         }
         .chat-feed::-webkit-scrollbar {
            width: 6px;
         }
         .chat-feed::-webkit-scrollbar-track {
            background: #333;
            border-radius: 3px;
         }
         .chat-feed::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
         }
        .chat-message {
            padding: 8px 0;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: enter 0.3s ease-out;
        }
         .chat-message:last-child {
            border-bottom: none;
         }
         .chat-message .user {
            font-weight: bold;
            color: var(--success); /* User name color */
         }
         .chat-message .system {
            font-style: italic;
            color: #aaa;
         }
        .chat-input {
            display: flex;
            gap: 6px;
            margin-top: auto; /* Push to bottom */
             flex-shrink: 0; /* Prevent shrinking */
        }
        .chat-input input {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: var(--input-border-radius);
            background: #333;
            color: var(--text);
            font-size: 0.85em;
             outline: none;
        }
        .chat-input button {
            background: var(--primary);
            color: var(--text);
            padding: 8px 12px;
            border: none;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            font-size: 0.85em;
             transition: background 0.2s;
        }
         .chat-input button:hover {
            background: #7A37CC;
         }
        .reaction {
            font-size: 0.8em;
            margin-left: 4px;
            cursor: pointer;
             opacity: 0.8;
             transition: opacity 0.2s;
        }
         .reaction:hover {
            opacity: 1;
         }

        /* Achievements */
        .achievement-popup {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--panel-background);
            padding: 12px;
            border-radius: var(--panel-border-radius);
            border-left: 6px solid var(--accent);
            display: flex;
            align-items: center;
            gap: 8px;
            animation: enter 0.3s ease-out;
            z-index: 10;
             box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .badge-icon {
            width: 36px;
            height: 36px;
            background: var(--accent);
            border-radius: 8px;
            display: grid;
            place-items: center;
            font-size: 1.2em;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Share Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9); /* Darker overlay */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
             opacity: 0;
             pointer-events: none;
             transition: opacity 0.3s ease-in-out;
        }
         .modal-overlay.visible {
             opacity: 1;
             pointer-events: auto;
         }
        .modal-content {
            background: var(--secondary);
            padding: 20px;
            border-radius: var(--panel-border-radius);
            text-align: center;
            max-width: 90%; /* Added max-width for mobile */
             width: 400px; /* Fixed width on larger screens */
             box-shadow: 0 8px 20px rgba(0,0,0,0.6);
             transform: translateY(-20px);
             opacity: 0;
             animation: enter 0.3s ease-out forwards;
             position: relative; /* For close button positioning */
             margin: 20px; /* Added margin for mobile padding */
        }
         .modal-content h2 {
            color: var(--success);
            margin-bottom: 10px;
         }
         .modal-content p {
            margin-bottom: 15px;
            color: #ccc;
         }
        .modal-content input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: var(--input-border-radius);
            background: #333;
            color: var(--text);
             font-size: 0.9em;
             cursor: text;
        }
        .modal-content button {
            background: var(--primary);
            color: var(--text);
            padding: 10px 20px;
            border: none;
            border-radius: var(--button-border-radius);
            cursor: pointer;
            margin: 5px;
             transition: background 0.2s;
        }
         .modal-content button:hover {
            background: #7A37CC;
         }
         .modal-content .close-btn {
             position: absolute;
             top: 10px;
             right: 10px;
             background: none;
             border: none;
             font-size: 1.5em;
             color: #aaa;
             cursor: pointer;
         }

        /* Flash Screen */
        .flash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.1s ease-out; /* Faster flash */
        }
        .flash-screen.win {
            background: var(--success);
            opacity: 0.4; /* More intense flash */
        }
         .flash-screen.win-10x {
            background: var(--accent); /* Yellow flash for 10x */
            opacity: 0.6; /* Very intense flash */
         }
        .flash-screen.lose {
            background: var(--danger);
            opacity: 0.4; /* More intense flash */
        }

         /* Confetti Effect (for wins) */
         .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--accent); /* Default color */
            animation: confetti-fall 2s ease-out forwards;
            pointer-events: none;
            z-index: 16; /* Above flash screen */
         }

        /* Leaderboard */
        .leaderboard-panel {
            position: absolute;
            top: 120px;
            right: 10px;
            background: var(--panel-background);
            padding: 12px;
            border-radius: var(--panel-border-radius);
            max-height: 250px;
            overflow-y: auto;
            backdrop-filter: blur(6px);
            width: 250px;
            font-size: 0.85em;
            z-index: 10;
             box-shadow: 0 4px 15px rgba(0,0,0,0.5);
             display: flex; /* Use flexbox for tabs */
             flex-direction: column;
             /* Added margin-top for desktop layout */
             margin-top: 180px;
         }
         /* Leaderboard Auto-Scroll Animation (if needed) */
         /* @keyframes autoscroll {
             0% { transform: translateY(0); }
             100% { transform: translateY(calc(-100% + 250px)); } // Adjust 250px to max-height
         } */


         .leaderboard-tabs {
             display: flex;
             margin-bottom: 10px;
             border-bottom: 1px solid #555;
         }
         .leaderboard-tab {
             flex-grow: 1;
             text-align: center;
             padding: 5px 0;
             cursor: pointer;
             font-weight: bold;
             color: #aaa;
             border-bottom: 2px solid transparent;
             transition: color 0.2s, border-bottom-color 0.2s;
         }
         .leaderboard-tab.active {
             color: var(--accent);
             border-bottom-color: var(--accent);
         }
         .leaderboard-content-tab {
             display: none; /* Hide content tabs by default */
         }
         .leaderboard-content-tab.active {
             display: block; /* Show active content tab */
         }


         .leaderboard-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--accent);
         }
         .leaderboard-entry {
             padding: 6px 0;
             border-bottom: 1px solid #333;
             display: flex;
             justify-content: space-between;
             align-items: center; /* Align items vertically */
         }
         .leaderboard-entry:last-child {
             border-bottom: none;
         }
         .leaderboard-entry .user {
             font-weight: bold;
             color: var(--primary);
             display: flex; /* Enable flex for user + emoji */
             align-items: center;
             gap: 5px;
         }
         .leaderboard-entry .value {
             color: var(--text);
         }

        /* Limited Time Bonus Banner */
        .bonus-banner {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(90deg, var(--accent), #FF8C00); /* Orange-gold gradient */
            color: #000;
            padding: 8px 15px;
            border-radius: var(--button-border-radius);
            font-weight: bold;
            font-size: 0.9em;
            z-index: 12; /* Above header */
            box-shadow: 0 4px 10px rgba(255, 215, 0, 0.5);
            animation: bounce 0.5s infinite alternate; /* Bouncing animation */
            display: none; /* Hidden by default */
        }

        /* Low Balance Alert */
        .low-balance-alert {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--danger);
            color: var(--text);
            padding: 15px 20px;
            border-radius: var(--panel-border-radius);
            font-weight: bold;
            z-index: 15;
            box-shadow: 0 4px 15px rgba(255, 55, 95, 0.5);
            display: none; /* Hidden by default */
            animation: enter 0.3s ease-out;
            text-align: center;
        }
        .low-balance-alert button {
            background: var(--text);
            color: var(--danger);
            padding: 8px 15px;
            border: none;
            border-radius: var(--button-border-radius);
            font-weight: bold;
            margin-top: 10px;
            cursor: pointer;
        }

         /* Refill Demo SOL Modal */
         #refillFakeSolModal .modal-content h2 {
             color: var(--primary);
         }
         #refillFakeSolModal .modal-content button {
             background: var(--success);
             color: #000;
         }

         /* Result Modal */
         #resultModal .modal-content h2.win {
             color: var(--success);
         }
          #resultModal .modal-content h2.lose {
             color: var(--danger);
         }
          #resultModal .modal-content button {
             background: var(--primary);
             color: var(--text);
             margin-top: 20px;
             font-size: 1.2em;
             padding: 12px 25px;
             /* Disable style for Spin Again button */
             transition: opacity 0.2s, background 0.2s;
          }
          #resultModal .modal-content button:disabled {
              opacity: 0.6;
              cursor: not-allowed;
              background: #555;
          }

          /* Idle Modal */
          #idleModal .modal-content h2 {
              color: var(--accent);
          }
           #idleModal .modal-content button {
               background: var(--success);
               color: #000;
           }

           /* Auto Demo Banner */
           .auto-demo-banner {
               position: absolute;
               top: 10px;
               left: 50%;
               transform: translateX(-50%);
               background: rgba(0,0,0,0.7);
               color: var(--accent);
               padding: 8px 15px;
               border-radius: var(--button-border-radius);
               font-weight: bold;
               font-size: 0.9em;
               z-index: 12;
               box-shadow: 0 2px 10px rgba(0,0,0,0.3);
               display: none; /* Hidden by default */
           }

        /* Mobile UI Enhancements */
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Fix iOS height issues */
        .full-height {
            height: -webkit-fill-available;
            height: 100vh;
        }

        /* Enhance touch targets */
        button,
        input[type="button"],
        .clickable {
            min-height: 44px;
            min-width: 44px;
        }

        /* Add haptic feedback styles */
        .haptic-feedback:active {
            transform: scale(0.96);
            transition: transform 0.1s ease-out;
        }


        /* Responsive Design */
        @media (max-width: 767px) {
             /* Mobile-only styles */
             .header {
                 padding: 8px 10px; /* Reduced padding */
                 margin: 5px; /* Reduced margin */
                 width: calc(100% - 10px); /* Adjust for margin */
                 flex-wrap: wrap; /* Allow header items to wrap */
                 justify-content: center; /* Center items when wrapped */
                 gap: 8px; /* Reduced gap */
             }
             .site-title {
                 font-size: 1.2em; /* Reduced font size */
                  flex-basis: 100%; /* Take full width when wrapped */
                 text-align: center;
             }
             .players-online, .user-profile {
                 padding: 6px 10px; /* Reduced padding */
                 font-size: 0.8em; /* Reduced font size */
                 gap: 6px; /* Reduced gap */
             }
             .user-profile {
                 flex-wrap: nowrap; /* Prevent wrapping inside user profile */
                 min-width: 0; /* Allow shrinking */
             }
             .avatar {
                 width: 24px; /* Reduced size */
                 height: 24px;
                 font-size: 0.8em;
             }
             .xp-bar {
                 width: 50px; /* Reduced width */
                 height: 6px; /* Reduced height */
             }
             .sol-balance-display {
                 font-size: 0.9em; /* Reduced font size */
             }
              .fake-winnings-display {
                 font-size: 0.7em; /* Reduced font size */
                 margin-left: 5px; /* Reduced margin */
             }

             /* Demo Mode Banner Mobile Position */
             .guest-banner {
                 top: 50px; /* Position slightly lower on mobile */
                 font-size: 0.7em; /* Smaller font on mobile */
                 padding: 4px 8px; /* Reduced padding */
             }


             .global-timer {
                 top: 80px; /* Adjusted position below header/guest banner */
                 padding: 8px 15px; /* Reduced padding */
                 font-size: 0.9em; /* Reduced font size */
             }
              .pre-spin-cta {
                 top: 115px; /* Adjusted position below timer */
                 padding: 6px 10px; /* Reduced padding */
                 font-size: 0.9em; /* Reduced font size */
             }

             /* Adjust padding for content above sticky bet controls on mobile */
             .container {
                 padding-bottom: 150px; /* Add padding to avoid content being hidden by sticky controls */
             }

             .bet-controls {
                 position: fixed; /* Keep fixed at bottom on mobile */
                 bottom: 0;
                 left: 0;
                 width: 100%;
                 border-radius: 0;
                 margin: 0;
                 padding: 10px; /* Reduced padding */
                 padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* Add safe area inset */
                 box-shadow: 0 -4px 15px rgba(0,0,0,0.5);
                 gap: 10px; /* Reduced gap */
                 /* Remove desktop margin-top */
                 margin-top: 0;
             }
             .bet-slider::-webkit-slider-thumb {
                 width: 25px; /* Larger thumb */
                 height: 25px;
             }
             .bet-slider::-moz-range-thumb {
                 width: 25px; /* Larger thumb */
                 height: 25px;
             }

             /* Live Panel Mobile Positioning */
             .live-panel-container {
                 top: 0; /* Full height from top */
                 right: 0; /* Position from right */
                 width: 250px; /* Mobile width */
                 height: 100%; /* Full height */
                 transform: translateX(100%); /* Start hidden offscreen right */
             }
             .live-panel-container.active {
                 transform: translateX(0); /* Slide in fully */
             }
              /* Removed .live-panel-container.closed as active/non-active handles state */

             .live-panel {
                 padding: 8px; /* Reduced padding inside the panel */
             }
             .live-panel-toggle-btn {
                 top: 120px; /* Position mid-right */
                 right: 10px; /* Keep on the right edge */
                 width: 44px; /* Touch target size */
                 height: 44px; /* Touch target size */
                 border-radius: 8px 0 0 8px; /* Rounded left side */
             }
              /* Position toggle button when panel is open on mobile */
             .live-panel-container.active + .live-panel-toggle-btn {
                 transform: translateX(-250px); /* Move button with the panel by panel width */
             }

             .live-panel-tab {
                 padding: 6px 0; /* Reduced padding */
                 font-size: 0.8em; /* Reduced font size */
             }
             .live-panel-content {
                 font-size: 0.8em; /* Reduced font size */
             }
             .bet-entry, .chat-message {
                 padding: 6px 0; /* Reduced padding */
                 gap: 4px; /* Reduced gap */
             }
             .chat-input {
                 gap: 4px; /* Reduced gap */
             }
             .chat-input input, .chat-input button {
                 padding: 6px; /* Reduced padding */
                 font-size: 0.8em; /* Reduced font size */
             }

             .leaderboard-panel {
                 display: none; /* Hide leaderboard on small screens */
             }
             /* Removed token-notification mobile styles as $SPIN is removed */
             .achievement-popup {
                 bottom: auto; /* Remove fixed bottom position */
                 top: 80px; /* Position near live panel */
                 left: 5px;
                 padding: 8px 12px;
                 font-size: 0.8em; /* Reduced font size */
             }
             .low-balance-alert {
                 bottom: calc(150px + 20px); /* Position above bet controls */
                 padding: 10px 15px;
                 font-size: 0.9em; /* Reduced font size */
             }
             .recent-spins {
                 bottom: 160px; /* Position above bet controls */
                 padding: 6px 10px; /* Reduced padding */
                 font-size: 0.7em; /* Reduced font size */
                 gap: 3px; /* Reduced gap */
             }
             .bonus-banner {
                 top: 60px; /* Adjust position */
                 font-size: 0.8em;
                 padding: 6px 12px;
             }
             .fake-activity-banner {
                 top: 50px; /* Adjust position */
                 font-size: 0.7em;
                 padding: 4px 8px;
             }
             .ten-x-hit-banner {
                 top: 150px; /* Adjust position */
                 font-size: 0.9em;
                 padding: 6px 12px;
             }

             /* Sticky Bet Controls when Keyboard is NOT open */
             body:not(.keyboard-open) .bet-controls {
                 position: fixed;
                 bottom: 0;
                 left: 0;
                 width: 100%;
                 border-radius: 0;
                 margin: 0;
                 padding: 10px; /* Reduced padding */
                 padding-bottom: calc(10px + env(safe-area-inset-bottom));
                 box-shadow: 0 -4px 15px rgba(0,0,0,0.5);
                 gap: 10px; /* Reduced gap */
             }
              /* Adjust padding when keyboard is open */
             body.keyboard-open .container {
                 padding-bottom: 15px; /* Reduce bottom padding when keyboard is open */
             }
             body.keyboard-open .bet-controls {
                 position: static; /* Make bet controls static when keyboard is open */
                 margin-bottom: 0;
                 padding-bottom: 10px; /* Ensure bottom padding */
             }

             /* Modal Scaling on Mobile */
             .modal-content {
                padding: 15px; /* Reduced padding */
                margin: 10px; /* Reduced margin */
             }
             .modal-content h2 {
                font-size: 1.2em; /* Reduced font size */
             }
             .modal-content p {
                font-size: 0.9em; /* Reduced font size */
             }
             .modal-content button {
                padding: 8px 15px; /* Reduced padding */
                font-size: 1em; /* Reduced font size */
             }
             .modal-content .close-btn {
                font-size: 1.2em; /* Reduced size */
                top: 5px;
                right: 5px;
             }
        }

        @media (min-width: 768px) {
             .container {
                 flex-direction: row; /* Layout side-by-side */
                 justify-content: center;
                 align-items: center;
                 gap: 40px;
                 padding: 20px;
             }
             .header {
                 position: absolute;
                 top: 20px;
                 left: 50%;
                 transform: translateX(-50%);
                 width: auto; /* Auto width */
                 max-width: 960px;
                 /* Reset mobile specific styles */
                 padding: 10px 15px;
                 margin: 10px;
                 flex-wrap: nowrap;
                 justify-content: space-between;
                 gap: 10px;
             }
             .site-title {
                 font-size: 1.5em;
                 flex-basis: auto;
                 text-align: left;
             }
             .players-online, .user-profile {
                 padding: 8px 12px;
                 font-size: 0.9em;
                 gap: 8px;
             }
             .user-profile {
                 flex-wrap: nowrap;
             }
             .avatar {
                 width: 28px;
                 height: 28px;
                 font-size: 0.9em;
             }
              .xp-bar {
                 width: 70px;
                 height: 8px;
             }
             .sol-balance-display {
                 font-size: 1em;
             }
              .fake-winnings-display {
                 font-size: 0.8em;
                 margin-left: 10px;
             }

             /* Demo Mode Banner Desktop Position */
             .guest-banner {
                 top: 10px; /* Position near header */
                 font-size: 0.8em; /* Standard font size */
                 padding: 5px 10px; /* Standard padding */
             }


             .global-timer {
                 top: 100px; /* Adjusted position */
                 padding: 10px 20px;
                 font-size: 1em;
             }
              .pre-spin-cta {
                 top: 140px; /* Adjusted position */
                 padding: 8px 15px;
                 font-size: 1em;
             }


            .wheel-container {
                 width: 400px;
                 height: 400px;
                 margin: 0; /* Remove auto margin */
                 margin-top: 180px; /* Space for header/timer/cta */
             }
             #rouletteCanvas {
                 /* Adjust canvas size if needed, but CSS width/height should handle scaling */
             }

             /* Unified Live Panel on Desktop */
             .live-panel-container {
                 position: static; /* Remove fixed positioning */
                 max-height: none; /* Allow full height */
                 overflow: hidden; /* Keep overflow hidden for tab content */
                 width: 300px;
                 margin: 0;
                 align-self: stretch; /* Stretch to fill height */
                 margin-top: 180px; /* Space for header/timer/cta */
                 transform: translateX(0); /* Ensure visible on desktop */
             }
              /* Removed .live-panel-container.closed and .live-panel-container.active desktop styles */

             .live-panel {
                 padding: 12px; /* Reset padding */
             }
             .live-panel-toggle-btn {
                 display: none; /* Hide toggle button on desktop */
             }
              .live-panel-tab {
                 padding: 8px 0; /* Reset padding */
                 font-size: 0.85em; /* Reset font size */
             }
             .live-panel-content {
                 font-size: 0.85em; /* Reset font size */
             }
              .bet-entry, .chat-message {
                 padding: 8px 0; /* Reset padding */
                 gap: 6px; /* Reset gap */
             }
             .chat-input {
                 gap: 6px; /* Reset gap */
             }
             .chat-input input, .chat-input button {
                 padding: 8px; /* Reset padding */
                 font-size: 0.85em; /* Reset font size */
             }


             .bet-controls {
                 position: static; /* Remove absolute positioning */
                 width: 400px; /* Match wheel width */
                 margin: 20px 0 0 0; /* Space below wheel */
                 padding: 15px; /* Reset padding */
                 gap: 15px; /* Reset gap */
                 margin-top: 20px; /* Reset desktop margin-top */
             }
             body:not(.keyboard-open) .bet-controls {
                 position: static; /* Ensure static positioning on desktop */
                 padding-bottom: 15px; /* Ensure bottom padding */
             }
              body.keyboard-open .bet-controls {
                 position: static; /* Ensure static positioning on desktop */
                 margin-bottom: 0;
                 padding-bottom: 15px; /* Ensure bottom padding */
             }


             /* Removed token-notification desktop styles as $SPIN is removed */
             .achievement-popup {
                 bottom: auto;
                 top: 180px; /* Position below timer */
                 left: 10px;
                 padding: 12px;
                 font-size: 0.85em;
             }
             .leaderboard-panel {
                 position: static; /* Remove absolute positioning */
                 max-height: none;
                 overflow-y: visible;
                 width: 300px;
                 margin: 0;
                 align-self: stretch;
                 margin-top: 180px;
             }
             .low-balance-alert {
                 bottom: 20px;
                 left: auto;
                 right: 20px; /* Position on the right */
                 transform: none;
                 padding: 15px 20px;
                 font-size: 1em;
             }
              .bonus-banner {
                 top: 10px;
                 left: 50%;
                 transform: translateX(-50%);
                 font-size: 0.9em;
                 padding: 8px 15px;
             }
             /* Auto Demo Banner Desktop Position */
             .auto-demo-banner {
                  top: 10px; /* Position next to guest banner */
                  font-size: 0.9em;
                  padding: 8px 15px;
             }

             /* Modal Scaling on Desktop */
             .modal-content {
                padding: 20px;
                margin: 20px;
             }
             .modal-content h2 {
                font-size: 1.5em;
             }
             .modal-content p {
                font-size: 1em;
             }
             .modal-content button {
                padding: 10px 20px;
                font-size: 1.1em;
             }
             .modal-content .close-btn {
                font-size: 1.5em;
                top: 10px;
                right: 10px;
             }
        }

/* Final fix for global timer and CTA alignment */
/* Removed conflicting rules */


/* Raise wheel higher for full visibility */
/* Removed conflicting rules */

/* Resize and reposition the modal close button */
.modal-content .close-btn {
    font-size: 1.2em !important;
    transform: scale(0.7) !important;
    top: 8px !important;
    right: 8px !important;
    padding: 2px !important;
    line-height: 1 !important;
    background: none !important;
    z-index: 999 !important;
}


/* Position timer and CTA just below the shop button */
/* Removed conflicting rules */


/* Lock final positioning of Next Spin & Place Your Bets just below Shop button */
/* Removed conflicting rules */


/* Move Recent Spins into top-right area below header */
.recent-spins {
    position: absolute !important;
    top: 135px !important;
    right: 16px !important;
    left: auto !important;
    bottom: auto !important;
    transform: none !important;
    background-color: rgba(0, 0, 0, 0.6) !important;
    padding: 4px 10px !important;
    font-size: 0.7em !important;
    border-radius: 10px !important;
    z-index: 999 !important;
    pointer-events: none !important;
}

/* Override any wheel container rules forcing it inside */
.wheel-container .recent-spins {
    position: absolute !important;
}


.tooltip-warning, #tooltip, .onboarding-tooltip.visible { display: none !important; opacity: 0 !important; pointer-events: none !important; }</style>
</head>
<body>
<div class="background-overlay" id="backgroundOverlay"></div>
<div class="strobe-overlay" id="strobeOverlay"></div>
<div class="container">
<div class="flash-screen" id="flashScreen"></div>
<div class="guest-banner" id="guestModeBanner" style="display: none;" title="You're playing with Demo SOL. Connect wallet to win real rewards.">
              Demo Mode  Demo SOL Only
        </div>
<div class="auto-demo-banner" id="autoDemoBanner" style="display: none;">
             Auto demo in progress  Tap anything to join
         </div>
<div class="header">
<div class="site-title">SolRoulette LIVE</div>
<div class="players-online"><i class="fas fa-users"></i> <span id="playersOnline">1,247</span> Online</div>
<div class="user-profile" id="userProfile">
</div>
</div>
<div class="global-timer" id="globalTimer"> Next Spin: 25s</div>
<div class="pre-spin-cta" id="preSpinCta">Place your bets...</div>
<div class="bonus-banner" id="bonusBanner" style="display: none;"></div> <div class="live-panel-container" id="livePanelContainer">
<div class="live-panel" id="livePanel">
<div class="live-panel-tabs">
<div class="live-panel-tab active" data-tab="bets" aria-label="Live Bets Tab">Live Bets <span class="unread-dot" id="betsUnreadDot"></span></div>
<div class="live-panel-tab" data-tab="leaderboard" aria-label="Leaderboard Tab">Leaderboard <span class="unread-dot" id="leaderboardUnreadDot"></span></div>
<div class="live-panel-tab" data-tab="chat" aria-label="Live Chat Tab">Live Chat <span class="unread-dot" id="chatUnreadDot"></span></div>
</div>
<div class="live-panel-content">
<div class="live-panel-content-tab active" id="liveBetsContent">
<div class="bet-entry"><i class="fas fa-dice"></i> <span class="system">System:</span> Welcome to SolRoulette LIVE!</div>
</div>
<div class="live-panel-content-tab" id="liveLeaderboardContent" style="display:none;">
  <div class="leaderboard-title">Top Players</div>
  <div class="leaderboard-entry"><span class="user">Alice</span> <span class="value">123.45</span></div>
  <div class="leaderboard-entry"><span class="user">Bob</span> <span class="value">98.76</span></div>
  <div class="leaderboard-entry"><span class="user">Charlie</span> <span class="value">77.00</span></div>
</div>

<div class="live-panel-content-tab" id="liveChatContent">
<div class="chat-feed" id="chatFeed">
<div class="chat-message"><i class="fas fa-robot"></i> <span class="system">System:</span> Spin to win big! <span class="reaction"></span></div>
</div>
<div class="chat-input">
<input aria-label="Chat input" id="chatInput" placeholder="Type a message..." type="text"/>
<button aria-label="Send chat message" id="sendChatBtn">Send</button>
</div>
</div>
</div>
</div>
</div>
<button aria-label="Toggle Live Panel" class="live-panel-toggle-btn" id="toggleLivePanel">
<i class="fas fa-chevron-left"></i> <span class="unread-dot" id="livePanelUnreadDot"></span>
</button>
<div class="leaderboard-panel" id="leaderboardPanel">
<div class="leaderboard-tabs">
<div class="leaderboard-tab active" data-tab="wager" aria-label="Top Wager Leaderboard">Top Wager</div>
<div class="leaderboard-tab" data-tab="streak" aria-label="Win Streak Leaderboard">Streak</div>
<div class="leaderboard-tab" data-tab="10x" aria-label="10x Wins Leaderboard">10x Wins</div>
</div>
<div id="leaderboardContent">
<div class="leaderboard-content-tab active" data-tab="wager">
</div>
<div class="leaderboard-content-tab" data-tab="streak">
</div>
<div class="leaderboard-content-tab" data-tab="10x">
</div>
</div>
</div>
<div class="wheel-container" id="wheelContainer">
<div class="pointer" id="pointer"></div>
<canvas id="rouletteCanvas"></canvas>
<div class="recent-spins" id="recentSpins">
<span class="label">Recent:</span>
</div>
</div>
<div class="bet-controls">
<div class="onboarding-tooltip" id="onboardingTooltip">Start here  Pick your multiplier.</div>
<div class="bet-label">Select Multiplier</div>
<div class="multiplier-options" id="multiplierOptions">
<button class="multiplier-btn haptic-feedback" data-multiplier="1.5" data-probability="30" title="" aria-label="1.5x Multiplier Bet">1.5x<small>Chance: 30%</small></button>
<button class="multiplier-btn haptic-feedback" data-multiplier="2" data-probability="20" title="" aria-label="2x Multiplier Bet">2x<small>Chance: 20%</small></button>
<button class="multiplier-btn haptic-feedback" data-multiplier="3" data-probability="20" title="" aria-label="3x Multiplier Bet">3x<small>Chance: 20%</small></button>
<button class="multiplier-btn haptic-feedback" data-multiplier="5" data-probability="15" title="" aria-label="5x Multiplier Bet">5x<small>Chance: 15%</small></button>
<button class="multiplier-btn haptic-feedback" data-multiplier="10" data-probability="15" title="" aria-label="10x Multiplier Bet">10x<small>Chance: 15%</small></button>
</div>
<div class="bet-amount">
<div class="bet-amount-top">
<span class="bet-amount-label">Bet Amount:</span>
<input class="bet-slider" id="betSlider" max="10" min="0.01" step="0.01" title="" type="range" value="0.5" aria-label="Bet amount slider"/>
<span class="bet-value" id="betValue">0.50 SOL</span>
</div>
<div class="max-win-text">Max Win Per Round: 50</div>
</div>
<div class="bet-summary" id="betSummary" style="display: none;">
</div>
<button class="connect-wallet-btn haptic-feedback" id="connectWalletBtn" aria-label="Connect Solana Wallet">Connect Wallet</button>
<button class="place-bet haptic-feedback" id="placeBetBtn" style="display: none;" title="Connect your wallet to place real bets" aria-label="Place Bet Button"> Place Bet</button>
</div>
<div id="achievementContainer"></div>
<div class="modal-overlay" id="walletModal">
<div class="modal-content">
<button aria-label="Close wallet modal" class="close-btn haptic-feedback" id="closeWalletModalBtn"></button>
<h2>Connect Your Wallet</h2>
<p>Choose a wallet to connect and start betting.</p>
<button aria-label="Connect Phantom Wallet" class="connect-wallet-button haptic-feedback" data-wallet="phantom" id="connectPhantomBtn">
                    Connect Phantom
                </button>
<button class="secondary-btn haptic-feedback" id="justWatchingBtn" aria-label="Just Watching">Just Watching? Close</button>
</div>
</div>
<div class="modal-overlay" id="profileModal">
<div class="modal-content">
<button aria-label="Close profile modal" class="close-btn haptic-feedback" id="closeProfileModalBtn"></button>
<h2>Your Profile <span class="verified-badge" id="verifiedBadge" title="Wallet Verified"><i class="fas fa-check-circle"></i></span></h2>
<div id="profileContent">
<div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
<div class="avatar large" id="profileAvatar"></div>
<div>
<div id="profileName" style="font-size: 1.2em; font-weight: bold;">Guest</div>
<div style="color: #aaa;">Level <span id="profileLevel">1</span></div>
<div class="xp-bar large" style="width: 150px;"><div class="xp-fill" id="profileXpFill" style="width: 0%;"></div></div>
</div>
</div>
<p>Wallet: <span id="profileWallet">Not Connected</span></p>
<p>Balance: <span id="profileBalance">0.00 SOL</span></p>
<p>Total Wagered: <span id="profileTotalWagered">0.00 SOL</span></p>
<p>Win Streak: <span id="profileWinStreak">0</span></p>
<p>10x Wins: <span id="profileTenXWins">0</span></p>
<p id="profileFakeWinnings" style="display: none;">Demo Winnings: <span id="fakeWinningsTotal">0.00</span> SOL</p>
<h3>Profile Settings</h3>
<input id="usernameInput" placeholder="Enter username" maxlength="20" aria-label="Enter username"/>
<button class="haptic-feedback" id="saveUsernameBtn" aria-label="Save Username">Save</button>
<h3>Achievements</h3>
<div id="profileAchievementsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); gap: 10px; margin-top: 10px;">
</div>
<h3>Referral Code</h3>
<input id="referralLinkInput" readonly="" type="text" aria-label="Referral link"/>
<button class="haptic-feedback" id="copyReferralLinkBtn" aria-label="Copy Referral Link">Copy Referral Link</button>
<button class="haptic-feedback" id="resetGuestProgressBtn" style="display: none; background: var(--danger); color: var(--text); margin-top: 20px;" aria-label="Reset Guest Progress">Reset Guest Progress</button>
</div>
</div>
</div>
<div class="modal-overlay" id="resultModal">
<div class="modal-content">
<button aria-label="Close result modal" class="close-btn haptic-feedback" id="closeResultModalBtn"></button>
<h2 id="resultModalTitle"></h2>
<p id="resultModalMessage"></p>
<button class="haptic-feedback" id="resultModalSpinAgainBtn" aria-label="Spin Again">Spin Again</button>
</div>
</div>
<div class="modal-overlay" id="messageBox">
<div class="modal-content">
<button aria-label="Close message box" class="close-btn haptic-feedback" id="closeMessageBoxBtn"></button>
<h2 id="messageBoxTitle"></h2>
<p id="messageBoxContent"></p>
<button class="haptic-feedback" id="messageBoxOkBtn" aria-label="OK">OK</button> </div>
</div>
<div class="modal-overlay" id="shareModal" style="display: none;">
    <div class="modal-content">
        <button aria-label="Close share modal" class="close-btn haptic-feedback" id="closeShareModalBtn"></button>
        <h2 id="shareTitle"></h2>
        <p id="shareMessage"></p>
        <input type="text" id="shareText" readonly aria-label="Share text"/>
        <button class="haptic-feedback" id="copyShareTextBtn" aria-label="Copy Share Text">Copy</button>
        <button class="haptic-feedback" id="tweetWinBtn" aria-label="Tweet Win">Tweet</button>
    </div>
</div>
<div class="modal-overlay" id="refillFakeSolModal">
    <div class="modal-content">
        <button aria-label="Close refill modal" class="close-btn haptic-feedback" id="closeRefillFakeSolModalBtn"></button>
        <h2>Demo SOL Low!</h2>
        <p>Your demo SOL balance is too low to place this bet. Would you like to refill?</p>
        <button class="haptic-feedback" id="refillFakeSolBtn" aria-label="Refill Demo SOL">Refill Demo SOL (500)</button>
    </div>
</div>
<div class="low-balance-alert" id="lowBalanceAlert">
             Low Balance! Your SOL is running low.
             <button class="haptic-feedback" id="topUpWalletBtn" aria-label="Top Up Wallet (Mock)">Top Up Now (Mock)</button>
</div>
<div class="low-balance-alert" id="guestModeToast" style="background: rgba(153, 69, 255, 0.9); display: none;">
             Demo Mode  Playing with Demo SOL. Connect wallet to win real rewards.
         </div>
<div class="bonus-banner" id="fakeActivityBanner" style="background: rgba(0,0,0,0.6); color: #fff; animation: none; top: 50px; font-size: 0.8em; padding: 5px 10px;">
<span id="activityWatchers"> 32 watching</span> | <span id="activityBetting">7 betting 10x</span> | <span id="activityWins">3 wins just hit!</span>
</div>
<div class="bonus-banner" id="tenXHitBanner" style="background: linear-gradient(90deg, var(--danger), var(--accent)); color: #fff; animation: bounce 0.5s infinite alternate; top: 150px; font-size: 1em; padding: 8px 15px; display: none;">
              3 others just hit 10x! 
         </div>
</div>
<script src="https://unpkg.com/@solana/web3.js@1.66.0/lib/index.iife.js"></script>
<script src="https://unpkg.com/@solana/wallet-adapter-base@0.9.19/dist/index.js"></script>
<script src="https://unpkg.com/@solana/wallet-adapter-wallets@0.19.9/dist/index.js"></script>
<script src="https://unpkg.com/@solana/wallet-adapter-react-ui@0.9.19/dist/index.js"></script>
<script src="https://unpkg.com/@solana/wallet-adapter-phantom@0.9.19/dist/index.js"></script>
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
        // Global state variables for wallet verification and user balance
        window.walletVerified = false;
        window.userSolBalance = 0; // Tracks real SOL balance from wallet

        // State Management
        let spinTimer = 25;
        let isSpinning = false;
        let walletBalance = parseFloat(localStorage.getItem('solroulette_wallet_balance') || '0'); // Load balance from localStorage
        let xp = parseInt(localStorage.getItem('solroulette_xp') || '0'); // Load XP from localStorage
        let level = parseInt(localStorage.getItem('solroulette_level') || '1'); // Load level from localStorage
        let totalWagered = parseFloat(localStorage.getItem('solroulette_total_wagered') || '0'); // Load total wagered
        let winStreak = parseInt(localStorage.getItem('solroulette_win_streak') || '0'); // Load win streak
        let tenXWins = parseInt(localStorage.getItem('solroulette_ten_x_wins') || '0'); // Load 10x wins
        // Store multiplier as numeric string
        // Load current bet state from localStorage, default to null multiplier and 0 amount
        let currentBet = { multiplier: localStorage.getItem('solroulette_current_multiplier') || null, amount: parseFloat(localStorage.getItem('solroulette_current_amount') || '0') };
        let achievementsUnlocked = new Set(JSON.parse(localStorage.getItem('solroulette_achievements') || '[]')); // Load achievements
        let playersOnline = 1247;
        let playerBets = []; // Array to store bets for the current round
        // Use isGuestMode to track if the user is in demo mode
        let isGuestMode = localStorage.getItem('solroulette_is_guest') === 'true'; // Track guest mode
        let guestSpinCount = parseInt(localStorage.getItem('solroulette_guest_spin_count') || '0'); // Track guest spins for modal
        let recentSpins = JSON.parse(localStorage.getItem('solroulette_recent_spins') || '[]'); // Load recent spins
        // Use fakeWinningsTotal to track demo winnings
        let fakeWinningsTotal = parseFloat(localStorage.getItem('solroulette_fake_winnings_total') || '0'); // Track fake winnings
        let onboardingShown = localStorage.getItem('solroulette_onboarding_shown') === 'true'; // Track if onboarding tooltip has been shown
        let firstRealBetPlaced = localStorage.getItem('solroulette_first_real_bet_placed') === 'true'; // Track if a real bet has been placed
        // Store actual spin result as string with 'x'
        let lastSpinResult = localStorage.getItem('solroulette_last_spin_result') || null; // Store the actual result of the last spin


        // User Profile
        let user = {
            wallet: localStorage.getItem('solroulette_wallet') || null, // Load wallet from localStorage
            name: localStorage.getItem('solroulette_user_name') || 'Guest', // Load name
            avatar: localStorage.getItem('solroulette_user_avatar') || '', // Load avatar
            referral: localStorage.getItem('solroulette_referral_code') || generateReferralCode(), // Load or generate referral code
        };

        // Daily Bonus State (Modified to only give SOL, removed $SPIN logic)
        let lastLoginDate = localStorage.getItem(isGuestMode ? 'solroulette_guest_last_login' : 'solroulette_last_login') || null;
        let dailyBonusDay = parseInt(localStorage.getItem(isGuestMode ? 'solroulette_guest_daily_bonus_day' : 'solroulette_daily_bonus_day') || '0');

        // Idle Timer State
        let idleTimer = null;
        const IDLE_TIMEOUT = 120000; // 2 minutes in milliseconds

        // Auto Demo State
        let isAutoDemo = false;
        let autoDemoTimer = null;
        const AUTO_DEMO_INTERVAL = 25000; // Spin every 25 seconds in auto demo


        // Dev Flags
        window.autoRefill = false; // Set to true in browser console for auto-refill testing


        // Audio Effects (Lazy Loading)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const sounds = {};

        // Implement try...catch for sound loading
        async function loadSound(name, url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                     console.warn(`Failed to fetch sound ${name} from ${url}: ${response.status}`);
                     return; // Exit if fetch fails
                }
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                sounds[name] = audioBuffer;
            } catch (e) {
                console.error(`Error loading sound ${name} from ${url}:`, e);
                // Fallback or silent failure for now due to CORS or other issues
            }
        }

        function playSound(name, volume = 1.0, loop = false) {
            // Ensure audio context is resumed after user interaction
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error("AudioContext resume failed:", e));
            }

            const audioBuffer = sounds[name];
            // Check if the audio buffer exists before trying to play
            if (!audioBuffer || !audioContext || audioContext.state === 'suspended') {
                // console.warn(`Sound "${name}" not loaded, audio context not available, or suspended.`);
                return; // Exit the function if sound is not available or context is suspended
            }

            try {
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume;

                source.connect(gainNode).connect(audioContext.destination);
                source.loop = loop;
                source.start(0);
                return source; // Return source to stop looping sounds later
            } catch (e) {
                console.error(`Error playing sound ${name}:`, e);
                return null; // Return null if playing fails
            }
        }

        let currentTickSound = null; // To control the looping tick sound

        // Debounce function
        function debounce(func, delay) {
            let inDebounce;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(inDebounce);
                inDebounce = setTimeout(() => func.apply(context, args), delay);
            }
        }

        const updateUIDebounced = debounce(updateUI, 50); // Debounce updateUI calls

        // Canvas Wheel Drawing
        const canvas = document.getElementById('rouletteCanvas');
        const ctx = canvas.getContext('2d');
        const segments = [
            { multiplier: '1.5x', color: '--success', probability: 0.3 },
            { multiplier: '2x', color: '--primary', probability: 0.2 },
            { multiplier: '3x', color: '--accent', probability: 0.2 },
            { multiplier: '5x', color: '--success', probability: 0.15 }, // Keeping same as success for visual variety
            { multiplier: '10x', color: '--danger', probability: 0.15 } // Lower chance for 10x
        ];
        const totalProbability = segments.reduce((sum, seg) => sum + seg.probability, 0);
        // Calculate angles based on probability
        let startAngle = 0;
        segments.forEach(segment => {
            segment.startAngle = startAngle;
            segment.endAngle = startAngle + (segment.probability / totalProbability) * 2 * Math.PI;
            segment.middleAngle = segment.startAngle + (segment.endAngle - segment.startAngle) / 2;
            startAngle = segment.endAngle;
        });

        let currentWheelRotation = 0;
        let spinAnimationId = null;
        let spinStartTime = null;
        let spinDuration = 5000; // 5 seconds
        let targetRotation = 0;
        let isNearMiss = false;

        function drawWheel() {
            const size = Math.min(canvas.width, canvas.height);
            const centerX = size / 2;
            const centerY = size / 2;
            // Ensure radius is not negative
            const radius = Math.max(0, size / 2 - 12); // Account for border, ensure non-negative

            ctx.clearRect(0, 0, size, size);

            // Only attempt to draw if the radius is positive
            if (radius > 0) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(currentWheelRotation);

                segments.forEach(segment => {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius, segment.startAngle, segment.endAngle);
                    ctx.closePath();
                    // Correctly get CSS variable value
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(segment.color).trim();
                    ctx.fill();

                    // Draw text
                    ctx.save();
                    // Rotate to the middle of the segment
                    ctx.rotate(segment.middleAngle);
                    ctx.fillStyle = '#FFF';
                    ctx.font = 'bold 24px "Inter", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // Position text away from the center
                    const textRadius = radius * 0.7;
                    ctx.fillText(segment.multiplier, textRadius, 0);
                    ctx.restore();
                });

                ctx.restore();

                // Draw metallic texture effect (simple overlay)
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; // Subtle white overlay
                ctx.globalCompositeOperation = 'overlay'; // Blend mode
                ctx.fill();
                ctx.restore();

                // Draw center circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 0.3, 0, 2 * Math.PI);
                ctx.fillStyle = '#222';
                ctx.fill();
                ctx.lineWidth = 5;
                ctx.strokeStyle = '#444';
                ctx.stroke();

                // Draw center text
                 // Correctly get CSS variable value
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
                ctx.font = 'bold 20px "Press Start 2P", cursive'; // Arcade font for center
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('SPIN', centerX, centerY);
            } else {
                 // Optionally draw a placeholder or message if canvas is too small
                 ctx.fillStyle = '#555';
                 ctx.font = '12px "Inter", sans-serif';
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillText('Canvas too small', centerX, centerY);
            }
        }

        function animateWheel(timestamp) {
            if (!spinStartTime) spinStartTime = timestamp;
            const elapsed = timestamp - spinStartTime;
            const progress = Math.min(elapsed / spinDuration, 1);

            // Easing function (cubic-bezier for spin)
            // This needs to match the CSS transition for the visual pointer effect
            // A simple cubic-bezier(0.25, 0.1, 0.25, 1) can be approximated
            const easedProgress = 1 - Math.pow(1 - progress, 3); // Simple ease-out

            // Calculate rotation based on progress
            // Start fast, slow down towards the end
            // We need to rotate from current position to targetRotation
            // For near-miss, the targetRotation will be adjusted during the spin

            let currentTargetRotation = targetRotation;
             // Apply near-miss fakeout during the last part of the spin
            if (isNearMiss && progress > 0.7 && progress < 0.95) {
                 // Calculate target rotation for 10x (with 'x' for the function)
                 const nearMissTarget = calculateCanvasTargetRotation('10x') + (Math.random() * 20 - 10); // Aim slightly past 10x
                 const nearMissProgress = (progress - 0.7) / (0.95 - 0.7); // Progress within the fakeout phase
                 currentTargetRotation = targetRotation + (nearMissTarget - targetRotation) * Math.sin(nearMissProgress * Math.PI / 2); // Ease into near miss
            }


            currentWheelRotation = currentTargetRotation * easedProgress;


            drawWheel();

            if (progress < 1) {
                spinAnimationId = requestAnimationFrame(animateWheel);
            } else {
                // Animation finished
                isSpinning = false;
                spinStartTime = null;
                // Snap to the final target position to avoid floating point issues
                currentWheelRotation = targetRotation;
                drawWheel();
                // Instead of calling handleSpinResult directly, emit an event to the backend
                // The backend will then determine the result and emit spinResult back to all clients
                // For now, we'll keep the direct call for client-side demo, but note this for backend integration.
                // In a real scenario, this would be: socket.emit('spinFinished', { /* client-side data for verification */ });
                // And backend would respond with 'spinResult'.
                handleSpinResult(); // Client-side demo logic
            }
        }

         // Function to calculate target rotation for canvas
         // This function maps the winning multiplier (string with 'x') to a rotation angle
         function calculateCanvasTargetRotation(winningMultiplierString) {
             const segment = segments.find(seg => seg.multiplier === winningMultiplierString);
             if (!segment) return 0;

             // We want the pointer to land on the middle of the segment
             // The canvas is rotated, so we need to find the rotation value
             // that brings the segment's middle angle to the pointer position (which is at the top, 0 degrees relative to the container)

             // The pointer is at the top (0 degrees relative to the container).
             // The canvas is rotated. We want the segment's middleAngle to align with the top.
             // If the segment's middle angle is M, we need to rotate the canvas by -M
             // However, the canvas drawing starts at 0 degrees to the right (standard canvas arc).
             // Our segments are defined starting from 0 degrees to the right.
             // The pointer is at the top, which is -PI/2 radians or -90 degrees.

             // So, we need to rotate the wheel such that the middle of the winning segment
             // aligns with the pointer's position (-90 degrees).

             const pointerAngle = -Math.PI / 2; // Pointer is at the top (in radians)
             const segmentMiddleAngle = segment.middleAngle; // Middle of the winning segment (in radians)

             // The rotation needed is the difference between the pointer angle and the segment's middle angle.
             // We need to add full rotations to make it spin multiple times.
             const fullRotations = 5; // Spin at least 5 full times
             const rotationInRadians = (pointerAngle - segmentMiddleAngle) + (fullRotations * 2 * Math.PI);

             return rotationInRadians;
         }

        // --- Socket.IO Client Setup ---
        // Connect to the Socket.IO server (replace with your backend URL)
        const socket = io('http://localhost:3000', {
            autoConnect: false // Prevent auto-connection until authenticated
        });

        // Socket.IO Event Listeners
        socket.on('connect', () => {
            console.log('Connected to Socket.IO server!');
            // After successful connection, if we have a JWT, try to authenticate
            const token = localStorage.getItem('jwt_token');
            if (token) {
                socket.emit('authenticate', { token });
            } else {
                // If no token, and not in guest mode, prompt for wallet connect
                if (!isGuestMode) {
                    openWalletModal();
                }
            }
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from Socket.IO server.');
            showToast('error', 'Disconnected', 'Lost connection to the game server. Please refresh.');
        });

        socket.on('authenticated', (userData) => {
            console.log('Authenticated successfully!', userData);
            // Update local user data with data from backend
            user.publicKey = userData.publicKey; // Store full public key
            user.name = userData.username;
            user.avatar = userData.avatar;
            walletBalance = userData.solBalance;
            xp = userData.xp;
            level = userData.level;
            totalWagered = userData.totalWagered;
            winStreak = userData.winStreak;
            tenXWins = userData.tenXWins;
            achievementsUnlocked = new Set(userData.achievements);
            dailyBonusDay = userData.dailyBonusDay;
            lastLoginDate = userData.lastLoginDate;

            // Mark wallet as verified and update UI
            window.walletVerified = true;
            window.userSolBalance = walletBalance; // Sync global SOL balance
            document.body.classList.add('wallet-verified');
            document.getElementById("guestModeBanner").style.display = "none";
            document.getElementById("verifiedBadge").style.display = "inline-block";
            document.getElementById("connectWalletBtn").style.display = "none";
            document.getElementById("placeBetBtn").style.display = "block";

            // Hide all demo UI and update with real SOL
            document.querySelectorAll(".fake-winnings-display").forEach(el => el.style.display = "none");
            document.querySelectorAll(".sol-balance-display").forEach(el => el.style.display = "block");

            isGuestMode = false; // Ensure guest mode is off

            updateUIDebounced();
            addChatMessage('System', `${user.name} joined the game!`, '', 'system');
            closeWalletModal();
            checkDailyBonus(); // Check for daily bonus after connecting wallet
            stopAutoDemo(); // Stop auto demo if it was running

            showToast('success', 'Welcome Back!', 'Your real wallet is now live.');
        });

        socket.on('authError', (message) => {
            console.error('Authentication error:', message);
            showToast('error', 'Auth Failed', message);
            localStorage.removeItem('jwt_token'); // Clear invalid token
            if (!isGuestMode) { // If not in guest mode, prompt to connect wallet again
                openWalletModal();
            }
        });

        socket.on('spinCountdown', ({ timeLeft }) => {
            spinTimer = timeLeft; // Sync frontend timer with backend
            updateTimer(); // Update UI based on new timer value
        });

        socket.on('spinResult', ({ winningMultiplier, betsOutcome, newLeaderboard, newUsersOnline }) => {
            console.log('Received spinResult from backend:', { winningMultiplier, betsOutcome, newLeaderboard, newUsersOnline });

            // Update local state based on backend results
            lastSpinResult = winningMultiplier;
            localStorage.setItem('solroulette_last_spin_result', lastSpinResult);

            // Process individual bet outcomes
            let userWinAmount = 0;
            let userLostAmount = 0;
            let userWon = false;
            let userBetFound = false;

            betsOutcome.forEach(outcome => {
                // Find the user's bet from the current round's playerBets array (if any)
                // Note: In a real system, the backend would tell us *our* outcome directly.
                // For this simulation, we'll match by publicKey if available, or assume the first 'isUser' bet.
                if (outcome.publicKey === user.publicKey || (outcome.isUser && !userBetFound)) { // Prioritize publicKey match
                    userBetFound = true;
                    if (outcome.won) {
                        walletBalance += outcome.winnings;
                        userWinAmount = outcome.winnings;
                        userWon = true;
                        addChatMessage('System', `${user.name} won ${outcome.winnings.toFixed(2)} on ${winningMultiplier}! `, '', 'system');
                    } else {
                        userLostAmount = outcome.amount;
                        addChatMessage('System', `${user.name} busted on ${outcome.multiplier}! `, '', 'system');
                    }
                    // Update local state for user
                    totalWagered = outcome.totalWagered; // Assuming backend sends updated totalWagered
                    winStreak = outcome.winStreak;
                    tenXWins = outcome.tenXWins;
                    xp = outcome.xp;
                    level = outcome.level;
                    achievementsUnlocked = new Set(outcome.achievements);

                    // Save to localStorage (real wallet keys)
                    localStorage.setItem('solroulette_wallet_balance', walletBalance);
                    localStorage.setItem('solroulette_total_wagered', totalWagered);
                    localStorage.setItem('solroulette_xp', xp);
                    localStorage.setItem('solroulette_level', level);
                    localStorage.setItem('solroulette_win_streak', winStreak);
                    localStorage.setItem('solroulette_ten_x_wins', tenXWins);
                    localStorage.setItem('solroulette_achievements', JSON.stringify([...achievementsUnlocked]));
                } else {
                    // Other players' outcomes
                    if (outcome.won) {
                        addChatMessage('System', `@${outcome.username} won on ${winningMultiplier}! `, '', 'system');
                    } else {
                        addChatMessage('System', `@${outcome.username} busted! `, '', 'system');
                    }
                }
            });

            // Add outcome to recent spins
            recentSpins.unshift({ multiplier: winningMultiplier, won: userWon });
            if (recentSpins.length > 10) {
                recentSpins.pop();
            }
            localStorage.setItem('solroulette_recent_spins', JSON.stringify(recentSpins));
            updateRecentSpinsDisplay();

            // Handle user's win/loss feedback
            if (userWon) {
                playSound('win');
                triggerMoneyRain();
                if (parseFloat(winningMultiplier.replace('x', '')) >= 5) {
                    playSound('win_10x');
                    showFlash('win-10x');
                } else {
                    showFlash('win');
                }
                if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 100]);
                showConfetti();
                if (parseFloat(winningMultiplier.replace('x', '')) >= 5) showShareModal(userWinAmount, winningMultiplier);
                document.getElementById('chatInput').value = ` Just hit ${winningMultiplier} on SolRoulette! `;
            } else if (userBetFound) { // Only play sad trombone if user actually placed a bet and lost
                playSound('sad_trombone');
                showFlash('lose');
                if (navigator.vibrate) navigator.vibrate(300);
            }

            // Reset user's current bet state and enable controls
            currentBet = { multiplier: null, amount: 0 };
            document.getElementById('placeBetBtn').disabled = false;
            document.getElementById('placeBetBtn').textContent = ' Place Bet';
            document.querySelectorAll('.multiplier-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.disabled = false;
                btn.title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');
            });
            document.getElementById('betSlider').disabled = false;
            document.getElementById('betSlider').title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');

            checkAchievements();
            updateUIDebounced();

            // Check low balance after result (only in real wallet mode)
            if (!isGuestMode) {
                checkLowBalance();
            } else {
                document.getElementById('lowBalanceAlert').style.display = 'none';
            }

            if (userBetFound) {
                showResultModal(userBet.multiplier + 'x', winningMultiplier, userWon, userWinAmount, userLostAmount);
            }

            // Anti-Tilt and Responsible Gambling: Add a 5-second cooldown after a loss
            if (!userWon && userBetFound) { // Only apply cooldown if user lost a bet
                document.getElementById("placeBetBtn").disabled = true;
                document.getElementById("placeBetBtn").textContent = 'Cooldown...';
                document.querySelectorAll('.multiplier-btn').forEach(btn => {
                    btn.disabled = true;
                    btn.title = 'Cooldown after loss';
                });
                document.getElementById('betSlider').disabled = true;
                document.getElementById('betSlider').title = 'Cooldown after loss';

                setTimeout(() => {
                    document.getElementById("placeBetBtn").disabled = false;
                    document.getElementById("placeBetBtn").textContent = ' Place Bet';
                    document.querySelectorAll('.multiplier-btn').forEach(btn => {
                        btn.disabled = false;
                        btn.title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');
                    });
                    document.getElementById('betSlider').disabled = false;
                    document.getElementById('betSlider').title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');
                    updateUIDebounced();
                }, 5000);
            }

            // Update players online and leaderboard
            playersOnline = newUsersOnline;
            document.getElementById('playersOnline').textContent = playersOnline;
            updateLeaderboard(newLeaderboard); // Pass the new leaderboard data from backend
        });

        socket.on('chatMessage', ({ username, message, publicKey }) => {
            // Determine if it's our own message or someone else's
            const type = publicKey === user.publicKey ? 'user' : 'other';
            addChatMessage(username, message, '', type);
        });

        socket.on('leaderboardUpdate', (data) => {
            updateLeaderboard(data); // Update leaderboard with real-time data
        });

        socket.on('betPlacedConfirmation', ({ username, amount, multiplier }) => {
            // Add other players' bets to the feed immediately
            if (username !== user.name) { // Don't re-add our own bet, it's added on placeBet()
                addBetEntry(`@${username}`, amount, multiplier);
            }
        });

        // Wallet Connection
        async function connectWallet() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);

            const connectWalletBtn = document.getElementById('connectWalletBtn');
            connectWalletBtn.textContent = 'Connecting...';
            connectWalletBtn.disabled = true;


            try {
                // Check if Solana wallet adapters library is loaded
                if (!window.SolanaWalletAdapters) {
                    showMessageBox('Error', 'Wallet Adapter Not Loaded', 'Solana wallet adapters library not found. Please ensure scripts are loaded correctly or try again later.');
                    connectWalletBtn.textContent = 'Connect Wallet';
                    connectWalletBtn.disabled = false;
                    return;
                }

                // Attempt to get PhantomWalletAdapter from the global SolanaWalletAdapters object
                const PhantomWalletAdapter = window.SolanaWalletAdapters.PhantomWalletAdapter;

                if (!PhantomWalletAdapter) {
                    showMessageBox('Error', 'Phantom Adapter Missing', 'Phantom wallet adapter not found within the Solana adapters library. This might be a library issue or an outdated version.');
                    connectWalletBtn.textContent = 'Connect Wallet';
                    connectWalletBtn.disabled = false;
                    return;
                }

                const adapter = new PhantomWalletAdapter();

                // Check if the adapter is available and connectable
                if (!adapter) { // This check might be redundant if PhantomWalletAdapter is already verified
                    showMessageBox('Error', 'Wallet Not Found', 'Phantom wallet not found. Please install it.');
                    connectWalletBtn.textContent = 'Connect Wallet';
                    connectWalletBtn.disabled = false;
                    return;
                }

                await adapter.connect();

                // --- Secure Wallet Signature Verification ---
                const message = `Sign in to SolRoulette LIVE. Nonce: ${Date.now()}`;
                const encodedMessage = new TextEncoder().encode(message);
                try {
                    const signature = await adapter.signMessage(encodedMessage);
                    const publicKeyBase58 = adapter.publicKey.toBase58();

                    // Send signature and public key to backend for verification and JWT issuance
                    const authResponse = await fetch('http://localhost:3000/api/auth/verify-signature', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            publicKey: publicKeyBase58,
                            message: btoa(String.fromCharCode.apply(null, encodedMessage)), // Base64 encode message
                            signature: btoa(String.fromCharCode.apply(null, signature.signature)) // Base64 encode signature
                        })
                    });

                    if (!authResponse.ok) {
                        const errorData = await authResponse.json();
                        throw new Error(errorData.message || 'Signature verification failed on server.');
                    }

                    const { token, user: userData } = await authResponse.json();
                    localStorage.setItem('jwt_token', token); // Store JWT

                    // Update local user data with data from backend
                    user.publicKey = userData.publicKey; // Store full public key
                    user.name = userData.username;
                    user.avatar = userData.avatar;
                    walletBalance = userData.solBalance;
                    xp = userData.xp;
                    level = userData.level;
                    totalWagered = userData.totalWagered;
                    winStreak = userData.winStreak;
                    tenXWins = userData.tenXWins;
                    achievementsUnlocked = new Set(userData.achievements);
                    dailyBonusDay = userData.dailyBonusDay;
                    lastLoginDate = userData.lastLoginDate;

                    // Mark wallet as verified and update UI
                    window.walletVerified = true;
                    window.userSolBalance = walletBalance; // Sync global SOL balance
                    document.body.classList.add('wallet-verified');
                    document.getElementById("guestModeBanner").style.display = "none";
                    document.getElementById("verifiedBadge").style.display = "inline-block";
                    document.getElementById("connectWalletBtn").style.display = "none";
                    document.getElementById("placeBetBtn").style.display = "block";

                    // Hide all demo UI and update with real SOL
                    document.querySelectorAll(".fake-winnings-display").forEach(el => el.style.display = "none");
                    document.querySelectorAll(".sol-balance-display").forEach(el => el.style.display = "block");

                    isGuestMode = false; // Exit demo mode on real wallet connection
                    localStorage.setItem('solroulette_is_guest', 'false'); // Update guest mode status

                    // Mark that a real bet is now possible/wallet is connected
                    firstRealBetPlaced = true;
                    localStorage.setItem('solroulette_first_real_bet_placed', 'true');

                    updateUIDebounced();
                    addChatMessage('System', `${user.name} joined the game!`, '', 'system');
                    closeWalletModal();
                    checkDailyBonus(); // Check for daily bonus after connecting wallet
                    stopAutoDemo(); // Stop auto demo if it was running

                    showToast('success', 'Wallet Verified', 'Your wallet has been successfully verified and connected!');

                    // Connect Socket.IO after successful authentication
                    if (!socket.connected) {
                        socket.connect();
                    }
                    // Emit 'authenticated' to backend to ensure server-side user state is synced
                    socket.emit('authenticate', { token });

                    connectWalletBtn.textContent = ' Wallet Connected';
                    connectWalletBtn.disabled = true;

                    // Fetch SOL periodically (now handled by backend pushing updates or on demand)
                    // setInterval(updateBalance, 30000); // Removed, backend will push updates
                } catch (err) {
                    console.error('Signature verification failed:', err);
                    showMessageBox("Signature Required", `You must sign to verify your wallet. Error: ${err.message}`);
                    await adapter.disconnect();
                    connectWalletBtn.textContent = 'Connect Wallet';
                    connectWalletBtn.disabled = false;
                    return;
                }

            } catch (err) {
                console.error('Wallet connection failed:', err);
                showToast('error', 'Connection Failed', 'Failed to connect wallet. Please try again.');
                if (navigator.vibrate) navigator.vibrate(200); // Vibrate on error
                connectWalletBtn.textContent = 'Connect Wallet';
                connectWalletBtn.disabled = false;
            }
        }

        // Function to update real SOL balance (now primarily driven by backend updates)
        async function updateBalance() {
            if (window.walletVerified && user.publicKey) {
                try {
                    const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl("mainnet-beta"));
                    const publicKey = new solanaWeb3.PublicKey(user.publicKey); // Use user.publicKey
                    const balance = await connection.getBalance(publicKey);
                    const solBalance = (balance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(2);
                    document.getElementById("profileBalance").textContent = `${solBalance} SOL`;
                    window.userSolBalance = parseFloat(solBalance);
                    walletBalance = window.userSolBalance; // Keep internal walletBalance in sync
                    localStorage.setItem('solroulette_wallet_balance', walletBalance); // Save to local storage
                    updateUIDebounced(); // Update UI to reflect new balance
                } catch (error) {
                    console.error("Error fetching SOL balance:", error);
                    showToast('error', 'Balance Update Failed', 'Could not fetch real SOL balance.');
                }
            }
        }


         // Wallet Connection Mobile Fixes
         function handleWalletConnection() {
             const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

             // Deep linking configuration
             const walletConfig = {
                 phantom: {
                     deepLink: 'https://phantom.app/ul/browse/',
                     name: 'Phantom'
                 },
                 solflare: {
                     deepLink: 'https://solflare.com/ul/v1/browse/',
                     name: 'Solflare'
                 }
             };

             document.getElementById('connectPhantomBtn').addEventListener('click', (e) => {
                 if (isMobile) {
                     // For mobile, use deep linking to open the wallet app
                     const currentURL = encodeURIComponent(window.location.href);
                     const deepLink = walletConfig['phantom'].deepLink + currentURL;

                     // Store wallet choice in sessionStorage for return visit
                     sessionStorage.setItem('preferredWallet', 'phantom');

                     // Open wallet app
                     window.location.href = deepLink;
                 } else {
                     connectWallet(); // For desktop, proceed with direct connection
                 }

                 // Add haptic feedback
                 if (navigator.vibrate) {
                     navigator.vibrate(50);
                 }
             });
         }


         function openWalletModal() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             document.getElementById('walletModal').classList.add('visible');
             resetIdleTimer(); // Reset idle timer on modal open
             stopAutoDemo(); // Stop auto demo on modal open
         }

         function closeWalletModal() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             document.getElementById('walletModal').classList.remove('visible');
             resetIdleTimer(); // Reset idle timer on modal close
             // Restart auto demo if it was active before opening the modal (optional, depends on desired flow)
             // if (wasAutoDemoActive) startAutoDemo();
         }

        // Update Timer
        function updateTimer() {
            const timerElement = document.getElementById('globalTimer');
            const pointerElement = document.getElementById('pointer');
            const preSpinCtaElement = document.getElementById('preSpinCta');
            const rouletteCanvas = document.getElementById('rouletteCanvas');

            if (isSpinning) {
                 timerElement.textContent = ` Spinning...`;
                 timerElement.style.background = 'linear-gradient(45deg, var(--accent), var(--primary))';
                 timerElement.classList.remove('urgent');
                 pointerElement.classList.remove('pulse'); // Stop pointer pulse
                 document.getElementById('backgroundOverlay').classList.add('intensify-particles'); // Intensify particles
                 if (currentTickSound) {
                     currentTickSound.stop(); // Stop tick sound when spinning starts
                     currentTickSound = null;
                 }
                 document.getElementById('strobeOverlay').classList.add('active'); // Activate strobe
                 preSpinCtaElement.textContent = 'Bets closed. Spinning now...'; // Update CTA

                 // Disable Spin Again button during spin
                 document.getElementById('resultModalSpinAgainBtn').disabled = true;
                 rouletteCanvas.classList.remove('countdown-glow'); // Remove glow while spinning

                 return;
            }

            document.getElementById('strobeOverlay').classList.remove('active'); // Deactivate strobe
            document.getElementById('backgroundOverlay').classList.remove('intensify-particles'); // De-intensify particles

            // Enable Spin Again button if betting is allowed
            if (!isSpinning && spinTimer > 3) {
                 document.getElementById('resultModalSpinAgainBtn').disabled = false;
            }


            timerElement.textContent = ` Next Spin: ${spinTimer}s`;
            timerElement.style.background = 'linear-gradient(45deg, var(--danger), var(--primary))';
             timerElement.classList.remove('urgent'); // Remove urgent class initially
             pointerElement.classList.remove('pulse'); // Stop pointer pulse
             rouletteCanvas.classList.remove('countdown-glow'); // Remove glow unless countdown is low


            if (spinTimer <= 10 && spinTimer > 0) {
                 timerElement.classList.add('urgent'); // Add urgent class for faster pulse and red gradient
                 // Play tick sound only if not already playing
                 if (!currentTickSound) {
                    currentTickSound = playSound('tick', 0.5, true); // Play tick sound on loop
                 }
                 // Increase pitch as timer nears 0 (mock pitch increase)
                 if (currentTickSound && audioContext && currentTickSound.playbackRate) { // Check playbackRate exists
                     const pitch = 1 + (10 - spinTimer) * 0.05; // Increase pitch by 0.05 for each second closer to 0
                     currentTickSound.playbackRate.setValueAtTime(pitch, audioContext.currentTime);
                 }
                if (spinTimer <= 5) {
                    preSpinCtaElement.textContent = `${spinTimer}s left...`; // Update CTA
                } else {
                     preSpinCtaElement.textContent = 'Place your bets...'; // Default CTA
                }
                 // Add glow to wheel during countdown
                 rouletteCanvas.classList.add('countdown-glow');


            } else {
                 if (currentTickSound) {
                     currentTickSound.stop(); // Stop tick sound when timer is above 10 or is 0
                     currentTickSound = null;
                 }
                 preSpinCtaElement.textContent = 'Place your bets...'; // Default CTA
                 rouletteCanvas.classList.remove('countdown-glow'); // Remove glow if timer is high or zero
            }

             // Pulse pointer when timer is <= 3s
             if (spinTimer <= 3 && spinTimer > 0) {
                 pointerElement.classList.add('pulse');
             } else {
                 pointerElement.classList.remove('pulse');
             }


            if (spinTimer <= 0) {
                // Betting closes 3 seconds before spin
                if (!isSpinning) { // Only spin if not already spinning
                     // Trigger spin animation on frontend
                     spinWheel();
                }
                spinTimer = 25; // Reset timer
                playerBets = []; // Clear local bets for the new round
                // Clear bet feed UI (now inside live panel)
                document.getElementById('liveBetsContent').innerHTML = '<div class="bet-entry"><i class="fas fa-dice"></i> <span class="system">System:</span> Welcome to SolRoulette LIVE!</div>'; // Clear existing bet entries and add welcome message
            } else {
                spinTimer--;
            }
            updateUIDebounced(); // Update UI elements that depend on the timer state
        }

        // Simulate Multiplayer (placing bets for the next round) - Now handled by backend
        function simulateMultiplayer() {
            // This function is largely replaced by backend Socket.IO events.
            // We'll keep a simplified version for frontend-only demo if no backend is running.
            // In a real setup, backend would push these.
            if (!socket.connected) { // Only simulate if not connected to backend
                playersOnline += Math.floor(Math.random() * 10 - 5);
                document.getElementById('playersOnline').textContent = playersOnline;

                const fakeUsers = ['SolDegen', 'CryptoChad', 'MoonApe', 'WheelMaster', 'LuckyLuke', 'GambaGuy', 'AnonBets', 'SolSpinner', 'DeFiKing', 'NFTCollector'];
                const multipliers = ['1.5', '2', '3', '5', '10'];

                if (Math.random() < 0.7) {
                    const newBet = {
                        user: fakeUsers[Math.floor(Math.random() * fakeUsers.length)],
                        amount: parseFloat((Math.random() * 5).toFixed(2)),
                        multiplier: multipliers[Math.floor(Math.random() * multipliers.length)]
                    };
                    addBetEntry(`@${newBet.user}`, newBet.amount, newBet.multiplier);
                }

                if (Math.random() < 0.5) {
                    const fakeMessages = ['Gonna hit 10x this round! ', 'Feeling lucky today!', 'Any big bettors out there?', 'Let\'s gooo!', 'Hope I don\'t bust ', 'What multiplier are you guys on?', 'Spin it!', 'To the moon! ', 'Wen 10x?', 'This wheel is rigged! '];
                    addChatMessage(fakeUsers[Math.floor(Math.random() * fakeUsers.length)], fakeMessages[Math.floor(Math.random() * fakeMessages.length)], '', 'user');
                }
            }
            updateFakeActivityBanner();
        }

         // Update Fake Activity Banner
         function updateFakeActivityBanner() {
             const watchers = Math.floor(Math.random() * 50) + 20; // 20-70 watchers
             const betting10x = Math.floor(Math.random() * 10); // 0-10 betting 10x
             const winsHit = Math.floor(Math.random() * 5); // 0-5 wins

             document.getElementById('activityWatchers').textContent = ` ${watchers} watching`;
             document.getElementById('activityBetting').textContent = `${betting10x} betting 10x`;
             document.getElementById('activityWins').textContent = `${winsHit} wins just hit!`;
         }

         // Show 10x Hit Banner (Fake)
         function showTenXHitBanner() {
             const banner = document.getElementById('tenXHitBanner');
             banner.style.display = 'block';
             playSound('win_10x'); // Play a sound effect
             setTimeout(() => {
                 banner.style.display = 'none';
             }, 3000); // Hide after 3 seconds
         }


        // Add Bet Entry to Feed
        function addBetEntry(user, amount, multiplier) {
            const feed = document.getElementById('liveBetsContent'); // Append to liveBetsContent
            const entry = document.createElement('div');
            entry.className = 'bet-entry';
            // Display multiplier with 'x' in the feed
            entry.innerHTML = `<i class="fas fa-dice"></i> <span class="user">${user}</span> bet <span class="amount">${amount.toFixed(2)}</span> on <span class="multiplier">${multiplier}x</span>`;
            feed.appendChild(entry);
            feed.scrollTop = feed.scrollHeight; // Auto-scroll to bottom

             // Show unread dot if live panel is closed
             const livePanelContainer = document.getElementById('livePanelContainer');
             // Check if the panel is NOT active (i.e., closed)
             if (!livePanelContainer.classList.contains('active')) {
                 document.getElementById('livePanelUnreadDot').style.display = 'block';
                 document.getElementById('betsUnreadDot').style.display = 'block';
             }
        }

        // Add Chat Message to Feed
        function addChatMessage(user, text, reaction, type) { // Added type parameter
            const chatFeed = document.getElementById('chatFeed'); // Use chatFeed div
            const msg = document.createElement('div');
            msg.className = 'chat-message';
            const userClass = type === 'system' ? 'system' : 'user';
            msg.innerHTML = `<i class="fas ${type === 'system' ? 'fa-robot' : 'fa-user'}"></i> <span class="${userClass}">${user}:</span> ${text} <span class="reaction">${reaction}</span>`;
            chatFeed.appendChild(msg); // Append to chatFeed
            chatFeed.scrollTop = chatFeed.scrollHeight; // Auto-scroll to bottom

            // Show unread dot if live panel is closed or on bets tab
            const livePanelContainer = document.getElementById('livePanelContainer');
            const chatTab = document.querySelector('.live-panel-tab[data-tab="chat"]');
            // Check if the panel is NOT active OR if the chat tab is NOT active
            if (!livePanelContainer.classList.contains('active') || !chatTab.classList.contains('active')) {
                document.getElementById('livePanelUnreadDot').style.display = 'block';
                document.getElementById('chatUnreadDot').style.display = 'block';
            }
        }

        // Send Chat
        function sendChat() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            if (!text) return;

            if (window.walletVerified && user.publicKey) {
                // Send chat message to backend via Socket.IO
                socket.emit("chatMessage", { message: text });
                input.value = "";
            } else {
                showMessageBox("Unverified Wallet", "Please connect and verify your wallet first to chat.");
            }

            xp += 5; // Earn XP for chatting
            checkAchievements();
            updateUIDebounced();

            input.value = '';
            resetIdleTimer(); // Reset idle timer on chat
            stopAutoDemo(); // Stop auto demo on chat interaction
        }

        // Place Bet
        async function placeBet() {
             // Block Betting Unless Verified
             if (!window.walletVerified) {
                 showMessageBox("Unverified Wallet", "Please connect and verify your wallet first.");
                 return;
             }
             if (window.userSolBalance < currentBet.amount) { // Use window.userSolBalance
                 showMessageBox("Insufficient SOL", "You dont have enough SOL to place this bet.");
                 return;
             }

             // Enforce Global Spin Timer
             // Get the current timer value from the UI, parse it
             const timerText = document.getElementById("globalTimer").textContent;
             const timerMatch = timerText.match(/(\d+)s/);
             const timer = timerMatch ? parseInt(timerMatch[1]) : 0;

             if (timer > 3) {
                 showMessageBox("Wait", "You can only place bets in the final 3 seconds before the spin.");
                 return;
             }

            // Null Bet Bug - Check for multiplier and amount > 0
            if (currentBet.multiplier === null || currentBet.amount <= 0) {
                showMessageBox('Invalid Bet', 'Please select a multiplier and enter a bet amount greater than 0.');
                 if (navigator.vibrate) navigator.vibrate(200);
                return; // Prevent placing bet if conditions not met
            }

            // Play bet confirmation sound
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(80); // Haptic feedback on spin start

            const amount = currentBet.amount;

            // Demo SOL Deduction & Refill Modal (only for guest mode)
            if (isGuestMode) {
                 if (walletBalance < amount) {
                     if (window.autoRefill) {
                         refillFakeSol();
                         if (walletBalance < amount) { // Re-check after refill
                             showMessageBox('Insufficient Balance', 'Insufficient SOL balance even after refill!');
                             if (navigator.vibrate) navigator.vibrate(200);
                             return;
                         }
                     } else {
                         openRefillFakeSolModal();
                         return;
                     }
                 }
                // Deduct demo amount immediately
                walletBalance -= amount;
                totalWagered += amount;
                localStorage.setItem('solroulette_guest_balance', walletBalance);
                localStorage.setItem('solroulette_guest_total_wagered', totalWagered);
                guestSpinCount++;
                localStorage.setItem('solroulette_guest_spin_count', guestSpinCount);
                addChatMessage('System', `Demo transaction sent: ${amount.toFixed(2)} on ${currentBet.multiplier}x!`, '', 'system');
                updateUIDebounced(); // Update UI to show deducted balance
                spinWheel(); // Trigger spin animation for demo mode
            } else {
                // Real wallet bet: Emit to backend
                try {
                    // Disable bet controls immediately to prevent double-betting
                    document.getElementById('placeBetBtn').disabled = true;
                    document.getElementById('placeBetBtn').textContent = 'Bet Placed!';
                    document.querySelectorAll('.multiplier-btn').forEach(btn => {
                        btn.disabled = true;
                        btn.title = 'Betting is closed';
                    });
                    document.getElementById('betSlider').disabled = true;
                    document.getElementById('betSlider').title = 'Betting is closed';

                    socket.emit('placeBet', {
                        amount: amount,
                        multiplier: currentBet.multiplier // Send numeric string
                    });
                    addChatMessage('System', `Transaction sent: ${amount.toFixed(2)} on ${currentBet.multiplier}x!`, '', 'system');
                    firstRealBetPlaced = true;
                    localStorage.setItem('solroulette_first_real_bet_placed', 'true');
                    stopAutoDemo(); // Stop auto demo on first real bet
                    updateUIDebounced(); // Update UI to reflect button state
                } catch (error) {
                    console.error('Error placing bet:', error);
                    showToast('error', 'Bet Failed', 'Failed to place bet. Please try again.');
                    if (navigator.vibrate) navigator.vibrate(200);
                    // Re-enable controls on error
                    document.getElementById('placeBetBtn').disabled = false;
                    document.getElementById('placeBetBtn').textContent = ' Place Bet';
                    document.querySelectorAll('.multiplier-btn').forEach(btn => {
                        btn.disabled = false;
                        btn.title = '';
                    });
                    document.getElementById('betSlider').disabled = false;
                    document.getElementById('betSlider').title = '';
                }
            }

            // Dismiss onboarding tooltip/glow if active
            dismissOnboarding();
            resetIdleTimer(); // Reset idle timer on spin
            // Auto demo is stopped when placeBet is called
        }

         // Function to handle the result of the spin (client-side for animation, backend for actual logic)
         function handleSpinResult() {
             // This function is now mainly for frontend animation and display.
             // The actual win/loss logic and balance updates are handled by the `socket.on('spinResult')` listener.

             // Add outcome to recent spins (this is also done on socket.on('spinResult'))
             // We'll keep this here for the immediate visual feedback of the spin animation.
             recentSpins.unshift({ multiplier: lastSpinResult, won: false }); // Assume false for now, backend will correct
             if (recentSpins.length > 10) {
                 recentSpins.pop();
             }
             localStorage.setItem('solroulette_recent_spins', JSON.stringify(recentSpins));
             updateRecentSpinsDisplay();

             // Show demo mode toast after each spin in guest mode
             if (isGuestMode) {
                 showGuestModeToast();
                 if (walletBalance < 0.01 && !document.getElementById('refillFakeSolModal').classList.contains('visible')) {
                     openRefillFakeSolModal();
                 }
             }

             // Reset user's current bet state and enable controls
             currentBet = { multiplier: null, amount: 0 };
             // The enabling/disabling of buttons is handled by socket.on('spinResult')
             // and updateUI, but ensure they are reset here for immediate visual feedback.
             document.getElementById('placeBetBtn').disabled = false;
             document.getElementById('placeBetBtn').textContent = ' Place Bet';
             document.querySelectorAll('.multiplier-btn').forEach(btn => {
                 btn.classList.remove('active');
                 btn.disabled = false;
                 btn.title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');
             });
             document.getElementById('betSlider').disabled = false;
             document.getElementById('betSlider').title = isGuestMode ? 'Using Demo SOL  Real rewards require a wallet' : (window.walletVerified ? '' : 'Connect Wallet to Bet');

             xp += 10; // Earn XP for completing a round
             checkAchievements();
             updateUIDebounced();

             // Save state to localStorage based on mode
             if (isGuestMode) {
                 localStorage.setItem('solroulette_guest_balance', walletBalance);
                 localStorage.setItem('solroulette_guest_xp', xp);
                 localStorage.setItem('solroulette_guest_total_wagered', totalWagered);
                 localStorage.setItem('solroulette_guest_win_streak', winStreak);
                 localStorage.setItem('solroulette_guest_ten_x_wins', tenXWins);
                 localStorage.setItem('solroulette_guest_achievements', JSON.stringify([...achievementsUnlocked]));
                 localStorage.setItem('solroulette_guest_spin_count', guestSpinCount);
                 localStorage.setItem('solroulette_fake_winnings_total', fakeWinningsTotal);
             } else {
                 // Real wallet data is synced via backend, but persist local copies for quick load
                 localStorage.setItem('solroulette_wallet_balance', walletBalance);
                 localStorage.setItem('solroulette_total_wagered', totalWagered);
                 localStorage.setItem('solroulette_xp', xp);
                 localStorage.setItem('solroulette_level', level);
                 localStorage.setItem('solroulette_win_streak', winStreak);
                 localStorage.setItem('solroulette_ten_x_wins', tenXWins);
                 localStorage.setItem('solroulette_achievements', JSON.stringify([...achievementsUnlocked]));
             }
             localStorage.setItem('solroulette_is_guest', isGuestMode);
             localStorage.setItem('solroulette_first_real_bet_placed', firstRealBetPlaced);
             localStorage.removeItem('solroulette_current_multiplier');
             localStorage.removeItem('solroulette_current_amount');

             // Check low balance after result (only in real wallet mode)
             if (!isGuestMode) {
                 checkLowBalance();
             } else {
                 document.getElementById('lowBalanceAlert').style.display = 'none';
             }

             // Restart auto demo after a short delay if it was active
             if (isAutoDemo) {
                 setTimeout(startAutoDemo, 3000);
             }
         }

         // Show Result Modal
         function showResultModal(pickedDisplay, landedDisplay, won, winAmount, lostAmount) {
             const modal = document.getElementById('resultModal');
             const title = document.getElementById('resultModalTitle');
             const message = document.getElementById('resultModalMessage');
             const spinAgainBtn = document.getElementById('resultModalSpinAgainBtn');

             title.classList.remove('win', 'lose');

             if (won) {
                 title.textContent = 'You Won!';
                 title.classList.add('win');
                 message.textContent = `You picked ${pickedDisplay}. Landed on ${landedDisplay}. You won ${winAmount.toFixed(2)}.`;
             } else {
                 title.textContent = 'You Lost!';
                 title.classList.add('lose');
                 message.textContent = `You picked ${pickedDisplay}. Landed on ${landedDisplay}. You lost ${lostAmount.toFixed(2)}.`;
             }

             modal.classList.add('visible');
             resetIdleTimer();
             stopAutoDemo();
         }

         function closeResultModal() {
              playSound('click');
              if (navigator.vibrate) navigator.vibrate(50);
              document.getElementById('resultModal').classList.remove('visible');
              resetIdleTimer();
         }

         // Refill Demo SOL Modal
         function openRefillFakeSolModal() {
             document.getElementById('refillFakeSolModal').classList.add('visible');
             resetIdleTimer();
             stopAutoDemo();
         }

         function closeRefillFakeSolModal() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             document.getElementById('refillFakeSolModal').classList.remove('visible');
             resetIdleTimer();
         }

         function refillFakeSol() {
             playSound('win');
             if (navigator.vibrate) navigator.vibrate([50, 50]);
             walletBalance = 500; // Reset demo balance
             localStorage.setItem('solroulette_guest_balance', walletBalance);
             showToast('info', 'Refilled!', 'Your demo SOL balance has been refilled.');
             updateUIDebounced();
             closeRefillFakeSolModal();
         }


        // Wheel Spin (Initiation)
        function spinWheel() {
            isSpinning = true;
            playSound('whoosh', 0.7);
            if (navigator.vibrate) navigator.vibrate([80]);

            const wheel = document.getElementById('rouletteCanvas');
            const pointer = document.getElementById('pointer');
            const container = document.getElementById('wheelContainer');

            // The actual winning multiplier will come from the backend via Socket.IO.
            // For client-side animation, we need a target. We'll use a placeholder for now.
            // In a real application, the backend would send the result *before* the animation starts,
            // and the frontend would animate to that specific result.
            // For this demo, we'll pick a random one for the animation, and the backend will provide the true result.
            const randomSegment = segments[Math.floor(Math.random() * segments.length)];
            lastSpinResult = randomSegment.multiplier; // Store for animation target

            isNearMiss = Math.random() < 0.2 && parseFloat(lastSpinResult.replace('x', '')) !== 10;

            targetRotation = calculateCanvasTargetRotation(lastSpinResult);

            spinStartTime = null;
            spinAnimationId = requestAnimationFrame(animateWheel);

            container.classList.add('bounce');
            pointer.classList.add('vibrate');

            setTimeout(() => {
                 container.classList.remove('bounce');
                 pointer.classList.remove('vibrate');
                 playSound('clank');
            }, spinDuration);

            const event = new Event('spinstart');
            document.getElementById('rouletteCanvas').dispatchEvent(event);
        }


        // Achievements
        function checkAchievements() {
            const achievements = [
                { name: 'First Bust', condition: winStreak === 0 && totalWagered > 0, icon: '' },
                { name: 'Hit 10x', condition: tenXWins >= 1, icon: '' },
                { name: '10 Spins', condition: guestSpinCount >= 10, icon: '' }, // Use guestSpinCount for this
                { name: 'High Roller', condition: totalWagered >= 50, icon: '' },
                 { name: 'Lucky Streak x3', condition: winStreak >= 3, icon: '' },
                 { name: 'Chatty', condition: xp >= 50, icon: '' }, // XP from chatting
                 { name: 'Daily Grinder', condition: dailyBonusDay >= 5, icon: '' } // Based on daily logins
            ];

            achievements.forEach(ach => {
                // Check if condition is met AND achievement is not already unlocked
                if (ach.condition && !achievementsUnlocked.has(ach.name)) {
                    unlockAchievement(ach.name, ach.icon);
                }
            });
             localStorage.setItem('solroulette_achievements', JSON.stringify([...achievementsUnlocked]));
        }

        function unlockAchievement(name, icon) {
            achievementsUnlocked.add(name);
            const container = document.getElementById('achievementContainer');
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="badge-icon">${icon}</div>
                <div>
                    <div style="font-weight: bold;">Achievement Unlocked!</div>
                    <div>${name}</div>
                </div>
            `;
            container.appendChild(popup);
            setTimeout(() => popup.remove(), 4000); // Popup disappears after 4 seconds
             localStorage.setItem('solroulette_achievements', JSON.stringify([...achievementsUnlocked])); // Save updated achievements
        }

        // Flash Screen
        function showFlash(type) {
            const flash = document.getElementById('flashScreen');
            flash.className = `flash-screen ${type}`;
            setTimeout(() => flash.className = 'flash-screen', 100); // Flash duration
        }

         // Confetti Effect
         function showConfetti() {
            const confettiColors = ['var(--primary)', 'var(--accent)', 'var(--success)', 'var(--danger)'];
            // Adjust confetti count based on screen width
            const confettiCount = window.innerWidth < 768 ? 50 : 100; // Fewer confetti on mobile
            const confettiShapes = ['square', 'circle', 'triangle', 'star']; // Variable shapes

            for (let i = 0; i < confettiCount; i++) {
                 const confetti = document.createElement('div');
                 const shape = confettiShapes[Math.floor(Math.random() * confettiShapes.length)];
                 confetti.className = `confetti ${shape}`; // Add shape class for styling
                 confetti.style.left = `${Math.random() * 100}vw`; // Random horizontal position
                 confetti.style.top = `${Math.random() * -20}vh`; // Start above viewport
                 // Adjust size based on screen width
                 const size = window.innerWidth < 768 ? Math.random() * 8 + 3 : Math.random() * 10 + 5;
                 confetti.style.width = `${size}px`; // Variable size
                 confetti.style.height = confetti.style.width; // Keep it square/circle initially
                 confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                 confetti.style.animationDelay = `${Math.random() * 1}s`; // Random delay
                 confetti.style.animationDuration = `${Math.random() * 2 + 1.5}s`; // Variable duration
                 document.body.appendChild(confetti);
                 // Remove confetti after animation
                 confetti.addEventListener('animationend', () => confetti.remove());
             }
         }

        // Share Modal
        function showShareModal(winnings, multiplier) {
             playSound('win_10x'); // Play a sound when share modal appears (celebration)
             if (navigator.vibrate) navigator.vibrate([50, 50]);

            document.getElementById('shareTitle').textContent = 'Big Win!';
            document.getElementById('shareMessage').textContent = `Just won ${winnings.toFixed(2)} on the ${multiplier} multiplier! Share your victory!`;
            const shareText = `Just won ${winnings.toFixed(2)} on ${multiplier} at SolRoulette LIVE! Spin now: ${user.referral} #SolRoulette #Solana #Crypto`;
            document.getElementById('shareText').value = shareText;
            document.getElementById('shareModal').style.display = 'flex'; // Use flex to center
            document.getElementById('shareModal').classList.add('visible');
        }

        function copyShareText() {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);
            const shareText = document.getElementById('shareText');
            shareText.select();
            shareText.setSelectionRange(0, 99999); // For mobile devices
            try {
                document.execCommand('copy');
                showToast('info', 'Copied!', 'Share link copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showToast('error', 'Copy Failed', 'Failed to copy link. Please copy manually.');
            }
        }

         function tweetWin() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             const shareText = document.getElementById('shareText').value;
             const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
             window.open(twitterUrl, '_blank');
             closeShareModal();
         }

        function closeShareModal() {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);
            document.getElementById('shareModal').classList.remove('visible');
            document.getElementById('shareModal').style.display = 'none'; // Hide completely
        }

         // Message Box (Custom Alert)
         function showMessageBox(title, message, callback = null) { // Added callback parameter
             document.getElementById('messageBoxTitle').textContent = title;
             document.getElementById('messageBoxContent').textContent = message;
             const msgBox = document.getElementById('messageBox');
             msgBox.classList.add('visible');

             // Handle the OK button click for the message box
             const okBtn = msgBox.querySelector('#messageBoxOkBtn'); // Use the new ID
             // Remove any existing event listener to prevent multiple calls
             const clonedOkBtn = okBtn.cloneNode(true);
             okBtn.parentNode.replaceChild(clonedOkBtn, okBtn);

             clonedOkBtn.addEventListener('click', () => {
                 closeMessageBox();
                 if (callback && typeof callback === 'function') {
                     callback(); // Execute the callback if provided
                 }
             });

             resetIdleTimer(); // Reset idle timer on modal open
             stopAutoDemo(); // Stop auto demo on modal open
         }

         function closeMessageBox() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             document.getElementById('messageBox').classList.remove('visible');
             resetIdleTimer(); // Reset idle timer on modal close
         }

         // Toast Notification System
         function showToast(type, title, message) {
            const toastContainer = document.createElement('div');
            toastContainer.className = `toast-container toast-${type}`;
            toastContainer.innerHTML = `
                <div class="toast-header">
                    <strong class="me-auto">${title}</strong>
                    <button type="button" class="btn-close" aria-label="Close toast"></button>
                </div>
                <div class="toast-body">${message}</div>
            `;
            document.body.appendChild(toastContainer);

            // Basic styling for toast (can be moved to CSS)
            toastContainer.style.position = 'fixed';
            toastContainer.style.bottom = '20px';
            toastContainer.style.left = '50%';
            toastContainer.style.transform = 'translateX(-50%)';
            toastContainer.style.padding = '10px 15px';
            toastContainer.style.borderRadius = '8px';
            toastContainer.style.zIndex = '1000';
            toastContainer.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
            toastContainer.style.opacity = '0';
            toastContainer.style.transition = 'opacity 0.3s ease-in-out';
            toastContainer.style.color = '#fff';

            if (type === 'success') toastContainer.style.backgroundColor = 'rgba(20, 241, 149, 0.9)';
            if (type === 'error') toastContainer.style.backgroundColor = 'rgba(255, 55, 95, 0.9)';
            if (type === 'info') toastContainer.style.backgroundColor = 'rgba(153, 69, 255, 0.9)';
            if (type === 'warning') toastContainer.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';

            setTimeout(() => {
                toastContainer.style.opacity = '1';
            }, 100);

            const closeBtn = toastContainer.querySelector('.btn-close');
            closeBtn.addEventListener('click', () => {
                toastContainer.style.opacity = '0';
                setTimeout(() => toastContainer.remove(), 300);
            });

            setTimeout(() => {
                toastContainer.style.opacity = '0';
                setTimeout(() => toastContainer.remove(), 300);
            }, 5000); // Auto-hide after 5 seconds
        }


         // Profile Modal
         function openProfileModal() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             updateProfileModal(); // Update content before showing
             document.getElementById('profileModal').classList.add('visible');
             resetIdleTimer(); // Reset idle timer on modal open
             stopAutoDemo(); // Stop auto demo on modal open
         }

         function closeProfileModal() {
             playSound('click');
             if (navigator.vibrate) navigator.vibrate(50);
             document.getElementById('profileModal').classList.remove('visible');
             resetIdleTimer(); // Reset idle timer on modal close
             // Restart auto demo if it was active before opening the modal (optional, depends on desired flow)
             // if (wasAutoDemoActive) startAutoDemo();
         }

         function updateProfileModal() {
             document.getElementById('profileAvatar').textContent = user.avatar;
             document.getElementById('profileName').textContent = user.name + (isGuestMode ? ' (Guest)' : ''); // Label guest mode
             document.getElementById('profileLevel').textContent = level;
             document.getElementById('profileXpFill').style.width = `${(xp % 100)}%`;
             document.getElementById('profileWallet').textContent = user.publicKey ? user.publicKey.slice(0, 6) + '...' + user.publicKey.slice(-6) : 'Not Connected';
             document.getElementById('profileBalance').textContent = walletBalance.toFixed(2) + ' SOL' + (isGuestMode ? ' (Demo)' : ''); // Label demo balance
             document.getElementById('profileTotalWagered').textContent = totalWagered.toFixed(2) + ' SOL' + (isGuestMode ? ' (Demo)' : ''); // Label demo stats
             document.getElementById('profileWinStreak').textContent = winStreak + (isGuestMode ? ' (Demo)' : '');
             document.getElementById('profileTenXWins').textContent = tenXWins + (isGuestMode ? ' (Demo)' : '');

             // Show demo winnings only in guest mode
             const fakeWinningsElement = document.getElementById('profileFakeWinnings');
             const fakeWinningsTotalElement = document.getElementById('fakeWinningsTotal');
             if (isGuestMode) {
                 fakeWinningsElement.style.display = 'block';
                 fakeWinningsTotalElement.textContent = fakeWinningsTotal.toFixed(2);
             } else {
                 fakeWinningsElement.style.display = 'none';
             }

             // Show/Hide Guest Reset Button
             const resetGuestBtn = document.getElementById('resetGuestProgressBtn');
             if (isGuestMode) {
                 resetGuestBtn.style.display = 'block';
             } else {
                 resetGuestBtn.style.display = 'none';
             }

             // Profile Editing (Username + Avatar)
             const usernameInput = document.getElementById('usernameInput');
             usernameInput.value = user.name === 'Guest' ? '' : user.name; // Clear input if guest

             // Update achievements grid
             const achievementsGrid = document.getElementById('profileAchievementsGrid');
             achievementsGrid.innerHTML = ''; // Clear existing
             const allAchievements = [
                 { name: 'First Bust', condition: winStreak === 0 && totalWagered > 0, icon: '' },
                 { name: 'Hit 10x', condition: tenXWins >= 1, icon: '' },
                 { name: '10 Spins', condition: guestSpinCount >= 10, icon: '' }, // Use guestSpinCount for this
                 { name: 'High Roller', condition: totalWagered >= 50, icon: '' },
                 { name: 'Lucky Streak x3', condition: winStreak >= 3, icon: '' },
                 { name: 'Chatty', condition: xp >= 50, icon: '' }, // XP from chatting
                 { name: 'Daily Grinder', condition: dailyBonusDay >= 5, icon: '' } // Based on daily logins
            ];

            allAchievements.forEach(ach => {
                const badge = document.createElement('div');
                badge.className = 'badge-icon'; // Reuse badge-icon style
                if (achievementsUnlocked.has(ach.name)) {
                    badge.textContent = ach.icon;
                    badge.title = ach.name; // Tooltip for unlocked achievements
                } else {
                    badge.textContent = '?'; // Placeholder for locked achievements
                    badge.style.opacity = 0.5;
                    badge.title = 'Locked';
                }
                achievementsGrid.appendChild(badge);
            });
        }

        function copyReferralLink() {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);
            const referralInput = document.getElementById('referralLinkInput');
            referralInput.select();
            referralInput.setSelectionRange(0, 99999); // For mobile devices
            try {
                // Use document.execCommand('copy') for clipboard operations due to iframe restrictions
                document.execCommand('copy');
                showToast('info', 'Copied!', 'Referral link copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy referral link: ', err);
                showToast('error', 'Copy Failed', 'Failed to copy referral link. Please copy manually.');
            }
        }

        function generateReferralCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            const referralLink = `https://solroulette.live?ref=${code}`;
            localStorage.setItem('solroulette_referral_code', referralLink);
            return referralLink;
        }

        // Check for referral code in URL on load
        function checkReferralCode() {
            const urlParams = new URLSearchParams(window.location.search);
            const ref = urlParams.get('ref');
            if (ref) {
                localStorage.setItem('solroulette_referred_by', ref);
                console.log(`Referred by: ${ref}`); // Log for tracking
                // You might want to award the referrer here in a real app
            }
        }

        // Reset Guest Progress
        function resetGuestProgress() {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);
            // Use a custom message box for confirmation instead of alert/confirm
            showMessageBox('Confirm Reset', 'Are you sure you want to reset your demo progress? This cannot be undone.', () => {
                // Clear only guest-specific localStorage items
                localStorage.removeItem('solroulette_is_guest');
                localStorage.removeItem('solroulette_guest_balance');
                localStorage.removeItem('solroulette_guest_xp');
                localStorage.removeItem('solroulette_guest_total_wagered');
                localStorage.removeItem('solroulette_guest_win_streak');
                localStorage.removeItem('solroulette_guest_ten_x_wins');
                localStorage.removeItem('solroulette_guest_achievements');
                localStorage.removeItem('solroulette_guest_spin_count');
                localStorage.removeItem('solroulette_guest_last_login');
                localStorage.removeItem('solroulette_guest_daily_bonus_day');
                localStorage.removeItem('solroulette_fake_winnings_total');
                localStorage.removeItem('solroulette_fake_intro_shown'); // Reset onboarding flag too
                localStorage.removeItem('solroulette_guest_modal_shown'); // Reset enjoyment modal flag
                localStorage.removeItem('solroulette_onboarding_shown'); // Reset onboarding tooltip flag
                localStorage.removeItem('solroulette_first_real_bet_placed'); // Reset real bet flag
                localStorage.removeItem('solroulette_current_multiplier'); // Clear current bet state
                localStorage.removeItem('solroulette_current_amount');
                localStorage.removeItem('solroulette_last_spin_result'); // Clear last spin result

                location.reload(); // Reload the page to restart in fresh guest mode
            });
        }

        // Profile Editing (Username + Avatar) - Save Username
        document.getElementById("saveUsernameBtn").addEventListener("click", async () => {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);

            const usernameInput = document.getElementById("usernameInput");
            const username = usernameInput.value.trim();

            if (username.length < 3) {
                showMessageBox("Invalid Username", "Must be at least 3 characters.");
                return;
            }

            if (!window.walletVerified || !user.publicKey) {
                showMessageBox("Wallet Not Verified", "Please connect and verify your wallet to set a username.");
                return;
            }

            showToast('info', 'Updating Username', 'Saving username...');
            try {
                const token = localStorage.getItem('jwt_token');
                if (!token) {
                    throw new Error('No authentication token found.');
                }
                const response = await fetch("http://localhost:3000/api/profile/update-username", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${token}`
                    },
                    body: JSON.stringify({ username })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to update username on server.');
                }

                const updatedUser = await response.json();
                user.name = updatedUser.username;
                localStorage.setItem('solroulette_user_name', updatedUser.username); // Update local storage
                showToast('success', 'Username Saved', `Your username has been set to ${updatedUser.username}.`);
                updateUIDebounced(); // Update UI to reflect new username
                closeProfileModal(); // Close profile modal after saving

                // Emit update to other clients (e.g., chat, leaderboard)
                socket.emit('profileUpdate', { username: updatedUser.username, avatar: user.avatar, publicKey: user.publicKey });

            } catch (error) {
                console.error("Error saving username:", error);
                showToast('error', 'Save Failed', `Failed to save username. ${error.message}`);
            }
        });


        // Daily Login Bonus (Modified to only give SOL)
        function checkDailyBonus() {
            const today = new Date().toDateString();
            const lastBonusDate = localStorage.getItem(isGuestMode ? 'solroulette_guest_last_login' : 'solroulette_last_login');

            if (lastBonusDate !== today) {
                dailyBonusDay++;
                localStorage.setItem(isGuestMode ? 'solroulette_guest_last_login' : 'solroulette_last_login', today);
                localStorage.setItem(isGuestMode ? 'solroulette_guest_daily_bonus_day' : 'solroulette_daily_bonus_day', dailyBonusDay);

                const bonusAmount = isGuestMode ? 25 : (dailyBonusDay === 7 ? 0.1 : 0.01); // 25 demo SOL for guests, 0.1 SOL for day 7, otherwise 0.01 SOL
                const bonusCurrency = 'SOL'; // Always SOL now

                showMessageBox('Daily Bonus!', `You received ${bonusAmount.toFixed(2)} ${bonusCurrency} for Day ${dailyBonusDay}!`, () => {
                    claimDailyBonus(bonusAmount);
                });
            }
        }

        // Simplified claimDailyBonus to be called directly from checkDailyBonus's message box callback
        async function claimDailyBonus(bonusAmount) {
            playSound('win');
            if (navigator.vibrate) navigator.vibrate([50, 50]);

            if (isGuestMode) {
                walletBalance += bonusAmount;
                localStorage.setItem('solroulette_guest_balance', walletBalance);
            } else {
                // Send request to backend to credit real SOL bonus
                try {
                    const token = localStorage.getItem('jwt_token');
                    if (!token) throw new Error('Not authenticated.');

                    const response = await fetch('http://localhost:3000/api/claim-daily-bonus', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ amount: bonusAmount, day: dailyBonusDay })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || 'Failed to claim daily bonus.');
                    }

                    const updatedUser = await response.json();
                    walletBalance = updatedUser.solBalance; // Update local balance from backend
                    localStorage.setItem('solroulette_wallet_balance', walletBalance);
                    showToast('success', 'Bonus Claimed!', `Claimed ${bonusAmount.toFixed(2)} SOL!`);

                } catch (error) {
                    console.error('Error claiming daily bonus:', error);
                    showToast('error', 'Bonus Failed', `Failed to claim bonus. ${error.message}`);
                }
            }

            // Reset daily bonus day after claiming day 7
            if (dailyBonusDay === 7) {
                dailyBonusDay = 0;
                localStorage.setItem(isGuestMode ? 'solroulette_guest_daily_bonus_day' : 'solroulette_daily_bonus_day', dailyBonusDay);
            }

            checkAchievements(); // Check if daily grinder achievement is unlocked
            updateUIDebounced();
        }


        // Leaderboard (Mock Data with Tabs) - Now updated by real-time data from backend
        let leaderboardScrollTimer = null;
        const LEADERBOARD_SCROLL_INTERVAL = 5000; // Scroll every 5 seconds

        function updateLeaderboard(backendData = null) {
            const leaderboardContent = document.getElementById('leaderboardContent');

            let currentLeaderboardData;
            if (backendData) {
                currentLeaderboardData = backendData;
            } else {
                // Fallback to mock data if no backend data (e.g., during initial load or disconnected)
                currentLeaderboardData = {
                    wager: [
                        { username: user.name, totalWagered: (isGuestMode ? totalWagered : totalWagered).toFixed(2), avatar: user.avatar, publicKey: user.publicKey },
                        { username: 'WhaleShark', totalWagered: '5000', avatar: '', publicKey: 'mock1' },
                        { username: 'GambaKing', totalWagered: '3000', avatar: '', publicKey: 'mock2' },
                        { username: 'SolDegen', totalWagered: '1500', avatar: '', publicKey: 'mock3' },
                        { username: 'CryptoChad', totalWagered: '1000', avatar: '', publicKey: 'mock4' },
                        { username: 'DiamondHands', totalWagered: '800', avatar: '', publicKey: 'mock5' },
                        { username: 'PaperHands', totalWagered: '500', avatar: '', publicKey: 'mock6' }
                    ].sort((a, b) => parseFloat(b.totalWagered) - parseFloat(a.totalWagered)),
                    streak: [
                        { username: user.name, winStreak: winStreak, avatar: user.avatar, publicKey: user.publicKey },
                        { username: 'LuckyLuke', winStreak: 15, avatar: '', publicKey: 'mock7' },
                        { username: 'StreakMaster', winStreak: 10, avatar: '', publicKey: 'mock8' },
                        { username: 'WinGod', winStreak: 8, avatar: '', publicKey: 'mock9' },
                        { username: 'HotHand', winStreak: 6, avatar: '', publicKey: 'mock10' },
                        { username: 'Consistent', winStreak: 5, avatar: '', publicKey: 'mock11' },
                        { username: 'NeverLose', winStreak: 4, avatar: '', publicKey: 'mock12' }
                    ].sort((a, b) => b.winStreak - a.winStreak),
                    '10x': [
                        { username: user.name, tenXWins: tenXWins, avatar: user.avatar, publicKey: user.publicKey },
                        { username: 'TenXHunter', tenXWins: 25, avatar: '', publicKey: 'mock13' },
                        { username: 'JackpotJoe', tenXWins: 18, avatar: '', publicKey: 'mock14' },
                        { username: 'BigWinner', tenXWins: 12, avatar: '', publicKey: 'mock15' },
                        { username: 'MoonApe', tenXWins: 9, avatar: '', publicKey: 'mock16' },
                        { username: 'StarChaser', tenXWins: 7, avatar: '', publicKey: 'mock17' },
                        { username: 'Legend', tenXWins: 5, avatar: '', publicKey: 'mock18' }
                    ].sort((a, b) => b.tenXWins - a.tenXWins)
                };
            }

            Object.keys(currentLeaderboardData).forEach(tabId => {
                const tabContentDiv = leaderboardContent.querySelector(`.leaderboard-content-tab[data-tab="${tabId}"]`);
                if (tabContentDiv) {
                    tabContentDiv.innerHTML = ''; // Clear existing content
                    currentLeaderboardData[tabId].forEach(entry => {
                        const entryDiv = document.createElement('div');
                        entryDiv.className = 'leaderboard-entry';
                        let valueDisplay = '';
                        if (tabId === 'wager') {
                            valueDisplay = `${parseFloat(entry.totalWagered).toFixed(2)}`;
                        } else if (tabId === 'streak') {
                            valueDisplay = entry.winStreak;
                        } else if (tabId === '10x') {
                            valueDisplay = entry.tenXWins;
                        }

                        entryDiv.innerHTML = `
                            <span class="user">
                                ${entry.avatar} ${entry.username}:
                            </span>
                            <span class="value">${valueDisplay}</span>
                        `;
                        tabContentDiv.appendChild(entryDiv);
                    });
                }
            });

            const activeTabContent = leaderboardContent.querySelector('.leaderboard-content-tab.active');
            if (activeTabContent && activeTabContent.children.length > 5) {
                startLeaderboardScroll();
            } else {
                stopLeaderboardScroll();
            }
        }

        function startLeaderboardScroll() {
            if (leaderboardScrollTimer === null) {
                const leaderboardPanel = document.getElementById('leaderboardPanel');
                leaderboardScrollTimer = setInterval(() => {
                    leaderboardPanel.scrollBy({ top: 20, behavior: 'smooth' });
                    if (leaderboardPanel.scrollTop + leaderboardPanel.clientHeight >= leaderboardPanel.scrollHeight) {
                        leaderboardPanel.scrollTo({ top: 0, behavior: 'smooth' });
                    }
                }, LEADERBOARD_SCROLL_INTERVAL / 5);
            }
        }

        function stopLeaderboardScroll() {
            clearInterval(leaderboardScrollTimer);
            leaderboardScrollTimer = null;
        }


        // Leaderboard Tab Switching
        document.querySelectorAll('.leaderboard-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const targetTab = tab.dataset.tab;
                document.querySelectorAll('.leaderboard-content-tab').forEach(content => {
                    content.classList.remove('active');
                    if (content.dataset.tab === targetTab) {
                        content.classList.add('active');
                    }
                });
                updateLeaderboard(); // Update leaderboard content and restart scroll
            });
        });

        // Low Balance Alert
        function checkLowBalance() {
            if (!isGuestMode && window.walletVerified && window.userSolBalance < 0.5) { // Only show in real wallet mode and if verified
                document.getElementById('lowBalanceAlert').style.display = 'block';
            } else {
                document.getElementById('lowBalanceAlert').style.display = 'none';
            }
        }

        async function topUpWallet() {
            playSound('click');
            if (navigator.vibrate) navigator.vibrate(50);
            // Mock Top Up - In a real app, this would initiate a deposit flow.
            // For now, we'll simulate a backend call to add funds.
            showToast('info', 'Mock Top Up', 'Requesting mock SOL top-up...');
            try {
                const token = localStorage.getItem('jwt_token');
                if (!token) throw new Error('Not authenticated.');

                const response = await fetch('http://localhost:3000/api/mock-top-up', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ amount: 5 }) // Mock adding 5 SOL
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to process mock top-up.');
                }

                const updatedUser = await response.json();
                walletBalance = updatedUser.solBalance; // Update local balance from backend
                localStorage.setItem('solroulette_wallet_balance', walletBalance);
                showToast('success', 'Mock Top Up', `5 SOL added to your balance!`);
                updateUIDebounced();
                checkLowBalance();
            } catch (error) {
                console.error('Error during mock top-up:', error);
                showToast('error', 'Top Up Failed', `Failed to top up. ${error.message}`);
            }
        }

        // Show Demo Mode Toast
        function showGuestModeToast() {
            const toast = document.getElementById('guestModeToast');
            toast.style.display = 'block';
            setTimeout(() => {
                toast.style.display = 'none';
            }, 5000); // Hide after 5 seconds
        }

        // Onboarding Modal for Guest Mode
        function showOnboardingModal() {
            showMessageBox(' Welcome to SolRoulette LIVE!', 'Heres 500 in Demo SOL to try your luck. Connect your wallet any time to win real rewards.', () => {
                localStorage.setItem('solroulette_fake_intro_shown', 'true');
                isGuestMode = true; // Explicitly set guest mode
                localStorage.setItem('solroulette_is_guest', 'true');
                walletBalance = 500; // Set initial demo balance immediately
                localStorage.setItem('solroulette_guest_balance', walletBalance);

                // Initialize other guest stats if they don't exist
                if (localStorage.getItem('solroulette_guest_xp') === null) localStorage.setItem('solroulette_guest_xp', '0');
                if (localStorage.getItem('solroulette_guest_total_wagered') === null) localStorage.setItem('solroulette_guest_total_wagered', '0');
                if (localStorage.getItem('solroulette_guest_win_streak') === null) localStorage.setItem('solroulette_guest_win_streak', '0');
                if (localStorage.getItem('solroulette_guest_ten_x_wins') === null) localStorage.setItem('solroulette_guest_ten_x_wins', '0');
                if (localStorage.getItem('solroulette_guest_achievements') === null) localStorage.setItem('solroulette_guest_achievements', '[]');
                if (localStorage.getItem('solroulette_guest_spin_count') === null) localStorage.setItem('solroulette_guest_spin_count', '0');
                if (localStorage.getItem('solroulette_guest_last_login') === null) localStorage.setItem('solroulette_guest_last_login', new Date().toDateString()); // Initialize guest login date
                if (localStorage.getItem('solroulette_guest_daily_bonus_day') === null) localStorage.setItem('solroulette_guest_daily_bonus_day', '0');
                if (localStorage.getItem('solroulette_fake_winnings_total') === null) localStorage.setItem('solroulette_fake_winnings_total', '0');

                // Load guest stats after setting them
                xp = parseInt(localStorage.getItem('solroulette_guest_xp'));
                totalWagered = parseFloat(localStorage.getItem('solroulette_total_wagered'));
                winStreak = parseInt(localStorage.getItem('solroulette_win_streak'));
                tenXWins = parseInt(localStorage.getItem('solroulette_ten_x_wins'));
                achievementsUnlocked = new Set(JSON.parse(localStorage.getItem('solroulette_achievements')));
                guestSpinCount = parseInt(localStorage.getItem('solroulette_guest_spin_count'));
                dailyBonusDay = parseInt(localStorage.getItem('solroulette_guest_daily_bonus_day'));
                fakeWinningsTotal = parseFloat(localStorage.getItem('solroulette_fake_winnings_total'));

                user.name = 'Guest'; // Ensure name is Guest
                user.avatar = ''; // Ensure avatar is Guest avatar
                localStorage.setItem('solroulette_user_name', user.name);
                localStorage.setItem('solroulette_user_avatar', user.avatar);

                updateUIDebounced(); // Update UI to show the new balance and guest state
                showToast('info', 'Demo SOL Added', '500 Demo SOL added. Start spinning!'); // Show toast
                showOnboardingTooltip(); // Show the onboarding tooltip after message box
                resetIdleTimer(); // Start idle timer after onboarding
            });
        }

        // Onboarding Tooltip
        function showOnboardingTooltip() {
            if (!onboardingShown && isGuestMode) {
                const tooltip = document.getElementById('onboardingTooltip');
                const multiplierOptions = document.getElementById('multiplierOptions');

                // Add glow to multiplier options
                multiplierOptions.classList.add('onboarding-glow');

                // Show tooltip
                tooltip.classList.add('visible');

                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    dismissOnboarding();
                }, 10000);
            }
        }

        function dismissOnboarding() {
            const tooltip = document.getElementById('onboardingTooltip');
            const multiplierOptions = document.getElementById('multiplierOptions');

            // Remove glow and hide tooltip
            multiplierOptions.classList.remove('onboarding-glow');
            tooltip.classList.remove('visible');

            // Mark onboarding as shown
            onboardingShown = true;
            localStorage.setItem('solroulette_onboarding_shown', 'true');
        }


        // Update Recent Spins Display
        function updateRecentSpinsDisplay() {
            const recentSpinsDiv = document.getElementById('recentSpins');
            recentSpinsDiv.innerHTML = '<span class="label">Recent:</span>'; // Reset content

            recentSpins.forEach(spin => {
                const outcomeSpan = document.createElement('span');
                // Determine color class based on the multiplier value
                const multiplierValue = parseFloat(spin.multiplier.replace('x', ''));
                let colorClass = 'lose'; // Default to lose (danger color)
                if (multiplierValue === 1.5 || multiplierValue === 5) {
                    colorClass = 'success'; // Use 'success' class for 1.5x and 5x
                } else if (multiplierValue === 2) {
                    colorClass = 'primary'; // Use 'primary' color for 2x
                } else if (multiplierValue === 3) {
                    colorClass = 'accent'; // Use 'accent' color for 3x
                } else if (multiplierValue === 10) {
                     colorClass = 'danger'; // Use 'danger' color for 10x
                }
                outcomeSpan.className = `outcome ${colorClass}`;
                outcomeSpan.textContent = spin.multiplier; // Display with 'x'
                recentSpinsDiv.appendChild(outcomeSpan);
            });
        }

        // Update Bet Summary Display
        function updateBetSummary() {
            const betSummaryDiv = document.getElementById('betSummary');
            // Check if multiplier is set (numeric string)
            if (currentBet.multiplier !== null && currentBet.amount > 0) {
                const potentialWin = currentBet.amount * parseFloat(currentBet.multiplier); // Use numeric value
                betSummaryDiv.innerHTML = `
                     You bet ${currentBet.amount.toFixed(2)} on ${currentBet.multiplier}x
                    <br>
                     Potential Win: ${potentialWin.toFixed(2)}
                `;
                betSummaryDiv.style.display = 'block';
            } else {
                betSummaryDiv.style.display = 'none';
            }
        }

        // Auto Demo Mode Functions
        function startAutoDemo() {
            // Only start auto demo if in guest mode, no real bet placed, not spinning, and no modal is open
            if (!isGuestMode || firstRealBetPlaced || isSpinning || document.querySelector('.modal-overlay.visible')) {
                isAutoDemo = false;
                document.getElementById('autoDemoBanner').style.display = 'none';
                return;
            }

            isAutoDemo = true;
            document.getElementById('autoDemoBanner').style.display = 'block';

            // Select a random multiplier (numeric string)
            const multipliers = ['1.5', '2', '3', '5', '10']; // Use numeric strings
            const randomMultiplier = multipliers[Math.floor(Math.random() * multipliers.length)];

            // Select the multiplier button in the UI (visual only)
            document.querySelectorAll('.multiplier-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.multiplier === randomMultiplier) { // Compare numeric strings
                    btn.classList.add('active');
                }
            });
            currentBet.multiplier = randomMultiplier; // Set the state (numeric string)

            // Set a random bet amount (e.g., between 0.1 and 2 SOL)
            const randomAmount = parseFloat((Math.random() * 1.9 + 0.1).toFixed(2));
            document.getElementById('betSlider').value = randomAmount; // Update slider
            currentBet.amount = randomAmount; // Set the state
            updateUIDebounced(); // Update UI to show selected bet

            // Place the bet after a short delay
            setTimeout(() => {
                // Double check state before placing bet in auto demo
                // Ensure timer is in betting window (last 3 seconds)
                const timerText = document.getElementById("globalTimer").textContent;
                const timerMatch = timerText.match(/(\d+)s/);
                const timer = timerMatch ? parseInt(timerMatch[1]) : 0;

                if (isAutoDemo && !isSpinning && timer <= 3 && timer > 0) { // Only place bet if within betting window
                    placeBet();
                } else {
                    // If conditions aren't met, try starting demo again later
                    autoDemoTimer = setTimeout(startAutoDemo, AUTO_DEMO_INTERVAL);
                }
            }, 1000); // Wait 1 second before attempting to place the bet in auto demo
        }

        function stopAutoDemo() {
            clearTimeout(autoDemoTimer);
            isAutoDemo = false;
            document.getElementById('autoDemoBanner').style.display = 'none';
            document.querySelectorAll('.multiplier-btn').forEach(btn => btn.classList.remove('active'));
            updateUIDebounced();
        }

        // Keyboard Detection for Mobile Sticky Bet Button
        let initialViewportHeight = window.innerHeight;
        let keyboardOpen = false;

        function checkKeyboard() {
            const currentViewportHeight = window.innerHeight;
            const heightDifference = initialViewportHeight - currentViewportHeight;
            const keyboardThreshold = 150;

            if (heightDifference > keyboardThreshold && !keyboardOpen) {
                keyboardOpen = true;
                document.body.classList.add('keyboard-open');
            } else if (heightDifference <= keyboardThreshold && keyboardOpen) {
                keyboardOpen = false;
                document.body.classList.remove('keyboard-open');
            }
        }

        window.addEventListener('resize', checkKeyboard);
        document.querySelectorAll('input[type="text"], input[type="number"], textarea').forEach(input => {
            input.addEventListener('focus', checkKeyboard);
            input.addEventListener('blur', checkKeyboard);
        });

        // Update UI elements
        function updateUI() {
            // Update XP bar and level
            const xpPercentage = (xp % 100);
            if (xp >= 100) {
                level++;
                xp -= 100;
                addChatMessage('System', `${user.name} leveled up to ${level}!`, '', 'system');
                // Backend will handle persistence, but update local state immediately
                localStorage.setItem('solroulette_level', level);
                localStorage.setItem('solroulette_xp', xp);
                if (xp >= 100) updateUIDebounced();
            }
            localStorage.setItem('solroulette_xp', xp);


            // Update the entire user profile block in the header
            document.getElementById('userProfile').innerHTML = `
                <div class="avatar" id="userAvatar">${user.avatar}</div>
                <div class="user-info">
                    <div id="userName">${user.name} ${isGuestMode ? '(Guest)' : ''} (Lv. ${level})</div>
                    <div class="xp-bar"><div class="xp-fill" id="xpFill" style="width: ${(xp % 100)}%"></div></div>
                </div>
                <div class="sol-balance-display"><i class="fas fa-wallet"></i> <span id="solBalance">${walletBalance.toFixed(2)}</span> SOL ${isGuestMode ? '(Demo)' : ''}</div>
                 <div id="fakeWinningsDisplay" class="fake-winnings-display" style="${isGuestMode ? 'display: block;' : 'display: none;'}" title="Your total demo winnings so far.">
                     <span id="fakeWinningsTotalDisplay">${fakeWinningsTotal.toFixed(2)}</span> (Demo)
                 </div>
                 <span class="verified-badge" id="verifiedBadge" title="Wallet Verified" style="${window.walletVerified ? 'display: inline-block;' : 'display: none;'}"">
                     <i class="fas fa-check-circle"></i>
                 </span>
            `;
             document.getElementById('userProfile').addEventListener('click', openProfileModal);


            // Update button states based on timer and wallet connection/guest mode
            const placeBetBtn = document.getElementById('placeBetBtn');
            const connectWalletBtn = document.getElementById('connectWalletBtn');
            const multiplierBtns = document.querySelectorAll('.multiplier-btn');
            const betSlider = document.getElementById('betSlider');
            const spinAgainBtn = document.getElementById('resultModalSpinAgainBtn');
            const guestModeBanner = document.getElementById('guestModeBanner');


            const timerText = document.getElementById("globalTimer").textContent;
            const timerMatch = timerText.match(/(\d+)s/);
            const timer = timerMatch ? parseInt(timerMatch[1]) : 0;
            const bettingAllowedByTimer = !isSpinning && timer <= 3 && timer > 0; // Betting only allowed in last 3 seconds
            const betIsValid = currentBet.multiplier !== null && currentBet.amount > 0;

            if (window.walletVerified) { // Connected with real wallet and verified
                 connectWalletBtn.style.display = 'none';
                 placeBetBtn.style.display = 'block';
                 guestModeBanner.style.display = 'none';

                 placeBetBtn.disabled = !bettingAllowedByTimer || !betIsValid;
                 placeBetBtn.title = bettingAllowedByTimer ? '' : 'Betting is closed';

                 multiplierBtns.forEach(btn => {
                     btn.disabled = !bettingAllowedByTimer;
                     btn.title = bettingAllowedByTimer ? '' : 'Betting is closed';
                 });
                 betSlider.disabled = !bettingAllowedByTimer;
                 betSlider.title = bettingAllowedByTimer ? '' : 'Betting is closed';

            } else { // Guest Mode or not connected/unverified
                 if (!user.publicKey) { // If no public key (not connected at all)
                     connectWalletBtn.style.display = 'block';
                 } else { // Connected but not verified, or in guest mode
                     connectWalletBtn.style.display = 'none';
                 }

                 placeBetBtn.style.display = 'block';
                 guestModeBanner.style.display = 'block';

                 placeBetBtn.disabled = !bettingAllowedByTimer || !betIsValid;
                 placeBetBtn.title = 'Demo SOL bets. Connect wallet to win real rewards.';

                 multiplierBtns.forEach(btn => {
                     btn.disabled = !bettingAllowedByTimer;
                     btn.title = bettingAllowedByTimer ? 'Using Demo SOL  Real rewards require a wallet' : 'Betting is closed';
                 });
                 betSlider.disabled = !bettingAllowedByTimer;
                 betSlider.title = bettingAllowedByTimer ? 'Using Demo SOL  Real rewards require a wallet' : 'Betting is closed';
            }

             spinAgainBtn.disabled = !bettingAllowedByTimer;

            multiplierBtns.forEach(btn => {
                btn.classList.remove('active');
                if (currentBet.multiplier !== null && btn.dataset.multiplier === currentBet.multiplier) {
                    btn.classList.add('active');
                }
            });

             if (!isGuestMode) {
                 checkLowBalance();
             } else {
                 document.getElementById('lowBalanceAlert').style.display = 'none';
             }

             updateBetSummary();
             document.getElementById('fakeWinningsTotalDisplay').textContent = fakeWinningsTotal.toFixed(2);
        }

        // Initial Canvas Setup
        function setupCanvas() {
            const container = document.getElementById('wheelContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawWheel(); // Initial draw
        }

        // Idle Timer Functions
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(showIdleModalOrAutoDemo, IDLE_TIMEOUT);

             if (isAutoDemo) {
                 stopAutoDemo();
             }
        }

        function showIdleModalOrAutoDemo() {
             const anyModalVisible = document.querySelector('.modal-overlay.visible');
             if (!anyModalVisible && isGuestMode && !firstRealBetPlaced) {
                 startAutoDemo();
             } else if (!anyModalVisible) {
                 showIdleModal();
             }
             resetIdleTimer();
        }

        function showIdleModal() {
            showMessageBox('Still here?', 'Try a spin and feel the rush ');
            resetIdleTimer();
        }

        // Event Listeners
        document.getElementById('betSlider').addEventListener('input', (e) => {
             currentBet.amount = parseFloat(e.target.value);
             localStorage.setItem('solroulette_current_amount', currentBet.amount);
             updateUIDebounced();
             dismissOnboarding();
             resetIdleTimer();
             stopAutoDemo();
        });

        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChat();
                e.preventDefault();
            }
        });

        document.querySelectorAll('.multiplier-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                 const timerText = document.getElementById("globalTimer").textContent;
                 const timerMatch = timerText.match(/(\d+)s/);
                 const timer = timerMatch ? parseInt(timerMatch[1]) : 0;

                 if (isSpinning || timer > 3) { // Cannot select during spin or if betting is closed
                     return;
                 }

                playSound('click');
                if (navigator.vibrate) navigator.vibrate(50);

                document.querySelectorAll('.multiplier-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentBet.multiplier = btn.dataset.multiplier;
                localStorage.setItem('solroulette_current_multiplier', currentBet.multiplier);

                updateUIDebounced();

                dismissOnboarding();
                resetIdleTimer();
                stopAutoDemo();
            });
        });

        document.getElementById('connectWalletBtn').addEventListener('click', openWalletModal);
        document.getElementById('placeBetBtn').addEventListener('click', placeBet);
        document.getElementById('closeWalletModalBtn').addEventListener('click', closeWalletModal);
        document.getElementById('justWatchingBtn').addEventListener('click', closeWalletModal);
        document.getElementById('closeProfileModalBtn').addEventListener('click', closeProfileModal);
        document.getElementById('copyReferralLinkBtn').addEventListener('click', copyReferralLink);
        document.getElementById('resetGuestProgressBtn').addEventListener('click', resetGuestProgress);
        document.getElementById('closeResultModalBtn').addEventListener('click', closeResultModal);
        document.getElementById('closeShareModalBtn').addEventListener('click', closeShareModal);
        document.getElementById('copyShareTextBtn').addEventListener('click', copyShareText);
        document.getElementById('tweetWinBtn').addEventListener('click', tweetWin);
        document.getElementById('messageBoxOkBtn').addEventListener('click', closeMessageBox);
        document.getElementById('topUpWalletBtn').addEventListener('click', topUpWallet);
        document.getElementById('resultModalSpinAgainBtn').addEventListener('click', closeResultModal);
        document.getElementById('refillFakeSolBtn').addEventListener('click', refillFakeSol); // Refill button for demo SOL
        document.getElementById('closeRefillFakeSolModalBtn').addEventListener('click', closeRefillFakeSolModal); // Close button for demo SOL refill modal


        // Live Panel Tab Switching Functionality
        const livePanelTabs = document.querySelectorAll('.live-panel-tab');
        const livePanelContents = document.querySelectorAll('.live-panel-content-tab');

        livePanelTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                livePanelTabs.forEach(t => t.classList.remove('active'));
                livePanelContents.forEach(c => c.classList.remove('active'));

                tab.classList.add('active');
                const targetTabId = tab.dataset.tab;
                const targetContent = document.getElementById(`live${targetTabId.charAt(0).toUpperCase() + targetTabId.slice(1)}Content`);

                if (targetContent) {
                    targetContent.classList.add('active');
                    if (targetTabId === 'chat') {
                         const chatFeed = document.getElementById('chatFeed');
                         chatFeed.scrollTop = chatFeed.scrollHeight;
                         document.getElementById('chatUnreadDot').style.display = 'none';
                    } else if (targetTabId === 'bets') {
                         document.getElementById('betsUnreadDot').style.display = 'none';
                    }
                    if (document.querySelector('.live-panel-tab.active')) {
                         document.getElementById('livePanelUnreadDot').style.display = 'none';
                    }
                }
                 resetIdleTimer();
                 stopAutoDemo();
            });
        });

        document.querySelector('.live-panel-tab[data-tab="bets"]').classList.add('active');
        document.getElementById('liveBetsContent').classList.add('active');


        // Add particle effects to the background overlay
        function createParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = `${Math.random() * 100}vw`;
            particle.style.top = `${Math.random() * 100}vh`;
            particle.style.animationDelay = `${Math.random() * 5}s`;
            document.getElementById('backgroundOverlay').appendChild(particle);
            particle.addEventListener('animationend', () => particle.remove());
        }

        function spawnParticles(count) {
            for (let i = 0; i < count; i++) {
                createParticle();
            }
        }

        // Add money rain effect on win
        function triggerMoneyRain() {
             const moneyCount = 50;
             for (let i = 0; i < moneyCount; i++) {
                 const money = document.createElement('div');
                 money.className = 'money-rain';
                 money.style.left = `${Math.random() * 100}vw`;
                 money.style.animationDelay = `${Math.random() * 0.5}s`;
                 document.body.appendChild(money);
                 money.addEventListener('animationend', () => money.remove());
             }
        }


        // Start Simulation
        // Frontend timer update is now driven by backend 'spinCountdown' event
        // setInterval(updateTimer, 1000); // This will be called by socket.on('spinCountdown')
        setInterval(simulateMultiplayer, 5000); // Simulate fake bets and chat every 5 seconds (only if not connected to backend)
        // Leaderboard updates are now driven by backend 'leaderboardUpdate' event
        // setInterval(updateLeaderboard, 15000); // This will be called by socket.on('leaderboardUpdate')
        setInterval(checkLowBalance, 30000); // Check low balance every 30 seconds
        setInterval(updateFakeActivityBanner, 7000); // Update fake activity banner periodically
        setInterval(() => {
            if (Math.random() < 0.3) {
                showTenXHitBanner();
            }
        }, Math.random() * 30000 + 30000);


        // Initial setup on page load
        window.onload = function() {
            setupCanvas();

            const fakeIntroShown = localStorage.getItem('solroulette_fake_intro_shown');

            if (!user.publicKey && !fakeIntroShown) { // No wallet connected and first time guest
                isGuestMode = true;
                localStorage.setItem('solroulette_is_guest', 'true');
                walletBalance = 500;
                localStorage.setItem('solroulette_guest_balance', walletBalance);

                if (localStorage.getItem('solroulette_guest_xp') === null) localStorage.setItem('solroulette_guest_xp', '0');
                if (localStorage.getItem('solroulette_guest_total_wagered') === null) localStorage.setItem('solroulette_guest_total_wagered', '0');
                if (localStorage.getItem('solroulette_guest_win_streak') === null) localStorage.setItem('solroulette_guest_win_streak', '0');
                if (localStorage.getItem('solroulette_guest_ten_x_wins') === null) localStorage.setItem('solroulette_guest_ten_x_wins', '0');
                if (localStorage.getItem('solroulette_guest_achievements') === null) localStorage.setItem('solroulette_guest_achievements', '[]');
                if (localStorage.getItem('solroulette_guest_spin_count') === null) localStorage.setItem('solroulette_guest_spin_count', '0');
                if (localStorage.getItem('solroulette_guest_last_login') === null) localStorage.setItem('solroulette_guest_last_login', new Date().toDateString());
                if (localStorage.getItem('solroulette_guest_daily_bonus_day') === null) localStorage.setItem('solroulette_guest_daily_bonus_day', '0');
                if (localStorage.getItem('solroulette_fake_winnings_total') === null) localStorage.setItem('solroulette_fake_winnings_total', '0');

                xp = parseInt(localStorage.getItem('solroulette_guest_xp'));
                totalWagered = parseFloat(localStorage.getItem('solroulette_total_wagered'));
                winStreak = parseInt(localStorage.getItem('solroulette_win_streak'));
                tenXWins = parseInt(localStorage.getItem('solroulette_ten_x_wins'));
                achievementsUnlocked = new Set(JSON.parse(localStorage.getItem('solroulette_achievements')));
                guestSpinCount = parseInt(localStorage.getItem('solroulette_guest_spin_count'));
                dailyBonusDay = parseInt(localStorage.getItem('solroulette_guest_daily_bonus_day'));
                fakeWinningsTotal = parseFloat(localStorage.getItem('solroulette_fake_winnings_total'));

                user.name = 'Guest';
                user.avatar = '';
                localStorage.setItem('solroulette_user_name', user.name);
                localStorage.setItem('solroulette_user_avatar', user.avatar);

                updateUIDebounced();
                showOnboardingModal();
            } else if (!user.publicKey && fakeIntroShown) { // Returning guest user
                isGuestMode = true;
                localStorage.setItem('solroulette_is_guest', 'true');
                walletBalance = parseFloat(localStorage.getItem('solroulette_guest_balance') || '500');
                if (walletBalance <= 0) {
                    walletBalance = 500;
                    localStorage.setItem('solroulette_guest_balance', walletBalance);
                }

                xp = parseInt(localStorage.getItem('solroulette_guest_xp') || '0');
                totalWagered = parseFloat(localStorage.getItem('solroulette_total_wagered') || '0');
                winStreak = parseInt(localStorage.getItem('solroulette_win_streak') || '0');
                tenXWins = parseInt(localStorage.getItem('solroulette_ten_x_wins') || '0');
                achievementsUnlocked = new Set(JSON.parse(localStorage.getItem('solroulette_achievements') || '[]'));
                guestSpinCount = parseInt(localStorage.getItem('solroulette_guest_spin_count') || '0');
                dailyBonusDay = parseInt(localStorage.getItem('solroulette_guest_daily_bonus_day') || '0');
                fakeWinningsTotal = parseFloat(localStorage.getItem('solroulette_fake_winnings_total') || '0');

                user.name = 'Guest';
                user.avatar = '';
                localStorage.setItem('solroulette_user_name', user.name);
                localStorage.setItem('solroulette_user_avatar', user.avatar);

                updateUIDebounced();
                showGuestModeToast();
                showOnboardingTooltip();
                resetIdleTimer();
            } else { // Wallet connected (from previous session or just connected)
                isGuestMode = false;
                localStorage.setItem('solroulette_is_guest', 'false');
                walletBalance = parseFloat(localStorage.getItem('solroulette_wallet_balance') || '0');
                xp = parseInt(localStorage.getItem('solroulette_xp') || '0');
                totalWagered = parseFloat(localStorage.getItem('solroulette_total_wagered') || '0');
                winStreak = parseInt(localStorage.getItem('solroulette_win_streak') || '0');
                tenXWins = parseInt(localStorage.getItem('solroulette_ten_x_wins') || '0');
                achievementsUnlocked = new Set(JSON.parse(localStorage.getItem('solroulette_achievements') || '[]'));
                dailyBonusDay = parseInt(localStorage.getItem('solroulette_daily_bonus_day') || '0');

                // If a JWT token exists, try to connect to Socket.IO and authenticate
                const token = localStorage.getItem('jwt_token');
                if (token) {
                    socket.connect(); // Connect Socket.IO
                } else {
                    // If no token, but publicKey exists (e.g., old local storage), reset and prompt wallet connect
                    user.publicKey = null;
                    localStorage.removeItem('solroulette_wallet');
                    openWalletModal();
                }

                updateUIDebounced();
                resetIdleTimer();
            }

            if (currentBet.multiplier !== null) {
                const defaultMultiplierBtn = document.querySelector(`.multiplier-btn[data-multiplier="${currentBet.multiplier}"]`);
                if (defaultMultiplierBtn) {
                    defaultMultiplierBtn.classList.add('active');
                }
            }
            if (currentBet.amount > 0) {
                document.getElementById('betSlider').value = currentBet.amount;
            }

            updateUIDebounced();

            spawnParticles(50);
            checkReferralCode();
            updateRecentSpinsDisplay();
            updateFakeActivityBanner();
            updateLeaderboard(); // Initial leaderboard population with mock data, will be updated by real-time data

            checkDailyBonus();

            if (isGuestMode && !firstRealBetPlaced) {
                autoDemoTimer = setTimeout(showIdleModalOrAutoDemo, IDLE_TIMEOUT);
            }
        };

        window.addEventListener('resize', setupCanvas);
        window.addEventListener('resize', checkKeyboard);

        document.addEventListener('mousemove', resetIdleTimer);
        document.addEventListener('keypress', resetIdleTimer);
        document.addEventListener('touchstart', resetIdleTimer);
        document.addEventListener('click', resetIdleTimer);
        document.addEventListener('scroll', resetIdleTimer);

        document.addEventListener('DOMContentLoaded', handleWalletConnection);

        document.getElementById('toggleLivePanel').addEventListener('click', function() {
            const livePanelContainer = document.getElementById('livePanelContainer');
            const toggleBtn = document.getElementById('toggleLivePanel');
            const icon = toggleBtn.querySelector('i');

            livePanelContainer.classList.toggle('active');

            if (livePanelContainer.classList.contains('active')) {
                icon.classList.remove('fa-chevron-left');
                icon.classList.add('fa-chevron-right');
                document.getElementById('livePanelUnreadDot').style.display = 'none';
                document.getElementById('betsUnreadDot').style.display = 'none';
                document.getElementById('chatUnreadDot').style.display = 'none';
            } else {
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-left');
            }
            resetIdleTimer();
            stopAutoDemo();
        });

        document.getElementById('sendChatBtn').addEventListener('click', sendChat);

        document.getElementById('rouletteCanvas').addEventListener('spinstart', () => {
            const multiplierOptions = document.getElementById('multiplierOptions');
            multiplierOptions.style.display = 'none';
            setTimeout(() => {
                multiplierOptions.style.display = 'grid';
            }, 4000);
        });

        // Load sounds
        loadSound('click', 'https://www.soundjay.com/buttons/button-1.mp3');
        loadSound('win', 'https://www.soundjay.com/misc/success-sound-effect.mp3');
        loadSound('win_10x', 'https://www.soundjay.com/misc/bell-ringing-01.mp3');
        loadSound('sad_trombone', 'https://www.soundjay.com/misc/sad-trombone-01.mp3');
        loadSound('whoosh', 'https://www.soundjay.com/misc/whoosh-1.mp3');
        loadSound('clank', 'https://www.soundjay.com/misc/clink-1.mp3');
        loadSound('tick', 'https://www.soundjay.com/mechanical/tick-tock-1.mp3');

    </script>
</body>

</html>
