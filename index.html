<!DOCTYPE html>
<html lang="en" x-data="cryptoDropApp" x-init="init()" :class="{ 'modal-open': modalOpen || walletModalOpen }">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#1A1A1A" />
  <meta name="description" content="Play CryptoDrop on MemePicks: Stake SOL, drop orbs, win NFTs and DropTokens!" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>CryptoDrop â€“ MemePicks</title>
  <link rel="icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.0/lib/index.iife.min.js" defer></script>
  <script>
    const LS_PREFIX = 'memepicks_';
    const BASE_URL = new URLSearchParams(window.location.search).get('env') === 'dev'
      ? 'http://localhost:5001'
      : 'https://memepicks-backend.onrender.com';
    console.log('Using BASE_URL:', BASE_URL);
    // Color mapping for slots (example)
    const colorMap = {
      '0x': '#9CA3AF', // Gray
      '0.5x': '#60A5FA', // Blue
      '1x': '#34D399', // Green
      '2x': '#FBBF24', // Amber
      '5x': '#F87171', // Red
      '10x': '#A78BFA', // Violet
      'Jackpot': '#F472B6' // Pink/Gold
    };
  </script>
  <style>
    /* ===== Base Styles ===== */
    body {
      font-family: 'Sora', sans-serif;
      background: #121212; /* Darker base */
      color: #FFFFFF;
      min-height: 100vh;
      margin: 0;
      overscroll-behavior: none;
      position: relative; /* Needed for absolute positioned elements like background */
      overflow-x: hidden; /* Prevent horizontal scroll */
    }
    body.modal-open { overflow: hidden; }
    html.dark body { /* Light/dark mode prep */
      background: #0A0A0A;
      color: #FFFFFF;
    }

    /* ===== Card Styles ===== */
    .card {
      @apply bg-gray-800 rounded-xl p-4 mb-4 shadow-lg flex flex-col gap-3 transition-all duration-300 ease-out;
      position: relative;
      will-change: transform, box-shadow;
    }
    @media (hover: hover) and (pointer: fine) {
      .card:hover {
        @apply shadow-purple-400/40 scale-[1.02] -translate-y-0.5;
        box-shadow: 0 8px 25px rgba(167, 139, 250, 0.3);
      }
    }
    .card:active { @apply scale-[0.98]; }

    /* ===== Button Styles ===== */
    .button-primary, .button-secondary, .button-auth {
      @apply px-4 py-3 min-h-[48px] min-w-[80px] text-sm font-semibold rounded-lg transition-all duration-200 ease-out cursor-pointer inline-flex items-center justify-center shadow-md disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none disabled:transform-none;
      touch-action: manipulation;
      will-change: transform, box-shadow, background-color;
    }
    .button-primary { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white border-transparent; }
    .button-secondary { @apply bg-transparent border border-purple-500 text-purple-400; }
    .button-auth { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white font-semibold px-4 py-2 rounded-lg min-h-[44px] shadow-md; }
    @media (hover: hover) and (pointer: fine) {
      .button-primary:hover:not(:disabled), .button-secondary:hover:not(:disabled), .button-auth:hover:not(:disabled) {
        @apply shadow-lg shadow-purple-500/50 scale-[1.03] -translate-y-px;
      }
    }
    .button-primary:active:not(:disabled), .button-secondary:active:not(:disabled), .button-auth:active:not(:disabled) {
      @apply scale-[0.97] transform-none shadow-md;
    }
    .button-primary:disabled, .button-secondary:disabled, .button-auth:disabled {
      @apply bg-gray-600 text-gray-400 border-gray-600;
    }
    .button-primary:focus-visible, .button-secondary:focus-visible, .button-auth:focus-visible {
      outline: 2px solid #7B61FF;
      outline-offset: 2px;
    }

    /* ===== Modal Styles ===== */
    .modal {
      @apply bg-gray-900 rounded-t-xl p-4 w-full max-w-full shadow-[-4px_0px_12px_rgba(0,0,0,0.3)] transition-transform duration-350 ease-out fixed bottom-0 left-0 z-[80] box-border max-h-[90vh] overflow-y-auto;
      padding-bottom: calc(16px + env(safe-area-inset-bottom));
      transform: translateY(100%); /* Start hidden */
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal.open { @apply translate-y-0; }
    .modal-container {
      @apply bg-black/60 transition-opacity duration-300 ease-in-out fixed inset-0 z-[75] opacity-0 pointer-events-none;
      backdrop-filter: blur(6px);
    }
    .modal-container.open { @apply opacity-100 pointer-events-auto; }

    /* ===== Basic Animations ===== */
    .fade-in { animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .glow { animation: glow 1.8s ease-in-out infinite; }
    @keyframes glow {
      0%, 100% { @apply shadow-lg shadow-purple-500/20; }
      50% { @apply shadow-xl shadow-purple-500/40; }
    }

    /* ===== Plinko-Specific Styles ===== */
    #plinko-board {
        position: relative;
        width: 100%;
        max-width: 400px; /* Adjust as needed */
        height: 450px; /* Adjust as needed */
        margin: 0 auto;
        /* border: 1px solid #444; */
        border-radius: 8px;
        overflow: hidden; /* Keep orb inside */
        /* Background handled by dynamic-background now */
    }
     #orb {
        position: absolute;
        width: 16px;
        height: 16px;
        background: radial-gradient(circle, #fecdd3, #f472b6); /* Example gradient orb */
        border-radius: 50%;
        box-shadow: 0 0 10px #f472b6, 0 0 5px white;
        z-index: 10;
        left: 50%; /* Initial position */
        top: 10px; /* Initial position */
        transform: translateX(-50%);
        will-change: top, left, transform;
        /* Orb trail handled by JS */
    }
    .peg {
      position: absolute; /* Position pegs via JS */
      width: 8px;
      height: 8px;
      background-color: #a78bfa; /* Purple pegs */
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(167, 139, 250, 0.7);
      transition: background-color 0.2s ease;
    }
    .peg:hover { background-color: #c4b5fd; } /* Subtle hover */
    .slot-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      padding: 0 5px; /* Adjust spacing */
    }
    .slot {
      width: 30px; /* Adjust size */
      height: 30px;
      border-radius: 4px; /* Can be rounded or square */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end; /* Label at bottom */
      padding-bottom: 2px;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      position: relative; /* For hover info */
      cursor: default; /* Default cursor */
      transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
      /* Base background set by JS based on value */
    }
    .slot.winning {
        animation: slotBounce 0.8s ease-in-out;
        box-shadow: 0 0 15px currentColor, 0 0 30px currentColor; /* Glow with slot color */
    }
    @keyframes slotBounce { /* Winning Slot Bounce */
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-8px) scale(1.1); }
    }
    .slot-label {
      @apply text-xs font-semibold text-center mt-1;
      /* Removed text-shadow, handled by slot */
    }

    /* Community feed */
    .chat-feed {
      @apply h-48 bg-gray-900 rounded-lg p-2 overflow-y-auto mb-2 flex flex-col-reverse; /* Darker feed */
      scrollbar-width: thin;
      scrollbar-color: #7B61FF #374151;
    }
    .chat-message { @apply mb-1.5 text-xs; }
    .chat-message .username { @apply font-semibold text-purple-400 mr-1; } /* Purple username */
    .chat-message .win-amount { @apply font-bold text-green-400 ml-1; } /* Green win amount */

    /* Toast styles */
    .toast {
      @apply fixed bottom-20 left-1/2 transform -translate-x-1/2 text-white text-sm py-2 px-4 rounded-lg z-[100] shadow-lg;
      animation: toastFade 0.4s ease-out forwards, toastSlideUp 0.4s ease-out forwards;
      max-width: 90%;
    }
    @keyframes toastFade {
        0% { opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { opacity: 0; }
    }
    @keyframes toastSlideUp {
        from { transform: translate(-50%, 20px); }
        to { transform: translate(-50%, 0); }
    }
    .toast-success { @apply bg-gradient-to-r from-green-500 to-emerald-500; }
    .toast-error { @apply bg-gradient-to-r from-red-500 to-pink-500; }
    .toast-info { @apply bg-gradient-to-r from-blue-500 to-indigo-500; }

    /* ===== Addictive Visual Enhancements ===== */
    .dynamic-background {
      position: fixed;
      inset: 0;
      z-index: -1; /* Behind everything */
      animation: backgroundFlow 20s linear infinite;
      background: linear-gradient(
        45deg,
        rgba(123, 97, 255, 0.1), /* Purple */
        rgba(255, 105, 180, 0.1), /* Pink */
        rgba(52, 211, 153, 0.1), /* Emerald */
        rgba(123, 97, 255, 0.1) /* Purple again */
      );
      background-size: 400% 400%;
    }
    @keyframes backgroundFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Progressive Glow on Board (applied via JS) */
    #plinko-board.addiction-glow {
       transition: box-shadow 0.5s ease-out; /* Smooth transition for glow changes */
       /* box-shadow is set dynamically in JS */
    }

    /* Anticipation Glow (added/removed via JS) */
    .anticipation-glow {
      position: absolute;
      inset: -10px; /* Slightly larger than board */
      border-radius: 12px; /* Match board rounding */
      background: rgba(123, 97, 255, 0); /* Start transparent */
      box-shadow: 0 0 0px rgba(123, 97, 255, 0);
      animation: anticipation 1.5s cubic-bezier(0.4, 0, 0.2, 1) infinite;
      z-index: 5; /* Above board, below orb */
      pointer-events: none;
    }
    @keyframes anticipation {
      0%, 100% { opacity: 0.4; box-shadow: 0 0 15px rgba(123, 97, 255, 0.3); transform: scale(1); }
      50% { opacity: 1; box-shadow: 0 0 35px rgba(123, 97, 255, 0.7); transform: scale(1.05); }
    }

    /* Reward Explosion (added/removed via JS) */
    .reward-explosion {
      position: absolute;
      width: 100px; /* Base size */
      height: 100px; /* Base size */
      border-radius: 50%;
      pointer-events: none;
      z-index: 20; /* Above orb */
      /* background set dynamically in JS */
      animation: rewardPop 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; /* Bounce effect */
    }
    @keyframes rewardPop {
      0% { transform: scale(0); opacity: 1; }
      60% { transform: scale(2.5); opacity: 0.7; } /* Overshoot */
      100% { transform: scale(2); opacity: 0; } /* Settle and fade */
    }

     /* Win Streak Notification */
    .win-streak {
      @apply fixed top-20 right-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white px-4 py-2 rounded-full text-base font-bold z-[90] shadow-xl;
      animation: streakPop 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy pop */
    }
    @keyframes streakPop {
      0% { transform: scale(0) rotate(-15deg); opacity: 0; }
      70% { transform: scale(1.15) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    /* Particle Canvas */
    #particle-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Behind UI but above background */
        pointer-events: none; /* Allow clicks through */
    }

    /* Gradient Pulse for Jackpot Slots (applied dynamically if needed) */
    .jackpot-pulse {
        background: linear-gradient(270deg, #ff6f00, #ff4081, #7b61ff);
        background-size: 600% 600%;
        animation: gradientShift 4s ease infinite;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

     /* Orb Trail Elements (created by JS) */
    .orb-trail {
      position: absolute;
      width: 12px; /* Slightly smaller than orb */
      height: 12px;
      border-radius: 50%;
      background: rgba(244, 114, 182, 0.5); /* Trail color */
      opacity: 1;
      filter: blur(2px); /* Softer trail */
      transition: opacity 0.8s ease-out, transform 0.8s ease-out; /* Slower fade */
      z-index: 9; /* Below orb */
      pointer-events: none;
    }

    /* Sticky Drop Button */
    .sticky-drop-button {
        @apply fixed bottom-[70px] right-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-full px-5 py-3 shadow-lg z-[70] text-sm font-semibold transition-all duration-300 ease-out opacity-0 pointer-events-none;
        transform: translateY(20px);
    }
    .sticky-drop-button.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
    }

    /* Slot Hover Tooltip (Basic Structure) */
    .slot-tooltip {
        @apply absolute bottom-full left-1/2 mb-2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded shadow-lg whitespace-nowrap opacity-0 invisible transition-opacity duration-200 pointer-events-none;
        z-index: 30;
    }
    .slot:hover .slot-tooltip {
        @apply opacity-100 visible;
    }

    /* Progress Bar */
    .progress-bar-container {
      @apply w-full bg-gray-700 h-2 rounded-full overflow-hidden;
    }
    .progress-bar {
      @apply bg-gradient-to-r from-purple-500 to-blue-500 h-full rounded-full transition-all duration-500 ease-out;
    }

  </style>
</head>
<body class="text-white"
      @click.outside="if(modalOpen || walletModalOpen) closeModals()"
      @keydown.escape.window="if(modalOpen || walletModalOpen) closeModals()"
      @mousemove="updateMousePos($event)"
      @scroll="handleScroll()">

  <div class="dynamic-background"></div>

  <canvas id="particle-canvas"></canvas>

  <div x-show="!walletConnected" class="fixed top-4 left-4 bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded-full z-[90] animate-pulse" aria-live="polite">
    Free Mode: <span x-text="faucetBalance.toFixed(3)"></span> SOL
  </div>

  <header class="fixed top-0 left-0 w-full z-[70] h-14 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700/50 flex items-center justify-between px-4" data-component="header">
    <div class="text-lg font-semibold text-[#7B61FF]">MemePicks</div>
    <h1 class="text-xl font-bold text-white">CryptoDrop</h1>
    <div class="flex items-center space-x-2">
      <a href="/" class="button-secondary text-sm min-h-[44px] px-3 py-2" aria-label="Back to MemePicks">Back</a>
      <button class="button-auth text-sm min-h-[44px] px-3 py-2" @click="walletConnected ? disconnectWallet() : openWalletModal()" x-text="walletConnected ? 'Disconnect' : 'Connect'" :aria-label="walletConnected ? 'Disconnect Wallet' : 'Connect Wallet'"></button>
    </div>
  </header>

  <main class="container mx-auto px-4 pt-20 pb-24 flex flex-col md:flex-row gap-6 relative z-10" data-component="main-content">
    <section class="flex-grow md:w-2/3" data-component="game-board">
      <div id="plinko-board" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl relative overflow-visible" :class="{ 'addiction-glow': consecutivePlays > 0 }">
         <div x-ref="plinkoBoardRef" class="w-full h-[450px] relative">
            </div>
         <div class="slot-container">
            </div>
      </div>

      <section id="controls" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl mt-4 fade-in" data-component="controls">
        <div class="flex justify-between items-center mb-3">
          <h2 class="text-base font-semibold text-[#7B61FF]">Place Your Drop</h2>
          <button class="button-secondary text-xs px-3 py-1 min-h-[32px]" @click="openBoardModal" x-text="`Board: ${selectedBoard}`" aria-label="Change board type"></button>
        </div>

        <div class="mb-3">
            <label for="bet-amount" class="block text-xs text-gray-400 mb-1">Bet Amount (SOL)</label>
            <input type="number" id="bet-amount" step="0.001" min="0.001" max="1" x-model.number="betAmount"
                   class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                   :disabled="dropping"
                   aria-label="Bet amount in SOL">
            </div>

        <button id="drop-button" class="button-primary w-full text-lg font-bold py-4 glow" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
          <span x-show="!dropping">Drop Orb</span>
          <span x-show="dropping">Dropping...</span>
        </button>

        <div class="flex justify-between items-center mt-3 text-xs text-gray-400">
          <span>Balance:</span>
          <span x-text="walletConnected ? (walletBalance !== null ? walletBalance.toFixed(5) + ' SOL' : 'Loading...') : faucetBalance.toFixed(3) + ' SOL (Free)'"></span>
        </div>

        <div class="flex justify-between items-center mt-2 text-xs text-gray-400">
           <span>Drop Streak: <span class="font-semibold text-white" x-text="consecutiveWins > 0 ? `ðŸ”¥ ${consecutiveWins} Wins` : '0'"></span></span>
           <span>Total Drops: <span class="font-semibold text-white" x-text="totalDrops"></span></span>
        </div>

         <div class="mt-3">
            <span class="text-xs text-gray-400 block mb-1">Session Progress (Visual)</span>
            <div class="progress-bar-container">
              <div class="progress-bar" :style="`width: ${progress}%`"></div>
            </div>
         </div>

      </section>
    </section>

    <aside class="md:w-1/3 space-y-4" data-component="info-feed">
        <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="last-drop">
           <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Last Drop</h2>
           <div class="text-sm text-gray-300 min-h-[20px]" x-html="dropResult" aria-live="polite">No drop yet.</div>
       </section>

       <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="community-feed">
           <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Recent Wins</h2>
           <div class="chat-feed" x-ref="chatFeed" role="log" aria-label="Recent CryptoDrop Wins">
               <template x-for="message in communityMessages" :key="message.id">
                   <div class="chat-message">
                       <span class="username" x-text="message.username"></span>
                       <span x-text="message.text"></span>
                       <span class="win-amount" x-text="message.reward ? `(+${message.reward} SOL)` : ''"></span>
                   </div>
               </template>
               <div x-show="communityMessages.length === 0" class="text-center text-gray-500 text-xs mt-4">No recent wins yet.</div>
           </div>
       </section>
    </aside>
  </main>

  <button class="sticky-drop-button" :class="{ 'visible': showStickyButton }" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
      Drop Again!
  </button>

  <div id="boardModal" class="fixed inset-0 z-[80]" x-show="modalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="board-modal-title" data-component="board-modal">
    <div class="modal-container" :class="{ 'open': modalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': modalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h2 id="board-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Board</h2>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close board selection modal">âœ•</button>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Standard' }" @click="selectBoard('Standard')" aria-label="Select Standard Plinko Board">Standard</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'High Risk' }" @click="selectBoard('High Risk')" aria-label="Select High Risk Plinko Board">High Risk</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'NFT Boost' }" @click="selectBoard('NFT Boost')" aria-label="Select NFT Boost Plinko Board">NFT Boost</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Jackpot' }" @click="selectBoard('Jackpot')" aria-label="Select Jackpot Plinko Board">Jackpot</button>
      </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel board selection">Cancel</button>
    </div>
  </div>

  <div id="walletChoiceModal" class="fixed inset-0 z-[80]" x-show="walletModalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="wallet-choice-modal-title" data-component="wallet-modal">
    <div class="modal-container" :class="{ 'open': walletModalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': walletModalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h3 id="wallet-choice-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Wallet</h3>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close wallet choice modal">âœ•</button>
      </div>
      <div class="space-y-3">
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('phantom')" aria-label="Connect with Phantom Wallet">
            <svg class="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M18.0002 48C8.05822 48 0 39.9418 0 30V18.0002C0 8.05822 8.05822 0 18.0002 0H30C39.9418 0 48 8.05822 48 18.0002V30C48 39.9418 39.9418 48 30 48H18.0002ZM24.0003 31.861C28.718 31.861 32.5717 28.0073 32.5717 23.2896C32.5717 18.5719 28.718 14.7182 24.0003 14.7182C19.2826 14.7182 15.4289 18.5719 15.4289 23.2896C15.4289 28.0073 19.2826 31.861 24.0003 31.861Z" fill="currentColor"></path></svg>
            Phantom
        </button>
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('solflare')" aria-label="Connect with Solflare Wallet">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8zm4.818-10.585l-2.828 2.828-1.414-1.414 4.242-4.242 1.414 1.414-1.414 1.414zm-9.636 0l4.242 4.242-1.414 1.414-4.242-4.242 1.414-1.414z" fill="currentColor"></path></svg>
            Solflare
        </button>
        </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel wallet connection">Cancel</button>
    </div>
  </div>

  <footer class="fixed bottom-0 left-0 w-full bg-gray-900/80 backdrop-blur-sm border-t border-gray-700/50 text-center text-xs text-gray-400 py-2 z-[50]" style="padding-bottom: calc(8px + env(safe-area-inset-bottom))" data-component="footer">
    3% staking fee | <a href="/bet" class="text-purple-500 hover:underline" aria-label="Try MemePicks Betting">Try MemePicks Betting</a> | Powered by MemePicks
  </footer>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('cryptoDropApp', () => ({
        // Wallet & Balance State
        walletConnected: false,
        walletAddress: null,
        walletBalance: null, // Real SOL balance
        faucetBalance: 5.000, // Free play balance
        connection: null, // Solana connection object

        // Game State
        selectedBoard: 'Standard',
        betAmount: 0.001, // Default bet
        dropping: false, // Is an orb currently dropping?
        dropResult: 'Place your first drop!',
        orbElement: null,
        pegElements: [],
        slotElements: [],
        boardRect: null, // Cache board dimensions
        currentAnimationId: null, // To cancel animation frame

        // Addictive Elements State
        consecutivePlays: 0, // Plays since last win
        consecutiveWins: 0, // Consecutive wins streak
        lastWinTime: null,
        totalDrops: 0, // Session drop counter
        progress: 0, // Fake progress bar percentage

        // UI State
        modalOpen: false,
        walletModalOpen: false,
        communityMessages: [],
        socket: null,
        showStickyButton: false, // For sticky drop button

        // Particle & Interaction State
        particleCtx: null,
        particles: [],
        mouseX: window.innerWidth / 2,
        mouseY: window.innerHeight / 2,

        // Constants for Plinko board layout (adjust as needed)
        BOARD_WIDTH: 400, // Corresponds to max-width in CSS
        BOARD_HEIGHT: 450,
        PEG_ROWS: 12, // Number of peg rows
        PEG_SIZE: 8,
        SLOT_COUNT: 9, // Number of slots
        SLOT_WIDTH: 30,
        SLOT_HEIGHT: 30,

        // Outcomes (example, should match backend/VRF logic)
        outcomes: [
          { slot: '0x', rewardMult: 0, weight: 0.20, color: colorMap['0x'] },
          { slot: '0.5x', rewardMult: 0.5, weight: 0.25, color: colorMap['0.5x'] },
          { slot: '1x', rewardMult: 1, weight: 0.25, color: colorMap['1x'] },
          { slot: '2x', rewardMult: 2, weight: 0.15, color: colorMap['2x'] },
          { slot: '5x', rewardMult: 5, weight: 0.10, color: colorMap['5x'] },
          { slot: '10x', rewardMult: 10, weight: 0.04, color: colorMap['10x'] },
          { slot: 'Jackpot', rewardMult: 50, weight: 0.01, color: colorMap['Jackpot'] } // Example: 50x Jackpot
        ],

        init() {
          console.log('Initializing CryptoDrop App...');
          // Load wallet state
          try {
            this.walletAddress = localStorage.getItem(LS_PREFIX + 'walletAddress') || null;
            this.walletConnected = !!this.walletAddress;
            if (this.walletConnected) {
              this.connection = new SolanaWeb3.Connection(
                SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'), // Use clusterApiUrl
                'confirmed'
              );
              this.getWalletBalance(this.walletAddress).catch(err => {
                 console.error('Initial balance fetch failed:', err);
                 this.showToast('Failed to load balance.', 'error');
                 // Consider disconnecting if balance fails crucially
                 // this.disconnectWallet();
              });
            }
          } catch (err) {
            console.error('Wallet init failed:', err);
            this.showToast('Wallet initialization error.', 'error');
            localStorage.removeItem(LS_PREFIX + 'walletAddress'); // Clear bad state
            this.walletConnected = false;
            this.walletAddress = null;
          }

          // Initialize Socket.IO
          this.initSocket();

          // Initialize board visuals (pegs, slots)
          this.initBoard();

          // Initialize particle system
          this.initParticles();

           // Load counters from local storage? (Optional)
          this.totalDrops = parseInt(localStorage.getItem(LS_PREFIX + 'totalDrops') || '0');

          // Set initial board glow based on state
          this.updateBoardGlow();

          console.log('CryptoDrop App Initialized.');
        },

        initSocket() {
             try {
                this.socket = io(BASE_URL, {
                    auth: { token: localStorage.getItem(LS_PREFIX + 'authToken') }, // If using auth tokens
                    reconnectionAttempts: 5, // Limit reconnections
                    transports: ['websocket'] // Prefer websocket
                });

                this.socket.on('connect', () => {
                    console.log('Socket connected:', this.socket.id);
                    // Maybe request initial recent wins?
                    this.socket.emit('getRecentWins');
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('Socket disconnected:', reason);
                    if (reason === 'io server disconnect') {
                        // The server disconnected deliberately, maybe auth failed
                        this.showToast('Server disconnected.', 'error');
                    }
                     // Optionally try to reconnect manually or show status
                });

                this.socket.on('connect_error', (err) => {
                    console.error('Socket connection error:', err.message, err.data);
                    this.showToast(`Connection failed: ${err.message}`, 'error');
                });

                // Listen for results broadcasted from the server
                this.socket.on('dropResult', (data) => {
                    // data: { username, slot, reward, isJackpot, timestamp }
                    console.log('Received dropResult:', data);
                    const message = {
                        id: data.timestamp || Date.now(),
                        username: data.username === this.walletAddress ? 'You' : (data.username ? data.username.slice(0, 4) + '...' + data.username.slice(-4) : 'Guest'),
                        text: `landed on ${data.slot}!`,
                        reward: data.reward > 0 ? data.reward.toFixed(5) : null // Format reward
                    };
                    this.communityMessages = [message, ...this.communityMessages.slice(0, 19)]; // Keep last 20 messages
                    this.scrollToChatBottom(); // Auto-scroll chat on new message

                    // Could add special effect if data.isJackpot is true
                });

                 // Handle receiving initial/recent wins list
                this.socket.on('recentWins', (wins) => {
                    console.log('Received recent wins:', wins);
                    this.communityMessages = wins.map(w => ({
                        id: w.timestamp || Date.now(),
                        username: w.username === this.walletAddress ? 'You' : (w.username ? w.username.slice(0, 4) + '...' + w.username.slice(-4) : 'Guest'),
                        text: `landed on ${w.slot}!`,
                        reward: w.reward > 0 ? w.reward.toFixed(5) : null
                    })).slice(0, 20); // Format and limit
                });

            } catch (error) {
                console.error("Socket initialization failed:", error);
                this.showToast("Cannot connect to live feed.", "error");
            }
        },

        initBoard() {
            const boardContainer = this.$refs.plinkoBoardRef;
            if (!boardContainer) return;
            boardContainer.innerHTML = ''; // Clear previous elements
            this.pegElements = [];
            this.slotElements = [];

            const boardWidth = boardContainer.clientWidth || this.BOARD_WIDTH;
            const boardHeight = this.BOARD_HEIGHT;
            this.boardRect = boardContainer.getBoundingClientRect(); // Cache dimensions

            // Create Pegs
            const rowHeight = boardHeight * 0.8 / (this.PEG_ROWS + 1); // Use ~80% of height for pegs
            for (let i = 0; i < this.PEG_ROWS; i++) {
                const pegsInRow = i + 3; // Simple increasing pattern
                const y = rowHeight * (i + 1);
                const spacing = boardWidth / (pegsInRow + 1);
                for (let j = 0; j < pegsInRow; j++) {
                    const x = spacing * (j + 1);
                    const peg = document.createElement('div');
                    peg.className = 'peg';
                    peg.style.left = `${x - this.PEG_SIZE / 2}px`;
                    peg.style.top = `${y - this.PEG_SIZE / 2}px`;
                    boardContainer.appendChild(peg);
                    this.pegElements.push({ element: peg, x, y, radius: this.PEG_SIZE / 2 });
                }
            }

             // Create Slots (ensure outcomes array matches SLOT_COUNT if using fixed count)
            const totalSlotWidth = this.outcomes.length * this.SLOT_WIDTH;
            const totalSpacing = boardWidth - totalSlotWidth;
            const spacing = totalSpacing / (this.outcomes.length + 1);
            const slotContainer = boardContainer.querySelector('.slot-container') || document.createElement('div');
            if (!slotContainer.classList.contains('slot-container')) {
                slotContainer.className = 'slot-container';
                boardContainer.appendChild(slotContainer);
            } else {
                slotContainer.innerHTML = ''; // Clear existing slots
            }

            this.outcomes.forEach((outcome, i) => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.style.backgroundColor = outcome.color || '#4B5563'; // Use outcome color or default
                slot.style.width = `${this.SLOT_WIDTH}px`;
                slot.style.height = `${this.SLOT_HEIGHT}px`;

                const label = document.createElement('span');
                label.className = 'slot-label';
                label.textContent = outcome.slot;
                slot.appendChild(label);

                 // Tooltip (simple version)
                const tooltip = document.createElement('div');
                tooltip.className = 'slot-tooltip';
                tooltip.innerHTML = `
                    Multiplier: ${outcome.slot}<br>
                    Reward: ${(this.betAmount * outcome.rewardMult).toFixed(5)} SOL<br>
                    Chance: ~${(outcome.weight * 100).toFixed(1)}%
                `; // Note: Chance is approximate based on weights
                slot.appendChild(tooltip);

                slotContainer.appendChild(slot);
                // Store slot element and its data for later reference
                this.slotElements.push({ element: slot, outcome: outcome, index: i });
            });

        },

        initParticles() {
             const canvas = document.getElementById('particle-canvas');
             if (!canvas) return;
             this.particleCtx = canvas.getContext('2d');
             canvas.width = window.innerWidth;
             canvas.height = window.innerHeight;

             const colors = ['#7B61FF', '#FF6BEC', '#61FF7B', '#FFB861', '#60A5FA'];
             this.particles = Array.from({ length: 80 }, () => ({ // Reduced particle count
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 2 + 0.5, // Slightly larger min radius
                vx: (Math.random() - 0.5) * 0.5, // Slower base speed
                vy: (Math.random() - 0.5) * 0.5,
                baseVx: (Math.random() - 0.5) * 0.5, // Store base velocity
                baseVy: (Math.random() - 0.5) * 0.5,
                color: colors[Math.floor(Math.random() * colors.length)],
                mass: Math.random() * 2 + 1 // Add mass for interaction later
            }));

            const animateParticles = () => {
                if (!this.particleCtx) return;
                const ctx = this.particleCtx;
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas completely for dynamic background
                // Optional: Redraw a subtle background overlay if needed
                // ctx.fillStyle = 'rgba(18, 18, 18, 0.05)';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.particles.forEach(p => {
                    // Mouse interaction
                    const dx = this.mouseX - p.x;
                    const dy = this.mouseY - p.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = 150; // Interaction radius

                    if (distance < maxDist) {
                        const force = (maxDist - distance) / maxDist; // Closer = stronger force
                        // Accelerate towards/away from mouse based on force
                        p.vx += (dx / distance) * force * 0.08; // Adjusted force factor
                        p.vy += (dy / distance) * force * 0.08;
                    } else {
                         // Dampen towards base velocity if far from mouse
                        p.vx += (p.baseVx - p.vx) * 0.01;
                        p.vy += (p.baseVy - p.vy) * 0.01;
                    }

                    // Apply velocity limits
                    p.vx = Math.max(-2, Math.min(2, p.vx));
                    p.vy = Math.max(-2, Math.min(2, p.vy));

                    p.x += p.vx;
                    p.y += p.vy;

                    // Boundary check (wrap around)
                    if (p.x < -p.radius) p.x = canvas.width + p.radius;
                    if (p.x > canvas.width + p.radius) p.x = -p.radius;
                    if (p.y < -p.radius) p.y = canvas.height + p.radius;
                    if (p.y > canvas.height + p.radius) p.y = -p.radius;

                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = Math.max(0.1, 1 - distance / (maxDist * 2)); // Fade if close to mouse? Optional.
                    ctx.fill();
                    ctx.globalAlpha = 1.0; // Reset alpha
                });

                requestAnimationFrame(animateParticles);
            };

            animateParticles(); // Start the particle animation loop

             // Resize listener
            window.addEventListener('resize', () => {
                if (!canvas) return;
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                 // Reinitialize particles or just update positions?
                 // For simplicity, we'll let them wrap on resize.
            });
        },

         updateMousePos(event) {
            this.mouseX = event.clientX;
            this.mouseY = event.clientY;
        },

        handleScroll() {
            const controlsElement = document.getElementById('controls');
            if (!controlsElement) {
                this.showStickyButton = false;
                return;
            }
            const rect = controlsElement.getBoundingClientRect();
             // Show sticky button if the main drop button section is scrolled out of view
            this.showStickyButton = rect.bottom < 0;
        },

        // === Wallet Functions ===
        async connectWallet(walletType) {
            this.showToast('Connecting wallet...', 'info');
            try {
                let provider;
                 // Use standard wallet adapter detection if available, otherwise basic check
                if (walletType === 'phantom' && ('phantom' in window) && window.phantom.solana) {
                    provider = window.phantom.solana;
                } else if (walletType === 'solflare' && ('solflare' in window) && window.solflare) {
                     provider = window.solflare;
                } else {
                     this.showToast(`Wallet ${walletType} not found. Please install it.`, 'error');
                     // Optionally redirect to wallet installation page
                     window.open(walletType === 'phantom' ? 'https://phantom.app/' : 'https://solflare.com/', '_blank');
                     return;
                }

                 if (!provider.isSolana) throw new Error('Selected provider is not a Solana wallet.');

                 // Try to connect
                 console.log(`Attempting to connect with ${walletType}`);
                 // Use `connect({ onlyIfTrusted: false })` to force prompt if not already connected
                 const response = await provider.connect();
                 const address = response.publicKey.toString();
                 console.log('Wallet connected:', address);

                 localStorage.setItem(LS_PREFIX + 'walletAddress', address);
                 this.walletAddress = address;
                 this.walletConnected = true;

                 this.connection = new SolanaWeb3.Connection(
                     SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'),
                    'confirmed'
                 );

                await this.getWalletBalance(address); // Fetch balance immediately
                this.showToast('Wallet connected!', 'success');
                this.closeModals();
                window.dispatchEvent(new CustomEvent('wallet-connected', { detail: { address } }));

                // Re-initialize board/slots if tooltips depend on bet amount/balance
                this.initBoard();

            } catch (err) {
                console.error('Wallet connection failed:', err);
                let message = 'Failed to connect wallet.';
                if (err.message.includes('User rejected')) {
                    message = 'Connection request rejected.';
                } else if (err.message.includes('not found')) {
                     message = `Please install ${walletType} wallet.`;
                }
                this.showToast(message, 'error');
                this.disconnectWallet(); // Ensure clean state on failure
            }
        },

        async getWalletBalance(address) {
          if (!address || !this.connection) {
            console.warn('Cannot fetch balance: No address or connection.');
            this.walletBalance = null; // Set balance to null if connection fails
            return;
           }
          try {
            console.log(`Fetching balance for ${address}...`);
            const publicKey = new SolanaWeb3.PublicKey(address);
            const balanceLamports = await this.connection.getBalance(publicKey);
            this.walletBalance = balanceLamports / SolanaWeb3.LAMPORTS_PER_SOL;
            console.log('Balance updated:', this.walletBalance);
            window.dispatchEvent(new CustomEvent('balance-updated', { detail: { balance: this.walletBalance } }));
          } catch (err) {
            console.error('Balance fetch failed:', err);
            this.showToast('Failed to fetch balance.', 'error');
             // Decide if we should disconnect or just show null balance
             this.walletBalance = null; // Indicate failed fetch
            // throw err; // Rethrow if caller needs to handle it
          }
        },

        disconnectWallet() {
          // Attempt to disconnect from provider if method exists (good practice)
          try {
            if (window.phantom?.solana?.disconnect) window.phantom.solana.disconnect();
            if (window.solflare?.disconnect) window.solflare.disconnect();
          } catch (e) { console.warn("Error during wallet disconnect:", e); }

          localStorage.removeItem(LS_PREFIX + 'walletAddress');
          this.walletAddress = null;
          this.walletConnected = false;
          this.walletBalance = null;
          this.connection = null;
          // Keep faucet balance as is
          this.showToast('Wallet disconnected.', 'info');
          this.closeModals(); // Ensure modals are closed
          // Re-initialize board/slots if tooltips depend on balance
          this.initBoard();
        },

        // === Modal Controls ===
        openBoardModal() { this.modalOpen = true; },
        openWalletModal() { this.walletModalOpen = true; },
        closeModals() {
          this.modalOpen = false;
          this.walletModalOpen = false;
        },

        // === Board Selection ===
        selectBoard(board) {
          this.selectedBoard = board;
          this.dropResult = `Switched to ${board} board.`;
          this.closeModals();
          // Update board visuals or fetch board-specific odds if necessary
          // this.updateBoardAnimation(); // Example call
          this.initBoard(); // Re-init to update slots/tooltips if needed
          this.showToast(`Switched to ${board} board`, 'info');
          // Inform backend if needed:
          // this.socket.emit('boardChange', { board, username: this.walletAddress || 'Guest' });
        },

        // === Main Game Logic: Orb Drop ===
        async dropOrb() {
            if (this.dropping) return; // Prevent multiple drops

            // Validation
            const stake = this.betAmount;
            if (stake < 0.001) {
                this.showToast('Minimum bet is 0.001 SOL.', 'error');
                return;
            }
            if (!this.walletConnected && this.faucetBalance < stake) {
                this.dropResult = 'Insufficient free mode balance.';
                this.showToast('Insufficient balance.', 'error');
                return;
            }
            if (this.walletConnected && (this.walletBalance === null || this.walletBalance < stake)) {
                this.dropResult = 'Insufficient SOL balance.';
                this.showToast('Insufficient SOL balance.', 'error');
                if (this.walletBalance === null) this.getWalletBalance(this.walletAddress); // Try fetching balance again
                return;
            }

            this.dropping = true;
            this.totalDrops++;
            localStorage.setItem(LS_PREFIX + 'totalDrops', this.totalDrops.toString()); // Persist total drops

            // Haptic feedback for drop start
            this.triggerHaptic([30]);

            // Update balance optimistically (or wait for backend confirmation)
             if (!this.walletConnected) {
                 this.faucetBalance -= stake;
             } else {
                 this.walletBalance -= stake; // Deduct optimistically
             }

            // --- Anticipation ---
            const boardElement = this.$refs.plinkoBoardRef;
            const anticipation = document.createElement('div');
            anticipation.className = 'anticipation-glow';
            boardElement.appendChild(anticipation);

            // Play anticipation sound?
            // playSound('anticipation');

            await new Promise(resolve => setTimeout(resolve, 700)); // Anticipation build-up time
            anticipation.remove();

            // --- Create Orb ---
            this.orbElement = document.createElement('div');
            this.orbElement.id = 'orb'; // Use ID for styling if needed
            // Initial position slightly above board center top
            let orbX = (boardElement.clientWidth || this.BOARD_WIDTH) / 2;
            let orbY = -10; // Start above the board
            this.orbElement.style.left = `${orbX - 8}px`; // Adjust for orb width (16px)
            this.orbElement.style.top = `${orbY}px`;
            boardElement.appendChild(this.orbElement);


            // --- Physics Simulation (Simplified) ---
            let velocityX = (Math.random() - 0.5) * 2; // Initial horizontal nudge
            let velocityY = 1; // Initial downward speed
            const gravity = 0.2;
            const bounceFactor = 0.6; // Energy loss on bounce
            let rotation = 0; // For orb rotation

            // Cancel previous animation if any
            if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);

             const animate = (timestamp) => {
                 if (!this.dropping || !this.orbElement) return; // Stop if drop finished or orb removed

                 // Update velocity and position
                 velocityY += gravity;
                 orbY += velocityY;
                 orbX += velocityX;

                 // Kinetic Rotation
                 rotation += velocityX * 3; // Rotate based on horizontal speed
                 this.orbElement.style.transform = `translateX(-50%) rotate(${rotation}deg)`; // Centered rotation

                  // --- Orb Trail ---
                 this.createOrbTrail(orbX, orbY);

                 // Collision Detection (Simple Peg Check)
                 this.pegElements.forEach(peg => {
                     const dx = orbX - peg.x;
                     const dy = orbY - peg.y;
                     const distance = Math.sqrt(dx * dx + dy * dy);
                     const combinedRadius = (this.orbElement.offsetWidth / 2) + peg.radius;

                     if (distance < combinedRadius) {
                         // Simple collision response: invert velocity slightly randomized
                         const overlap = combinedRadius - distance;
                         const nx = dx / distance; // Normal x
                         const ny = dy / distance; // Normal y

                         // Move orb out of collision
                         orbX += nx * overlap * 0.5; // Move less aggressively
                         orbY += ny * overlap * 0.5;

                         // Reflect velocity (basic)
                         const dotProduct = velocityX * nx + velocityY * ny;
                         velocityX -= 2 * dotProduct * nx;
                         velocityY -= 2 * dotProduct * ny;

                         // Apply bounce factor and slight random angle change
                         velocityX *= bounceFactor * (0.9 + Math.random() * 0.2);
                         velocityY *= bounceFactor * (0.9 + Math.random() * 0.2);
                         velocityX += (Math.random() - 0.5) * 0.5; // Add slight random horizontal push

                         // Limit excessive vertical bounce
                         if (velocityY < -5) velocityY = -5;

                         // Play peg hit sound?
                         // playSound('pegHit');
                         // Haptic feedback for peg hit
                         this.triggerHaptic([10]);
                     }
                 });


                 // Update orb element position
                 this.orbElement.style.left = `${orbX - this.orbElement.offsetWidth / 2}px`;
                 this.orbElement.style.top = `${orbY}px`;


                 // Check if orb reached bottom slots
                 if (orbY >= this.BOARD_HEIGHT - this.SLOT_HEIGHT) { // Check against board height minus slot height
                      // Determine winning slot based on final X position
                      const slotIndex = this.getSlotIndex(orbX);
                      this.finishDrop(slotIndex); // Call finishDrop with the determined slot index
                      return; // Stop animation
                 }

                 // Check if out of bounds (prevent infinite fall)
                 if (orbY > this.BOARD_HEIGHT + 50) {
                      console.warn("Orb fell out of bounds.");
                      this.finishDrop(this.getSlotIndex(orbX)); // Assign to nearest slot even if out of bounds
                      return;
                 }

                this.currentAnimationId = requestAnimationFrame(animate);
             };

            this.currentAnimationId = requestAnimationFrame(animate);

            // --- Progressive Glow Logic ---
            this.consecutivePlays++;
            this.updateBoardGlow();

            // --- Inform Backend (Optional: Could wait until finish) ---
            // const username = this.walletAddress ? this.walletAddress.slice(0, 4) + '...' + this.walletAddress.slice(-4) : 'Guest';
            // this.socket.emit('dropStart', { username, betAmount: stake, board: this.selectedBoard });
        },

        createOrbTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'orb-trail';
            trail.style.left = `${x - 6}px`; // Center trail element
            trail.style.top = `${y + this.orbElement.offsetHeight / 2 - 6}px`; // Position relative to orb center
            this.$refs.plinkoBoardRef.appendChild(trail);

            // Force reflow to apply initial state before transition
            trail.offsetHeight;

            // Apply fade-out and shrink effect
            trail.style.opacity = '0';
            trail.style.transform = 'scale(0.2)';

            // Remove after animation
            setTimeout(() => trail.remove(), 800); // Match transition duration
        },

        getSlotIndex(finalX) {
            // Calculate which slot the final X position falls into
             const boardWidth = this.$refs.plinkoBoardRef.clientWidth || this.BOARD_WIDTH;
             const totalSlotWidth = this.outcomes.length * this.SLOT_WIDTH;
             const totalSpacing = boardWidth - totalSlotWidth;
             const spacing = totalSpacing / (this.outcomes.length + 1);
             let currentX = spacing;
             for (let i = 0; i < this.outcomes.length; i++) {
                 const slotStartX = currentX;
                 const slotEndX = currentX + this.SLOT_WIDTH;
                 if (finalX >= slotStartX && finalX <= slotEndX) {
                     return i;
                 }
                 currentX += this.SLOT_WIDTH + spacing;
             }
             // If slightly out of bounds, snap to nearest edge slot
             return finalX < boardWidth / 2 ? 0 : this.outcomes.length - 1;
        },

        async finishDrop(slotIndex) {
            if (!this.dropping) return; // Avoid finishing multiple times

            // Stop animation loop
            if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);
            this.currentAnimationId = null;

            const winningSlotData = this.slotElements[slotIndex];
            const result = winningSlotData.outcome;
            const rewardValue = this.betAmount * result.rewardMult;

            // --- Reward Reveal Delay ---
            await new Promise(resolve => setTimeout(resolve, 600)); // Delay before showing result

             // Remove orb element
            if (this.orbElement) {
                 this.orbElement.remove();
                 this.orbElement = null;
            }

            // --- Visual Feedback for Win/Loss ---
            const slotElement = winningSlotData.element;
            slotElement.classList.add('winning'); // Add bounce/glow animation class
            setTimeout(() => slotElement.classList.remove('winning'), 800); // Remove after animation

            // Play win/loss sound?
             // playSound(rewardValue > 0 ? 'win' : 'loss');

            // Haptic feedback for win/loss
             this.triggerHaptic(rewardValue > 0 ? [50, 30, 50] : [20]);

             // --- Reward Explosion ---
             if (rewardValue > 0) {
                 const explosion = document.createElement('div');
                 explosion.className = 'reward-explosion';
                 // Position at the center of the winning slot
                 const slotRect = slotElement.getBoundingClientRect();
                 const boardRect = this.$refs.plinkoBoardRef.getBoundingClientRect();
                 const explosionX = slotRect.left + slotRect.width / 2 - boardRect.left;
                 const explosionY = slotRect.top + slotRect.height / 2 - boardRect.top;

                 explosion.style.left = `${explosionX - 50}px`; // Offset by half explosion size
                 explosion.style.top = `${explosionY - 50}px`;
                 explosion.style.background = `radial-gradient(circle, ${result.color} 20%, transparent 70%)`;
                 this.$refs.plinkoBoardRef.appendChild(explosion);
                 setTimeout(() => explosion.remove(), 800); // Match animation duration
             }

             // --- Update Balances ---
             if (rewardValue > 0) {
                 if (!this.walletConnected) {
                     this.faucetBalance += rewardValue;
                 } else {
                      // Instead of adding optimistically, wait for backend confirmation or update after tx
                      // For now, we add it back optimistically IF we deducted optimistically earlier.
                      this.walletBalance += rewardValue;
                      // A more robust approach involves waiting for a confirmed transaction
                      // or a balance update message from the backend/socket.
                      // Example: Fetch balance again after a short delay
                      // setTimeout(() => this.getWalletBalance(this.walletAddress), 2000);
                 }
             }

            // Update Drop Result Text
            this.dropResult = `Landed on <span style="color:${result.color}; font-weight: bold;">${result.slot}</span>! Won ${rewardValue.toFixed(5)} SOL`;

            // --- Win Streak Logic ---
            if (rewardValue > 0.00001) { // Consider near-zero wins as wins for streak
                this.consecutiveWins++;
                this.lastWinTime = Date.now();
                this.consecutivePlays = 0; // Reset non-win plays on a win

                // Show Win Streak Notification
                if (this.consecutiveWins > 1) { // Show only for streaks > 1
                    const streak = document.createElement('div');
                    streak.className = 'win-streak';
                    streak.innerHTML = `WIN STREAK! <span class="text-xl ml-1">x${this.consecutiveWins}</span>`; // Larger streak number
                    document.body.appendChild(streak);
                    setTimeout(() => streak.remove(), 2500); // Show for longer
                }
                 this.showToast(`Won ${rewardValue.toFixed(5)} SOL!`, 'success');

            } else {
                this.consecutiveWins = 0; // Reset streak on loss
                this.showToast(`Landed on ${result.slot}`, 'info'); // Simple notification for loss/0x
            }

             // --- Fake Progress Bar Update ---
             this.progress = (this.progress + Math.random() * 5 + 1) % 100; // Increment progress randomly

            // Reset board glow immediately after win, or keep for non-win
            this.updateBoardGlow();

            // Send final result to backend/socket if needed
            const username = this.walletAddress ? this.walletAddress.slice(0, 4) + '...' + this.walletAddress.slice(-4) : 'Guest';
            if(this.socket?.connected) {
                this.socket.emit('dropResult', {
                    username,
                    board: this.selectedBoard,
                    betAmount: this.betAmount,
                    slot: result.slot,
                    reward: rewardValue,
                    timestamp: Date.now()
                });
            } else {
                // Fallback if socket is down - add to local feed directly
                 const message = { id: Date.now(), username: 'You', text: `landed on ${result.slot}!`, reward: rewardValue > 0 ? rewardValue.toFixed(5) : null };
                 this.communityMessages = [message, ...this.communityMessages.slice(0, 19)];
                 this.scrollToChatBottom();
            }


            // Re-enable drop button
            this.dropping = false;

             // Re-fetch balance after a short delay to sync? (Optional, depends on backend flow)
             // if (this.walletConnected) setTimeout(() => this.getWalletBalance(this.walletAddress), 1500);
        },

        updateBoardGlow() {
            const boardElement = document.getElementById('plinko-board');
            if (!boardElement) return;

            if (this.consecutivePlays > 0) {
                const intensity = Math.min(0.2 + (this.consecutivePlays * 0.05), 0.8); // Cap intensity
                const spread = Math.min(15 + (this.consecutivePlays * 4), 40); // Cap spread
                boardElement.style.boxShadow = `0 0 ${spread}px rgba(123, 97, 255, ${intensity})`;
                // Could also change color based on streak, e.g., shift towards red/orange
            } else {
                 // Reset glow if consecutivePlays is 0 (after a win)
                 boardElement.style.boxShadow = 'none'; // Or a default subtle shadow
                 // boardElement.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)'; // Example default shadow
            }
        },

         // === Utility Functions ===
         triggerHaptic(pattern) {
            if ("vibrate" in navigator) {
                try {
                    navigator.vibrate(pattern);
                } catch (e) {
                    console.warn("Haptic feedback failed:", e);
                }
            }
        },

        scrollToChatBottom() {
             this.$nextTick(() => {
                 const chatFeed = this.$refs.chatFeed;
                 if (chatFeed) {
                     chatFeed.scrollTop = 0; // Scroll to top since it uses flex-col-reverse
                 }
             });
        },

        // === Toast Notification System ===
        showToast(message, type = 'info', duration = 3000) {
            const toastContainer = document.body; // Append directly to body
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            toast.setAttribute('role', 'alert'); // Accessibility

            toastContainer.appendChild(toast);

            // Auto remove toast
            setTimeout(() => {
                toast.style.animation = 'toastFadeOut 0.4s ease-out forwards'; // Add a fade-out animation if desired
                setTimeout(() => toast.remove(), 400); // Remove after fade-out
            }, duration);
        }

        // Add Web Audio API integration here for sounds
        // loadSounds() { ... }
        // playSound(soundName) { ... }

      }));
    });
  </script>

  <style>
    @keyframes toastFadeOut {
        from { opacity: 1; transform: translate(-50%, 0); }
        to { opacity: 0; transform: translate(-50%, -10px); }
    }
  </style>
</body>
</html>