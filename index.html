<!DOCTYPE html>
<html lang="en" x-data="cryptoDropApp" x-init="init()" :class="{ 'modal-open': modalOpen || walletModalOpen }">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#1A1A1A" />
  <meta name="description" content="Play CryptoDrop on MemePicks: Stake SOL, drop orbs, win NFTs and DropTokens!" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>CryptoDrop – MemePicks</title>
  <link rel="icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.0/lib/index.iife.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // --- Configuration ---
    const LS_PREFIX = 'memepicks_'; // Local Storage prefix
    const BASE_URL = new URLSearchParams(window.location.search).get('env') === 'dev'
      ? 'http://localhost:5001' // Development backend URL
      : 'https://memepicks-backend.onrender.com'; // Production backend URL
    console.log('Using BASE_URL:', BASE_URL);

    // Mapping for slot colors
    const colorMap = {
      '0x': '#9CA3AF', // Gray
      '0.5x': '#60A5FA', // Blue
      '1x': '#34D399', // Green
      '2x': '#FBBF24', // Yellow
      '5x': '#F87171', // Red
      '10x': '#A78BFA', // Purple
      'Jackpot': '#F472B6' // Pink
    };

    // --- Game Constants ---
    const BOARD_WIDTH = 400; // px
    const BOARD_HEIGHT = 450; // px
    const PEG_ROWS = 14; // Number of rows of pegs
    const PEG_SIZE = 8; // px
    const SLOT_COUNT = 11; // Number of outcome slots
    const SLOT_WIDTH = 35; // px
    const SLOT_HEIGHT = 40; // px
    const ORB_SIZE = 16; // px
    const GRAVITY = 0.2; // Affects orb vertical acceleration
    const BOUNCE_FACTOR = 0.7; // Energy retained on collision (0 to 1)
    const PEG_COLLISION_DAMPING = 0.9; // Damping factor for peg collisions

    // Outcome definitions with weights (for mock data/frontend simulation)
    // In a real game, these would come from the backend
    const outcomes = [
      { slot: '0x', rewardMult: 0, weight: 0.20, color: colorMap['0x'] },
      { slot: '0.2x', rewardMult: 0.2, weight: 0.15, color: colorMap['0.5x'] },
      { slot: '0.5x', rewardMult: 0.5, weight: 0.20, color: colorMap['0.5x'] },
      { slot: '1x', rewardMult: 1, weight: 0.20, color: colorMap['1x'] },
      { slot: '2x', rewardMult: 2, weight: 0.10, color: colorMap['2x'] },
      { slot: '3x', rewardMult: 3, weight: 0.05, color: colorMap['2x'] },
      { slot: '5x', rewardMult: 5, weight: 0.05, color: colorMap['5x'] },
      { slot: '8x', rewardMult: 8, weight: 0.02, color: colorMap['10x'] },
      { slot: '10x', rewardMult: 10, weight: 0.02, color: colorMap['10x'] },
      { slot: '20x', rewardMult: 20, weight: 0.008, color: colorMap['Jackpot'] },
      { slot: 'Jackpot', rewardMult: 50, weight: 0.002, color: colorMap['Jackpot'] }
    ];
  </script>

  <style>
    /* --- Base Styles --- */
    body {
      font-family: 'Sora', sans-serif;
      background: #121212;
      color: #FFFFFF;
      min-height: 100vh;
      margin: 0;
      overscroll-behavior: none;
      position: relative;
      overflow-x: hidden;
    }
    body.modal-open { overflow: hidden; } /* Prevent scrolling when modal is open */
    html.dark body { /* Dark mode support */
      background: #0A0A0A;
      color: #FFFFFF;
    }

    /* --- Card Styles --- */
    .card {
      @apply bg-gray-800 rounded-xl p-4 mb-4 shadow-lg flex flex-col gap-3 transition-all duration-300 ease-out;
      position: relative;
      will-change: transform, box-shadow;
    }
    /* Hover effects for desktop */
    @media (hover: hover) and (pointer: fine) {
      .card:hover {
        @apply shadow-purple-400/40 scale-[1.02] -translate-y-0.5;
        box-shadow: 0 8px 25px rgba(167, 139, 250, 0.3);
      }
    }
    /* Active state for click/tap */
    .card:active { @apply scale-[0.98]; }

    /* --- Button Styles --- */
    .button-primary, .button-secondary, .button-auth {
      @apply px-4 py-3 min-h-[48px] min-w-[80px] text-sm font-semibold rounded-lg transition-all duration-200 ease-out cursor-pointer inline-flex items-center justify-center shadow-md disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none disabled:transform-none;
      touch-action: manipulation; /* Improve touch responsiveness */
      will-change: transform, box-shadow, background-color;
    }
    .button-primary { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white border-transparent; }
    .button-secondary { @apply bg-transparent border border-purple-500 text-purple-400; }
    .button-auth { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white font-semibold px-4 py-2 rounded-lg min-h-[44px] shadow-md; }

    /* Hover effects for desktop buttons */
    @media (hover: hover) and (pointer: fine) {
      .button-primary:hover:not(:disabled), .button-secondary:hover:not(:disabled), .button-auth:hover:not(:disabled) {
        @apply shadow-lg shadow-purple-500/50 scale-[1.03] -translate-y-px;
      }
    }
    /* Active state for buttons */
    .button-primary:active:not(:disabled), .button-secondary:active:not(:disabled), .button-auth:active:not(:disabled) {
      @apply scale-[0.97] transform-none shadow-md;
    }
    /* Disabled button styles */
    .button-primary:disabled, .button-secondary:disabled, .button-auth:disabled {
      @apply bg-gray-600 text-gray-400 border-gray-600;
    }
    /* Focus styles for accessibility */
    .button-primary:focus-visible, .button-secondary:focus-visible, .button-auth:focus-visible {
      outline: 2px solid #7B61FF;
      outline-offset: 2px;
    }

    /* --- Modal Styles --- */
    .modal {
      @apply bg-gray-900 rounded-t-xl p-4 w-full max-w-full shadow-[-4px_0px_12px_rgba(0,0,0,0.3)] transition-transform duration-350 ease-out fixed bottom-0 left-0 z-[80] box-border max-h-[90vh] overflow-y-auto;
      padding-bottom: calc(16px + env(safe-area-inset-bottom)); /* Safe area for iPhone notch */
      transform: translateY(100%); /* Start off-screen */
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal.open { @apply translate-y-0; } /* Slide in */

    .modal-container {
      @apply bg-black/60 transition-opacity duration-300 ease-in-out fixed inset-0 z-[75] opacity-0 pointer-events-none;
      backdrop-filter: blur(6px); /* Blurred background overlay */
    }
    .modal-container.open { @apply opacity-100 pointer-events-auto; } /* Show overlay */

    /* --- Animation Classes --- */
    .fade-in { animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .glow { animation: glow 1.8s ease-in-out infinite; }
    @keyframes glow {
      0%, 100% { @apply shadow-lg shadow-purple-500/20; }
      50% { @apply shadow-xl shadow-purple-500/40; }
    }

    /* --- Plinko Board Styles (SVG Based) --- */
    #plinko-board {
      position: relative;
      width: 100%;
      max-width: ${BOARD_WIDTH}px; /* Use constant */
      height: ${BOARD_HEIGHT}px; /* Use constant */
      margin: 0 auto;
      border-radius: 8px;
      overflow: hidden;
      /* background-color: #1A1A1A; /* Dark background for board */
    }

    #plinko-svg {
      width: 100%;
      height: 100%;
      overflow: visible; /* Allow orb/trail to go slightly outside */
    }

    .svg-peg {
      fill: #a78bfa; /* Purple */
      transition: fill 0.2s ease;
    }
    .svg-peg:hover { fill: #c4b5fd; } /* Lighter purple on hover */

    .svg-orb {
      fill: url(#orb-gradient); /* Use defined gradient */
      filter: drop-shadow(0 0 8px rgba(244, 114, 182, 0.8)); /* Pink glow */
      transition: transform linear; /* Smooth movement */
      will-change: transform;
    }

    .svg-slot-rect {
      /* Fill color set dynamically by JS */
      transition: fill 0.3s ease-out, transform 0.3s ease-out;
    }

    .svg-slot-label {
      fill: white;
      font-size: 10px;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none; /* Don't block clicks */
    }

    .slot-tooltip {
      /* Tooltip styles */
      position: absolute;
      bottom: 10px; /* Position above the slot */
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(55, 65, 81, 0.9); /* gray-700 with opacity */
      color: white;
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      z-index: 30;
    }

    .svg-slot-rect:hover + .slot-tooltip {
       opacity: 1;
       visibility: visible;
    }


    /* --- Chat Feed Styles --- */
    .chat-feed {
      @apply h-48 bg-gray-900 rounded-lg p-2 overflow-y-auto mb-2 flex flex-col-reverse;
      scrollbar-width: thin; /* Firefox scrollbar */
      scrollbar-color: #7B61FF #374151; /* Scrollbar color */
    }
    /* Custom scrollbar for Webkit browsers */
    .chat-feed::-webkit-scrollbar { width: 6px; }
    .chat-feed::-webkit-scrollbar-track { background: #374151; }
    .chat-feed::-webkit-scrollbar-thumb { background: #7B61FF; border-radius: 3px; }

    .chat-message { @apply mb-1.5 text-xs; }
    .chat-message .username { @apply font-semibold text-purple-400 mr-1; }
    .chat-message .win-amount { @apply font-bold text-green-400 ml-1; }

    /* --- Toast Notification Styles --- */
    .toast {
      @apply fixed bottom-20 left-1/2 transform -translate-x-1/2 text-white text-sm py-2 px-4 rounded-lg z-[100] shadow-lg;
      animation: toastFade 0.4s ease-out forwards, toastSlideUp 0.4s ease-out forwards;
      max-width: 90%;
      text-align: center;
    }
    @keyframes toastFade {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes toastSlideUp {
      from { transform: translate(-50%, 20px); }
      to { transform: translate(-50%, 0); }
    }
    .toast-success { @apply bg-gradient-to-r from-green-500 to-emerald-500; }
    .toast-error { @apply bg-gradient-to-r from-red-500 to-pink-500; }
    .toast-info { @apply bg-gradient-to-r from-blue-500 to-indigo-500; }

    /* --- Background Animations --- */
    .dynamic-background {
      position: fixed;
      inset: 0;
      z-index: -1;
      animation: backgroundFlow 20s linear infinite;
      background: linear-gradient(
        45deg,
        rgba(123,97,255,0.1), /* Purple */
        rgba(255,105,180,0.1), /* Pink */
        rgba(52,211,153,0.1), /* Green */
        rgba(123,97,255,0.1)  /* Purple */
      );
      background-size: 400% 400%;
    }
    @keyframes backgroundFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #plinko-board.addiction-glow {
      transition: box-shadow 0.5s ease-out;
    }

    .anticipation-glow {
      position: absolute;
      inset: -10px; /* Extend slightly beyond the board */
      border-radius: 12px;
      background: rgba(123,97,255,0); /* Transparent initially */
      box-shadow: 0 0 0px rgba(123,97,255,0); /* No shadow initially */
      animation: anticipation 1.5s cubic-bezier(0.4,0,0.2,1) infinite;
      z-index: 5;
      pointer-events: none;
    }
    @keyframes anticipation {
      0%, 100% { opacity: 0.4; box-shadow: 0 0 15px rgba(123,97,255,0.3); transform: scale(1); }
      50% { opacity: 1; box-shadow: 0 0 35px rgba(123,97,255,0.7); transform: scale(1.05); }
    }

    .reward-explosion {
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 20;
      animation: rewardPop 0.8s cubic-bezier(0.175,0.885,0.32,1.275) forwards;
    }
    @keyframes rewardPop {
      0% { transform: scale(0); opacity: 1; }
      60% { transform: scale(2.5); opacity: 0.7; }
      100% { transform: scale(2); opacity: 0; }
    }

    .win-streak {
      @apply fixed top-20 right-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white px-4 py-2 rounded-full text-base font-bold z-[90] shadow-xl;
      animation: streakPop 0.6s cubic-bezier(0.175,0.885,0.32,1.275);
    }
    @keyframes streakPop {
      0% { transform: scale(0) rotate(-15deg); opacity: 0; }
      70% { transform: scale(1.15) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    /* --- Three.js Particle Canvas --- */
    #particle-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2; /* Below dynamic background */
      pointer-events: none;
    }

    /* --- Jackpot Pulse Animation --- */
    .jackpot-pulse {
      background: linear-gradient(270deg, #ff6f00, #ff4081, #7b61ff);
      background-size: 600% 600%;
      animation: gradientShift 4s ease infinite;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* --- Orb Trail Animation --- */
    .orb-trail {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(244,114,182,0.5); /* Semi-transparent pink */
      opacity: 1;
      filter: blur(2px);
      transition: opacity 0.8s ease-out, transform 0.8s ease-out;
      z-index: 9; /* Below orb */
      pointer-events: none;
    }

    /* --- Sticky Drop Button (Mobile) --- */
    .sticky-drop-button {
      @apply fixed bottom-[70px] right-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-full px-5 py-3 shadow-lg z-[70] text-sm font-semibold transition-all duration-300 ease-out opacity-0 pointer-events-none;
      transform: translateY(20px);
      /* Ensure it's only visible on small screens */
      @apply md:hidden;
    }
    .sticky-drop-button.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    /* --- Progress Bar Styles --- */
    .progress-bar-container {
      @apply w-full bg-gray-700 h-2 rounded-full overflow-hidden;
    }
    .progress-bar {
      @apply bg-gradient-to-r from-purple-500 to-blue-500 h-full rounded-full transition-all duration-500 ease-out;
    }

    /* --- Attention Craving Animation for Drop Button --- */
    .orb-drop-trigger {
      animation: craveAttention 1.2s cubic-bezier(0.68,-0.55,0.27,1.55) infinite;
    }
    @keyframes craveAttention {
      0% { transform: scale(1); }
      50% { transform: scale(1.05) rotate(1deg); } /* Slightly smaller scale change */
      100% { transform: scale(1); }
    }

    /* --- Faux Progress Bar Animation --- */
    .faux-progress {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 5; /* Above board elements, below orb */
    }
    .faux-progress::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: fakeProgress 2.5s infinite;
    }
    @keyframes fakeProgress {
      100% { left: 200%; }
    }

    /* --- Near Miss Flash Animation --- */
    .near-miss-flash {
      animation: nearMiss 0.8s ease-out;
    }
    @keyframes nearMiss {
      0% { background-color: #ff000080; } /* Red semi-transparent */
      100% { background-color: transparent; }
    }

    /* --- Addiction Timer / Prompt --- */
    .addiction-timer {
      position: fixed;
      bottom: 70px; /* Above sticky button */
      left: 50%;
      transform: translateX(-50%);
      background: #ff4757; /* Red */
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      box-shadow: 0 0 15px #ff475740;
      z-index: 95; /* Above sticky button, below toasts */
      white-space: nowrap;
    }

    /* --- Loader Orb --- */
    .loader-orb {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #f472b6, #7b61ff); /* Pink to Purple */
      border-radius: 50%;
      animation: pulseLoader 2s ease-in-out infinite;
      z-index: 1000; /* Top layer */
      transform: translate(-50%, -50%); /* Center the orb */
    }
    @keyframes pulseLoader {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.7; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    /* --- Confetti Animation --- */
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #f472b6; /* Default color, can be overridden */
      opacity: 0.8;
      animation: confettiFall 2s linear forwards;
      pointer-events: none;
      z-index: 20; /* Above board elements */
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 0.8; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* --- Win Text Animation --- */
    .win-text {
      @apply fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-2xl font-bold z-[100] text-yellow-300;
      animation: winTextPop 1.5s ease-out forwards;
      text-shadow: 0 0 8px rgba(253, 224, 71, 0.5); /* Yellow glow */
    }
    @keyframes winTextPop {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    /* --- Layout Adjustments for Responsiveness --- */
    @media (min-width: 768px) { /* Medium screens and up */
      main {
        flex-direction: row; /* Side-by-side layout */
      }
      aside {
        width: 33.3333%; /* md:w-1/3 */
        position: sticky; /* Make sidebars sticky */
        top: 80px; /* Below header */
        align-self: flex-start; /* Align to the top */
        max-height: calc(100vh - 160px); /* Limit height to enable scrolling within sidebar */
        overflow-y: auto; /* Enable scrolling for long content */
        scrollbar-width: thin;
        scrollbar-color: #7B61FF #374151;
      }
      aside::-webkit-scrollbar { width: 6px; }
      aside::-webkit-scrollbar-track { background: #374151; }
      aside::-webkit-scrollbar-thumb { background: #7B61FF; border-radius: 3px; }

      section.flex-grow {
        width: 66.6666%; /* md:w-2/3 */
      }

      .sticky-drop-button {
        display: none; /* Hide sticky button on desktop */
      }
    }

    /* --- Additional Styles for Polish --- */
    a { @apply text-purple-400 hover:underline; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
    }
  </style>
</head>
<body class="text-white"
      @click.outside="if(modalOpen || walletModalOpen) closeModals()"
      @keydown.escape.window="if(modalOpen || walletModalOpen) closeModals()"
      @mousemove="updateMousePos($event)"
      @touchstart="updateMousePos($event)"
      @touchmove="updateMousePos($event)"
      @scroll.window="handleScroll()">

  <div class="dynamic-background"></div>
  <canvas id="particle-canvas"></canvas>

  <div x-show="!walletConnected" class="fixed top-4 left-4 bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded-full z-[90] animate-pulse" aria-live="polite">
    Free Mode: <span x-text="faucetBalance.toFixed(3)"></span> SOL
  </div>

  <header class="fixed top-0 left-0 w-full z-[70] h-14 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700/50 flex items-center justify-between px-4" data-component="header">
    <div class="text-lg font-semibold text-[#7B61FF]">MemePicks</div>
    <h1 class="text-xl font-bold text-white">CryptoDrop</h1>
    <div class="flex items-center space-x-2">
      <a href="/" class="button-secondary text-sm min-h-[44px] px-3 py-2" aria-label="Back to MemePicks">Back</a>
      <button class="button-auth text-sm min-h-[44px] px-3 py-2" @click="walletConnected ? disconnectWallet() : openWalletModal()" x-text="walletConnected ? 'Disconnect' : 'Connect'" :aria-label="walletConnected ? 'Disconnect Wallet' : 'Connect Wallet'"></button>
    </div>
  </header>

  <main class="container mx-auto px-4 pt-20 pb-24 flex flex-col md:flex-row gap-6 relative z-10" data-component="main-content">

    <aside class="md:w-1/3 space-y-4 order-2 md:order-1" data-component="community-feed-sidebar">
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="community-feed">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Recent Wins</h2>
        <div class="chat-feed" x-ref="chatFeed" role="log" aria-label="Recent CryptoDrop Wins">
          <template x-for="message in communityMessages" :key="message.id">
            <div class="chat-message">
              <span class="username" x-text="message.username"></span>
              <span x-text="message.text"></span>
              <span class="win-amount" x-text="message.reward ? (+${message.reward} SOL) : ''"></span>
            </div>
          </template>
          <div x-show="communityMessages.length === 0" class="text-center text-gray-500 text-xs mt-4">No recent wins yet.</div>
        </div>
        <div class="text-center text-xs text-gray-400 mt-2">
          <span x-text="onlineUsers"></span> online users
        </div>
      </section>
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="leaderboard">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Leaderboard</h2>
        <ul>
          <li class="text-sm text-gray-300 mb-1">CryptoWhale: 0.850 SOL 🔥</li>
          <li class="text-sm text-gray-300 mb-1">NFTKingpin: 0.620 SOL 🔥</li>
          <li class="text-sm text-gray-300 mb-1">SolDegen99: 0.410 SOL</li>
          <li class="text-sm text-gray-300 mb-1">PlinkoPro: 0.350 SOL</li>
          <li class="text-sm text-gray-300">LuckyLlama: 0.280 SOL</li>
        </ul>
      </section>
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="big-win-ticker">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Big Win!</h2>
        <div class="text-center text-lg font-bold text-yellow-400 animate-pulse">
          CryptoWhale won 0.5 SOL!
        </div>
      </section>
    </aside>

    <section class="flex-grow md:w-2/3 order-1 md:order-2" data-component="game-board">
      <div id="plinko-board" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl relative overflow-visible" :class="{ 'addiction-glow': consecutivePlays > 0 }">
        <svg id="plinko-svg" x-ref="plinkoSvgRef" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${BOARD_WIDTH} ${BOARD_HEIGHT}" preserveAspectRatio="xMidYMin meet">
          <defs>
            <radialGradient id="orb-gradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
              <stop offset="0%" style="stop-color:#fecdd3; stop-opacity:1" />
              <stop offset="100%" style="stop-color:#f472b6; stop-opacity:1" />
            </radialGradient>
            <linearGradient id="jackpot-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" style="stop-color:#ff6f00;" />
              <stop offset="33%" style="stop-color:#ff4081;" />
              <stop offset="66%" style="stop-color:#7b61ff;" />
              <stop offset="100%" style="stop-color:#ff6f00;" />
            </linearGradient>
          </defs>
          </svg>
        <div class="slot-tooltip-container absolute bottom-0 left-0 w-full flex justify-around px-1">
           </div>
      </div>

      <section id="controls" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl mt-4 fade-in" data-component="controls">
        <div class="flex justify-between items-center mb-3">
          <h2 class="text-base font-semibold text-[#7B61FF]">Place Your Drop</h2>
          <button class="button-secondary text-xs px-3 py-1 min-h-[32px]" @click="openBoardModal" x-text="'Board: ' + selectedBoard" aria-label="Change board type"></button>
        </div>
        <div class="mb-3">
          <label for="bet-amount" class="block text-xs text-gray-400 mb-1">Bet Amount (SOL)</label>
          <input type="number" id="bet-amount" step="0.001" min="0.001" max="1" x-model.number="betAmount"
                 class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                 :disabled="dropping"
                 aria-label="Bet amount in SOL">
        </div>
        <button id="drop-button" class="orb-drop-trigger button-primary w-full text-lg font-bold py-4 glow" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
          <span x-show="!dropping">INSTANT WIN! <span x-text="betAmount.toFixed(3)"></span> SOL 🎰</span>
          <span x-show="dropping">Dropping...</span>
        </button>
        <div class="flex justify-between items-center mt-3 text-xs text-gray-400">
          <span>Balance:</span>
          <span x-text="walletConnected ? (walletBalance !== null ? walletBalance.toFixed(5) + ' SOL' : 'Loading...') : faucetBalance.toFixed(3) + ' SOL (Free)'"></span>
        </div>
        <div class="flex justify-between items-center mt-2 text-xs text-gray-400">
          <span>Drop Streak: <span class="font-semibold text-white" x-text="consecutiveWins > 0 ? '🔥 ' + consecutiveWins + ' Wins' : '0'"></span></span>
          <span>Total Drops: <span class="font-semibold text-white" x-text="totalDrops"></span></span>
        </div>
        <div class="mt-3">
          <span class="text-xs text-gray-400 block mb-1">XP Progress (Level <span x-text="level"></span>)</span>
          <div class="progress-bar-container">
            <div class="progress-bar" :style="'width: ' + (xp % 100) + '%'"></div>
          </div>
          <div class="text-xs text-gray-400 mt-1 text-right"><span x-text="xp % 100"></span>/100 XP to next level</div>
        </div>
        <div class="mt-3">
           <span class="text-xs text-gray-400 block mb-1">Daily Mission: Drop 10 times</span>
           <div class="progress-bar-container">
             <div class="progress-bar" :style="'width: ' + (dailyDrops / 10 * 100) + '%'"></div>
           </div>
           <div class="text-xs text-gray-400 mt-1 text-right"><span x-text="dailyDrops"></span>/10 drops today</div>
        </div>
        <div class="mt-3">
          <span class="text-xs text-gray-400 block mb-1">Mystery Box (Drops until unlock: <span x-text="10 - (totalDrops % 10)"></span>)</span>
          <button class="button-secondary w-full text-sm mt-1" :disabled="(totalDrops % 10 !== 0) || totalDrops === 0" @click="openMysteryBox()">Unlock Mystery Box</button>
        </div>
      </section>
    </section>

    <aside class="md:w-1/3 space-y-4 order-3 md:order-3" data-component="wallet-sidebar">
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="wallet-info">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Wallet</h2>
        <div x-show="!walletConnected" class="flex flex-col items-center gap-3">
          <p class="text-sm text-gray-400 text-center">Connect your Solana wallet to play with real SOL.</p>
          <button class="button-auth w-full" @click="openWalletModal()" aria-label="Connect Solana Wallet">Connect Wallet</button>
        </div>
        <div x-show="walletConnected" class="text-sm">
          <p class="text-gray-400 mb-1">Connected:</p>
          <p class="font-mono text-xs break-all mb-2" x-text="walletAddress"></p>
          <p class="text-gray-400 mb-1">Balance:</p>
          <p class="text-lg font-bold text-green-400 mb-3" x-text="walletBalance !== null ? walletBalance.toFixed(5) + ' SOL' : 'Loading...'"></p>
          <button class="button-primary w-full mb-2" aria-label="Deposit SOL">Deposit (Solana Pay)</button>
          <button class="button-secondary w-full" :disabled="walletBalance === null || walletBalance < 0.1" aria-label="Withdraw SOL">Withdraw (Min 0.1 SOL)</button>
        </div>
      </section>
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="referral">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Refer Friends</h2>
        <p class="text-xs text-gray-400 mb-2">Share your code and earn 0.001 SOL per friend who deposits!</p>
        <div class="flex items-center gap-2 mb-2">
          <input type="text" readonly value="YOUR_REFERRAL_CODE" class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white text-sm" aria-label="Your referral code">
          <button class="button-secondary text-xs px-3 py-2 min-h-[38px]" @click="copyToClipboard('YOUR_REFERRAL_CODE')">Copy</button>
        </div>
        <button class="button-secondary w-full text-sm" aria-label="Share referral code on X (Twitter)">Share on X</button>
      </section>
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="session-stats">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Session Stats</h2>
        <div class="text-xs text-gray-400 grid grid-cols-2 gap-2">
          <div>Drops: <span class="font-semibold text-white" x-text="sessionDrops"></span></div>
          <div>Wins: <span class="font-semibold text-white" x-text="sessionWins"></span></div>
          <div class="col-span-2">Spent: <span class="font-semibold text-white" x-text="sessionSpent.toFixed(5)"></span> SOL</div>
          <div class="col-span-2">Won: <span class="font-semibold text-white" x-text="sessionWon.toFixed(5)"></span> SOL</div>
        </div>
      </section>
    </aside>

  </main>

  <button class="sticky-drop-button" :class="{ 'visible': showStickyButton }" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
    Drop Again? ⏳
  </button>

  <div id="boardModal" class="fixed inset-0 z-[80]" x-show="modalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="board-modal-title" data-component="board-modal">
    <div class="modal-container" :class="{ 'open': modalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': modalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h2 id="board-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Board</h2>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close board selection modal">✕</button>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Standard' }" @click="selectBoard('Standard')" aria-label="Select Standard Plinko Board">Standard</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'High Risk' }" @click="selectBoard('High Risk')" aria-label="Select High Risk Plinko Board">High Risk</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'NFT Boost' }" @click="selectBoard('NFT Boost')" aria-label="Select NFT Boost Plinko Board">NFT Boost</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Jackpot' }" @click="selectBoard('Jackpot')" aria-label="Select Jackpot Plinko Board">Jackpot</button>
      </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel board selection">Cancel</button>
    </div>
  </div>

  <div id="walletChoiceModal" class="fixed inset-0 z-[80]" x-show="walletModalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="wallet-choice-modal-title" data-component="wallet-modal">
    <div class="modal-container" :class="{ 'open': walletModalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': walletModalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h3 id="wallet-choice-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Wallet</h3>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close wallet choice modal">✕</button>
      </div>
      <div class="space-y-3">
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('phantom')" aria-label="Connect with Phantom Wallet">
          <svg class="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M18.0002 48C8.05822 48 0 39.9418 0 30V18.0002C0 8.05822 8.05822 0 18.0002 0H30C39.9418 0 48 8.05822 48 18.0002V30C48 39.9418 39.9418 48 30 48H18.0002ZM24.0003 31.861C28.718 31.861 32.5717 28.0073 32.5717 23.2896C32.5717 18.5719 28.718 14.7182 24.0003 14.7182C19.2826 14.7182 15.4289 18.5719 15.4289 23.2896C15.4289 28.0073 19.2826 31.861 24.0003 31.861Z" fill="currentColor"></path></svg>
          Phantom
        </button>
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('solflare')" aria-label="Connect with Solflare Wallet">
          <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8zm4.818-10.585l-2.828 2.828-1.414-1.414 4.242-4.242 1.414 1.414-1.414 1.414zm-9.636 0l4.242 4.242-1.414 1.414-4.242-4.242 1.414-1.414z" fill="currentColor"></path></svg>
          Solflare
        </button>
      </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel wallet connection">Cancel</button>
    </div>
  </div>

  <footer class="fixed bottom-0 left-0 w-full bg-gray-900/80 backdrop-blur-sm border-t border-gray-700/50 text-center text-xs text-gray-400 py-2 z-[50]" style="padding-bottom: calc(8px + env(safe-area-inset-bottom))" data-component="footer">
    3% staking fee | <a href="https://www.gamblinghelpline.org/" target="_blank" class="text-purple-500 hover:underline" aria-label="Responsible Gambling Information">Responsible Gambling</a> | <a href="/terms" class="text-purple-500 hover:underline">Terms</a> | <a href="/privacy" class="text-purple-500 hover:underline">Privacy</a> | Powered by MemePicks v1.0
  </footer>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('cryptoDropApp', () => ({
        // --- State Variables ---
        walletConnected: false,
        walletAddress: null,
        walletBalance: null,
        faucetBalance: 5.000, // Free mode balance
        connection: null, // Solana connection
        selectedBoard: 'Standard',
        betAmount: 0.001,
        dropping: false, // Is an orb currently dropping?
        dropResult: 'Place your first drop!', // Text display for last drop result
        orbElement: null, // Reference to the SVG orb element
        pegElements: [], // Array of SVG peg elements data
        slotElements: [], // Array of SVG slot elements data
        boardRect: null, // Bounding rectangle of the board SVG
        currentAnimationId: null, // requestAnimationFrame ID
        consecutivePlays: 0, // Consecutive drops without a win
        consecutiveWins: 0, // Consecutive wins
        lastWinTime: null, // Timestamp of the last win
        totalDrops: 0, // Total drops across sessions
        dailyDrops: 0, // Drops in the current day
        xp: 0, // Experience points
        level: 1, // Player level
        loginStreak: 0, // Daily login streak
        sessionDrops: 0, // Drops in current session
        sessionWins: 0, // Wins in current session
        sessionSpent: 0, // SOL spent in current session
        sessionWon: 0, // SOL won in current session
        modalOpen: false, // Is board modal open?
        walletModalOpen: false, // Is wallet modal open?
        communityMessages: [], // Live chat messages
        socket: null, // Socket.IO connection
        showStickyButton: false, // Show mobile sticky drop button?
        particleCtx: null, // Canvas context for Three.js particles
        particles: [], // Array of particle objects
        mouseX: window.innerWidth / 2, // Mouse X position for particle interaction
        mouseY: window.innerHeight / 2, // Mouse Y position for particle interaction
        audioContext: null, // Web Audio API context
        sounds: {}, // Loaded audio buffers
        onlineUsers: Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000, // Fake online user count

        // --- Addiction/Gamification Mechanics (Frontend Simulation) ---
        addictionMechanics: {
          fakeLuckyStreak: 0, // Frontend streak simulation
          timeSpent: 0, // Time spent on the page (seconds)
          forcedFOMOInterval: null, // Interval for fake FOMO messages
          jackpotEventTimer: null, // Timer for Jackpot event countdown
          multiplierBoostTimer: null, // Timer for Multiplier Boost countdown

          // Simulates a drop outcome based on weights
          // In a real game, this would be determined by the backend
          calculateSimulatedOutcome() {
              const totalWeight = outcomes.reduce((sum, outcome) => sum + outcome.weight, 0);
              let random = Math.random() * totalWeight;
              for (const outcome of outcomes) {
                  if (random < outcome.weight) {
                      return outcome;
                  }
                  random -= outcome.weight;
              }
              // Fallback in case of floating point issues
              return outcomes[outcomes.length - 1];
          },

          // Frontend simulation of a "forced" win for engagement
          forceFrontendWin() {
              // Simple logic: Force a win after a few losses in free mode
              if (!this.walletConnected && this.consecutivePlays >= 3 && Math.random() < 0.6) {
                  const winOutcomes = outcomes.filter(o => o.rewardMult >= 1);
                  return winOutcomes[Math.floor(Math.random() * winOutcomes.length)];
              }
              return null;
          },

          // Starts the fake FOMO message generator
          startFOMO() {
            if (this.forcedFOMOInterval) clearInterval(this.forcedFOMOInterval);
            this.forcedFOMOInterval = setInterval(() => {
              const fakeUsers = ['ProGambler42', 'CryptoWhale', 'NFTKingpin', 'SolanaMax', 'PlinkoWhale'];
              const fakeWinOutcome = this.calculateSimulatedOutcome();
              const fakeWinAmount = (Math.random() * 0.1 + 0.01).toFixed(5); // Simulate small to medium wins
              this.communityMessages = [{
                id: Date.now() + Math.random(), // Unique ID
                username: fakeUsers[Math.floor(Math.random() * fakeUsers.length)],
                text: `just won ${fakeWinOutcome.slot}!`,
                reward: fakeWinOutcome.rewardMult > 0 ? fakeWinAmount : null // Only show reward if it's a win
              }, ...this.communityMessages.slice(0, 19)]; // Keep last 20 messages
              this.scrollToChatBottom();
            }, Math.random() * (7000 - 4000) + 4000); // Random interval between 4-7 seconds
          },

          // Trigger a Jackpot event (frontend simulation)
          triggerJackpotEvent() {
              if (this.jackpotEventTimer) clearTimeout(this.jackpotEventTimer);
              this.showToast('Jackpot Round Begins in 2:00!', 'info', 120000); // Show toast for 2 minutes
              const countdownDisplay = document.createElement('div');
              countdownDisplay.className = 'addiction-timer';
              document.body.appendChild(countdownDisplay);

              let timeLeft = 120; // 2 minutes
              const updateCountdown = () => {
                  timeLeft--;
                  const minutes = Math.floor(timeLeft / 60);
                  const seconds = (timeLeft % 60).toString().padStart(2, '0');
                  countdownDisplay.textContent = `Jackpot Round: ${minutes}:${seconds}`;
                  if (timeLeft <= 0) {
                      clearInterval(interval);
                      countdownDisplay.remove();
                      this.showToast('Jackpot Round Active!', 'success', 60000); // Active for 1 minute
                      this.triggerMultiplierBoost();
                  }
              };
              updateCountdown(); // Initial display
              const interval = setInterval(updateCountdown, 1000);
          },

          // Trigger a temporary multiplier boost (frontend simulation)
          triggerMultiplierBoost() {
              // This would ideally affect backend odds, but here we'll add a visual cue
              const board = document.getElementById('plinko-board');
              if (board) {
                  board.classList.add('addiction-glow');
                  if (this.multiplierBoostTimer) clearTimeout(this.multiplierBoostTimer);
                  this.multiplierBoostTimer = setTimeout(() => {
                      board.classList.remove('addiction-glow');
                  }, 60000); // Boost lasts for 1 minute
              }
          }
        },

        // --- Initialization ---
        init() {
          console.log('Initializing CryptoDrop App...');
          this.showLoader(); // Show loading animation

          // Load state from Local Storage
          try {
            this.walletAddress = localStorage.getItem(LS_PREFIX + 'walletAddress') || null;
            this.walletConnected = !!this.walletAddress;
            this.totalDrops = parseInt(localStorage.getItem(LS_PREFIX + 'totalDrops') || '0');
            this.dailyDrops = parseInt(localStorage.getItem(LS_PREFIX + 'dailyDrops') || '0');
            this.xp = parseInt(localStorage.getItem(LS_PREFIX + 'xp') || '0');
            this.level = Math.floor(this.xp / 100) + 1; // Level based on XP
            this.loginStreak = parseInt(localStorage.getItem(LS_PREFIX + 'loginStreak') || '0');
            this.faucetBalance = parseFloat(localStorage.getItem(LS_PREFIX + 'faucetBalance') || '5.000');

            // Check for daily reset for drops and login streak
            const lastDropDate = localStorage.getItem(LS_PREFIX + 'lastDropDate');
            const today = new Date().toDateString();
            if (lastDropDate !== today) {
                this.dailyDrops = 0;
                localStorage.setItem(LS_PREFIX + 'lastDropDate', today);
            }
             const lastLoginDate = localStorage.getItem(LS_PREFIX + 'lastLoginDate');
            if (lastLoginDate !== today) {
                this.loginStreak = lastLoginDate ? this.loginStreak + 1 : 1; // Increment streak if previous login was yesterday
                localStorage.setItem(LS_PREFIX + 'lastLoginDate', today);
                localStorage.setItem(LS_PREFIX + 'loginStreak', this.loginStreak.toString());
                this.showToast(`Welcome back! Day ${this.loginStreak} login streak!`, 'success');
            }


            // If wallet was previously connected, try to re-establish connection and fetch balance
            if (this.walletConnected) {
              this.connection = new SolanaWeb3.Connection(
                SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'),
                'confirmed' // Use 'confirmed' for faster balance checks
              );
              this.getWalletBalance(this.walletAddress).catch(err => {
                console.error('Initial balance fetch failed:', err);
                this.showToast('Failed to load wallet balance.', 'error');
                // Don't disconnect automatically on fetch error, let user try again
              });
            }
          } catch (err) {
            console.error('Local Storage or Wallet init failed:', err);
            this.showToast('Initialization error. Local data might be corrupt.', 'error');
            // Clear potentially bad local storage data
            // localStorage.clear(); // Use with caution!
            // Or selectively remove:
            // localStorage.removeItem(LS_PREFIX + 'walletAddress');
            // this.walletConnected = false;
            // this.walletAddress = null;
          }

          this.initSocket(); // Initialize Socket.IO for live feed
          this.initBoard(); // Draw the Plinko board (SVG)
          this.initParticles(); // Initialize Three.js background particles
          this.initAudio(); // Load sound effects
          this.addictionMechanics.startFOMO(); // Start fake win messages

          // Set up timers for jackpot and multiplier boost events
          // Use random initial delays to make it feel less predictable
          setTimeout(() => this.addictionMechanics.triggerJackpotEvent(), Math.random() * 600000 + 300000); // 5-15 mins
          setTimeout(() => this.addictionMechanics.triggerMultiplierBoost(), Math.random() * 300000 + 120000); // 2-7 mins


          // Hide loader after a delay
          setTimeout(() => this.hideLoader(), 2000);

          // Timer to track time spent (for addiction mechanics)
          setInterval(() => this.addictionMechanics.timeSpent += 1, 1000);

          console.log('CryptoDrop App Initialized.');
        },

        // --- UI Helpers ---
        showLoader() {
          const loader = document.createElement('div');
          loader.className = 'loader-orb';
          document.body.appendChild(loader);
        },
        hideLoader() {
          const loader = document.querySelector('.loader-orb');
          if (loader) loader.remove();
        },
        openBoardModal() { this.modalOpen = true; },
        openWalletModal() { this.walletModalOpen = true; },
        closeModals() {
          this.modalOpen = false;
          this.walletModalOpen = false;
        },
        selectBoard(board) {
          this.selectedBoard = board;
          this.dropResult = `Switched to ${board} board.`;
          this.closeModals();
          this.initBoard(); // Redraw board for selected type (if types had different layouts)
          this.showToast(`Switched to ${board} board`, 'info');
        },
        copyToClipboard(text) {
          navigator.clipboard.writeText(text).then(() => {
            this.showToast('Copied to clipboard!', 'success');
          }).catch(err => {
            console.error('Failed to copy:', err);
            this.showToast('Failed to copy.', 'error');
          });
        },

        // --- Socket.IO Integration ---
        initSocket() {
          try {
            this.socket = io(BASE_URL, {
              auth: { token: localStorage.getItem(LS_PREFIX + 'authToken') }, // Authenticate if needed
              reconnectionAttempts: 5,
              transports: ['websocket'] // Prefer websocket
            });

            this.socket.on('connect', () => {
              console.log('Socket connected:', this.socket.id);
              this.socket.emit('getRecentWins'); // Request recent wins on connect
              // Optionally emit user info if logged in
              if(this.walletConnected && this.walletAddress) {
                 this.socket.emit('userInfo', { address: this.walletAddress });
              }
            });

            this.socket.on('disconnect', (reason) => {
              console.log('Socket disconnected:', reason);
              if (reason === 'io server disconnect') {
                this.showToast('Server disconnected.', 'error');
              } else {
                this.showToast('Disconnected from live feed. Reconnecting...', 'info');
              }
            });

            this.socket.on('connect_error', (err) => {
              console.error('Socket connection error:', err.message, err.data);
              this.showToast(`Connection failed: ${err.message}`, 'error');
            });

            // Listen for new drop results from the server
            this.socket.on('dropResult', (data) => {
              console.log('Received dropResult:', data);
              // Add the new message to the community feed
              const message = {
                id: data.timestamp || Date.now() + Math.random(),
                username: data.username === this.walletAddress ? 'You' : (data.username ? data.username.slice(0, 4) + '...' + data.username.slice(-4) : 'Guest'),
                text: `landed on ${data.slot}!`,
                reward: data.reward > 0 ? data.reward.toFixed(5) : null
              };
              this.communityMessages = [message, ...this.communityMessages.slice(0, 19)]; // Add to top, keep 20
              this.scrollToChatBottom(); // Scroll to show the new message
            });

            // Listen for initial list of recent wins
            this.socket.on('recentWins', (wins) => {
              console.log('Received recent wins:', wins);
              this.communityMessages = wins.map(w => ({
                id: w.timestamp || Date.now() + Math.random(),
                username: w.username === this.walletAddress ? 'You' : (w.username ? w.username.slice(0, 4) + '...' + w.username.slice(-4) : 'Guest'),
                text: `landed on ${w.slot}!`,
                reward: w.reward > 0 ? w.reward.toFixed(5) : null
              })).slice(0, 20); // Map and take top 20
              this.scrollToChatBottom();
            });

             // Listen for online user count updates (if backend provides)
            this.socket.on('onlineUsers', (count) => {
                this.onlineUsers = count;
            });

          } catch (error) {
            console.error("Socket initialization failed:", error);
            this.showToast("Cannot connect to live feed.", "error");
          }
        },

        // --- Plinko Board Rendering (SVG) ---
        initBoard() {
          const boardSvg = this.$refs.plinkoSvgRef;
          if (!boardSvg) return;

          // Clear previous board elements
          boardSvg.innerHTML = `
             <defs>
                <radialGradient id="orb-gradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                  <stop offset="0%" style="stop-color:#fecdd3; stop-opacity:1" />
                  <stop offset="100%" style="stop-color:#f472b6; stop-opacity:1" />
                </radialGradient>
                <linearGradient id="jackpot-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                  <stop offset="0%" style="stop-color:#ff6f00;" />
                  <stop offset="33%" style="stop-color:#ff4081;" />
                  <stop offset="66%" style="stop-color:#7b61ff;" />
                  <stop offset="100%" style="stop-color:#ff6f00;" />
                </linearGradient>
              </defs>
          `; // Keep defs, clear rest

          this.pegElements = [];
          this.slotElements = [];
          const boardWidth = boardSvg.clientWidth || BOARD_WIDTH;
          const boardHeight = boardSvg.clientHeight || BOARD_HEIGHT; // Use clientHeight for actual size
          this.boardRect = boardSvg.getBoundingClientRect(); // Update board rect

          // Calculate peg positions
          const rowHeight = boardHeight * 0.8 / (PEG_ROWS + 1); // 80% of height for pegs
          for (let i = 0; i < PEG_ROWS; i++) {
            const pegsInRow = i + 3; // Start with 3 pegs in the first row, increase by 1 each row
            const y = rowHeight * (i + 1);
            const spacing = boardWidth / (pegsInRow + 1);
            for (let j = 0; j < pegsInRow; j++) {
              const x = spacing * (j + 1);
              // Create SVG circle for peg
              const peg = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              peg.setAttribute('class', 'svg-peg');
              peg.setAttribute('cx', x);
              peg.setAttribute('cy', y);
              peg.setAttribute('r', PEG_SIZE / 2);
              boardSvg.appendChild(peg);
              this.pegElements.push({ element: peg, x, y, radius: PEG_SIZE / 2 });
            }
          }

          // Calculate slot positions
          const totalSlotWidth = outcomes.length * SLOT_WIDTH;
          const totalSpacing = boardWidth - totalSlotWidth;
          const spacing = totalSpacing / (outcomes.length + 1);
          const slotContainer = document.createElement('div'); // Use a div for tooltips positioned relative to the SVG
          slotContainer.className = 'slot-tooltip-container absolute bottom-0 left-0 w-full flex justify-around px-1'; // Tailwind classes for positioning
          document.getElementById('plinko-board').appendChild(slotContainer); // Append to the parent div, not the SVG

          outcomes.forEach((outcome, i) => {
            const slotX = spacing * (i + 1) + SLOT_WIDTH * i;
            const slotY = boardHeight - SLOT_HEIGHT; // Position at the bottom

            // Create SVG rectangle for the slot area
            const slotRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            slotRect.setAttribute('class', 'svg-slot-rect');
            slotRect.setAttribute('x', slotX);
            slotRect.setAttribute('y', slotY);
            slotRect.setAttribute('width', SLOT_WIDTH);
            slotRect.setAttribute('height', SLOT_HEIGHT);
            slotRect.setAttribute('rx', 4); // Rounded corners
            slotRect.setAttribute('ry', 4);
            // Set fill color dynamically or use gradient for Jackpot
            if (outcome.slot === 'Jackpot') {
                 slotRect.style.fill = 'url(#jackpot-gradient)'; // Use SVG gradient
                 slotRect.classList.add('jackpot-pulse'); // Add pulse animation class
            } else {
                 slotRect.style.fill = outcome.color || '#4B5563'; // Use solid color
            }
            boardSvg.appendChild(slotRect);

            // Create SVG text for the slot label
            const slotLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            slotLabel.setAttribute('class', 'svg-slot-label');
            slotLabel.setAttribute('x', slotX + SLOT_WIDTH / 2); // Center text
            slotLabel.setAttribute('y', slotY + SLOT_HEIGHT / 2); // Center text
            slotLabel.textContent = outcome.slot;
            boardSvg.appendChild(slotLabel);

            // Create a div for the tooltip (positioned relative to the parent div)
            const tooltip = document.createElement('div');
            tooltip.className = 'slot-tooltip';
             tooltip.style.left = `${slotX + SLOT_WIDTH / 2}px`; // Position tooltip center above slot
            tooltip.innerHTML = `
              Multiplier: ${outcome.slot}<br>
              Reward: ${(this.betAmount * outcome.rewardMult).toFixed(5)} SOL<br>
              Chance: ~${(outcome.weight * 100).toFixed(1)}%
            `;
             // Add hover listener to the SVG rect to show/hide the tooltip
             slotRect.addEventListener('mouseover', () => { tooltip.classList.add('opacity-100', 'visible'); });
             slotRect.addEventListener('mouseout', () => { tooltip.classList.remove('opacity-100', 'visible'); });
             // Add touch listeners for mobile tooltips
             slotRect.addEventListener('touchstart', (e) => {
                 e.stopPropagation(); // Prevent body click from closing modal
                 // Close other tooltips
                 document.querySelectorAll('.slot-tooltip.opacity-100').forEach(t => t.classList.remove('opacity-100', 'visible'));
                 tooltip.classList.add('opacity-100', 'visible');
             });


            slotContainer.appendChild(tooltip); // Append tooltip to the tooltip container div

            this.slotElements.push({ element: slotRect, label: slotLabel, tooltip: tooltip, outcome: outcome, index: i, x: slotX, y: slotY, width: SLOT_WIDTH, height: SLOT_HEIGHT });
          });

          // Initial update of tooltip content based on current bet amount
           this.updateSlotTooltips();

           // Add a resize observer to update board dimensions and redraw
           const resizeObserver = new ResizeObserver(entries => {
               for (let entry of entries) {
                   if (entry.target === boardSvg.parentElement) { // Observe the parent div for size changes
                       this.initBoard(); // Redraw the board when container size changes
                   }
               }
           });
           resizeObserver.observe(boardSvg.parentElement); // Observe the parent div
        },

        // Updates the content of the slot tooltips with the current bet amount
        updateSlotTooltips() {
            this.slotElements.forEach(slotData => {
                 slotData.tooltip.innerHTML = `
                    Multiplier: ${slotData.outcome.slot}<br>
                    Reward: ${(this.betAmount * slotData.outcome.rewardMult).toFixed(5)} SOL<br>
                    Chance: ~${(slotData.outcome.weight * 100).toFixed(1)}%
                 `;
            });
        },

        // --- Three.js Particle Background ---
        initParticles() {
          const canvas = document.getElementById('particle-canvas');
          if (!canvas) return;

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true }); // alpha: true for transparency
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio); // Improve rendering quality

          // Create particles (SOL tokens, NFT shards - simulated as colored points)
          const particleCount = window.innerWidth < 768 ? 80 : 200; // Fewer particles on mobile
          const particleGeometry = new THREE.BufferGeometry();
          const particleVertices = [];
          const particleColors = [];
          const color = new THREE.Color();

          const colors = ['#7B61FF', '#FF6BEC', '#61FF7B', '#FFB861', '#60A5FA', '#FFFFFF']; // Various colors

          for (let i = 0; i < particleCount; i++) {
              // Random position within a larger area
              const x = (Math.random() - 0.5) * 200;
              const y = (Math.random() - 0.5) * 200;
              const z = (Math.random() - 0.5) * 200;
              particleVertices.push(x, y, z);

              // Random color from the list
              color.set(colors[Math.floor(Math.random() * colors.length)]);
              particleColors.push(color.r, color.g, color.b);
          }

          particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
          particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));

          const particleMaterial = new THREE.PointsMaterial({
              size: 0.8, // Size of each particle
              vertexColors: true, // Use colors from geometry
              transparent: true,
              opacity: 0.7,
              blending: THREE.AdditiveBlending // Additive blending for glow effect
          });

          const particles = new THREE.Points(particleGeometry, particleMaterial);
          scene.add(particles);

          camera.position.z = 100; // Move camera back

          // Animation loop
          const animate = () => {
              requestAnimationFrame(animate);

              // Particle movement and interaction (simplified)
              const positions = particleGeometry.attributes.position.array;
              for (let i = 0; i < positions.length; i += 3) {
                  // Basic floating movement
                  positions[i] += Math.sin(Date.now() * 0.0001 + i) * 0.05;
                  positions[i + 1] += Math.cos(Date.now() * 0.0001 + i) * 0.05;
                  positions[i + 2] += Math.sin(Date.now() * 0.00015 + i) * 0.05;

                  // Simple mouse interaction (push particles away)
                  const dx = positions[i] - (this.mouseX / window.innerWidth - 0.5) * 100; // Map mouse X to scene coordinates
                  const dy = positions[i + 1] - -(this.mouseY / window.innerHeight - 0.5) * 100; // Map mouse Y to scene coordinates (invert Y)
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  const maxDist = 50; // Influence radius

                  if (distance < maxDist) {
                      const force = (maxDist - distance) / maxDist;
                      positions[i] += (dx / distance) * force * 0.5;
                      positions[i + 1] += (dy / distance) * force * 0.5;
                  }

                  // Wrap around if particles go out of bounds
                   if (positions[i] > 100) positions[i] = -100;
                   if (positions[i] < -100) positions[i] = 100;
                   if (positions[i + 1] > 100) positions[i + 1] = -100;
                   if (positions[i + 1] < -100) positions[i + 1] = 100;
                   if (positions[i + 2] > 100) positions[i + 2] = -100;
                   if (positions[i + 2] < -100) positions[i + 2] = 100;
              }
              particleGeometry.attributes.position.needsUpdate = true; // Tell Three.js to update positions

              // Rotate particles slightly
              particles.rotation.y += 0.001;
              particles.rotation.x += 0.0005;

              renderer.render(scene, camera);
          };

          animate(); // Start the animation loop

          // Handle window resizing
          window.addEventListener('resize', () => {
              camera.aspect = window.innerWidth / window.innerHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(window.innerWidth, window.innerHeight);
              renderer.setPixelRatio(window.devicePixelRatio);
          });
        },

        // --- Audio Integration ---
        initAudio() {
          try {
            // Check for AudioContext support
            if (!window.AudioContext && !window.webkitAudioContext) {
              console.warn('Web Audio API not supported in this browser.');
              return;
            }
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Function to load a sound file
            const loadSound = async (url, name) => {
              try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                this.sounds[name] = audioBuffer;
                console.log(`Sound loaded: ${name}`);
              } catch (err) {
                console.error(`Failed to load sound ${name} from ${url}:`, err);
              }
            };

            // Load sounds (using placeholder URLs)
            // Replace with actual sound file URLs
            Promise.all([
              loadSound('https://www.soundjay.com/mechanical/sounds/plink-1.mp3', 'plink'), // Placeholder plink
              loadSound('https://www.soundjay.com/money/sounds/coins-jingle-1.mp3', 'win'), // Placeholder win
              loadSound('https://www.soundjay.com/misc/sounds/whoosh-2.mp3', 'loss'), // Placeholder loss/whoosh
              loadSound('https://www.soundjay.com/human/sounds/applause-1.mp3', 'bigwin'), // Placeholder bigwin (applause)
              loadSound('https://www.soundjay.com/buttons/sounds/button-click-1.mp3', 'click') // Placeholder click
            ]).then(() => {
                console.log('All sounds attempted to load.');
                // Optional: Enable a sound toggle button here
            }).catch(err => {
                 console.error('Error during sound loading promises:', err);
            });

             // Background ambient sound (optional, requires user interaction to start)
             // const bgMusic = new Audio('https://example.com/sounds/casino-ambience.mp3'); // Placeholder
             // bgMusic.loop = true;
             // bgMusic.volume = 0.1; // Low volume
             // // Autoplay is often blocked, so you might need a button to start this
             // document.body.addEventListener('click', () => {
             //    if (this.audioContext.state === 'suspended') {
             //        this.audioContext.resume();
             //    }
             //    // bgMusic.play().catch(() => console.log('Background music autoplay blocked'));
             // }, { once: true }); // Only need to listen for first click

          } catch (err) {
            console.error('AudioContext initialization failed:', err);
            this.showToast('Sound effects disabled.', 'info');
          }
        },

        // Plays a loaded sound
        playSound(name) {
          if (!this.audioContext || this.audioContext.state === 'suspended' || !this.sounds[name]) {
               console.warn(`Cannot play sound "${name}". AudioContext state: ${this.audioContext?.state}, Sound loaded: ${!!this.sounds[name]}`);
               return; // Don't play if context is suspended or sound not loaded
          }
          try {
              const source = this.audioContext.createBufferSource();
              source.buffer = this.sounds[name];
              source.connect(this.audioContext.destination);
              source.start(0);
          } catch (e) {
              console.error(`Error playing sound "${name}":`, e);
          }
        },

        // --- Wallet Integration ---
        async connectWallet(walletType) {
          this.showToast('Connecting wallet...', 'info');
          try {
            let provider = null;
            const providerUrl = walletType === 'phantom' ? 'https://phantom.app/' : 'https://solflare.com/';

            // Check if the wallet is installed and accessible
            if (walletType === 'phantom' && ('phantom' in window) && window.phantom.solana) {
              provider = window.phantom.solana;
            } else if (walletType === 'solflare' && ('solflare' in window) && window.solflare) {
              provider = window.solflare;
            }

            // If provider not found, prompt user to install
            if (!provider) {
              this.showToast(`Wallet ${walletType} not found. Please install it.`, 'error');
              window.open(providerUrl, '_blank'); // Open installation page
              return;
            }

            // Check if the provider is a valid Solana wallet
            if (!provider.isSolana) {
                 throw new Error('Selected provider is not a Solana wallet.');
            }

            console.log(`Attempting to connect with ${walletType}`);
            // Request connection from the wallet
            const response = await provider.connect();
            const address = response.publicKey.toString();
            console.log('Wallet connected:', address);

            // Store address and update state
            localStorage.setItem(LS_PREFIX + 'walletAddress', address);
            this.walletAddress = address;
            this.walletConnected = true;

            // Initialize Solana connection if not already
            if (!this.connection) {
                 this.connection = new SolanaWeb3.Connection(
                    SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'),
                    'confirmed'
                 );
            }


            // Fetch initial balance
            await this.getWalletBalance(address);

            this.showToast('Wallet connected!', 'success');
            this.closeModals(); // Close wallet modal
            window.dispatchEvent(new CustomEvent('wallet-connected', { detail: { address } })); // Custom event

            // Re-initialize board if needed (e.g., if different boards require wallet)
            // this.initBoard();

          } catch (err) {
            console.error('Wallet connection failed:', err);
            let message = 'Failed to connect wallet.';
            if (err.message.includes('User rejected')) {
              message = 'Connection request rejected by user.';
            } else if (err.message.includes('not found') || err.message.includes('provider is not a Solana wallet')) {
              message = `Please install ${walletType} wallet.`;
            } else {
                 message = `Connection error: ${err.message}`;
            }
            this.showToast(message, 'error');
            this.disconnectWallet(); // Ensure state is reset on failure
          }
        },

        // Fetches the connected wallet's SOL balance
        async getWalletBalance(address) {
          if (!address || !this.connection) {
            console.warn('Cannot fetch balance: No address or connection.');
            this.walletBalance = null;
            return;
          }
          try {
            console.log(`Fetching balance for ${address}...`);
            const publicKey = new SolanaWeb3.PublicKey(address);
            // Fetch balance in lamports (smallest unit)
            const balanceLamports = await this.connection.getBalance(publicKey);
            // Convert lamports to SOL
            this.walletBalance = balanceLamports / SolanaWeb3.LAMPORTS_PER_SOL;
            console.log('Balance updated:', this.walletBalance);
            window.dispatchEvent(new CustomEvent('balance-updated', { detail: { balance: this.walletBalance } })); // Custom event
          } catch (err) {
            console.error('Balance fetch failed:', err);
            this.showToast('Failed to fetch balance.', 'error');
            this.walletBalance = null; // Set balance to null on error
          }
        },

        // Disconnects the wallet
        disconnectWallet() {
          try {
            // Attempt to call disconnect on known providers
            if (window.phantom?.solana?.disconnect) window.phantom.solana.disconnect();
            if (window.solflare?.disconnect) window.solflare.disconnect();
          } catch (e) {
              console.warn("Error during wallet disconnect:", e);
              // Continue with state reset even if provider disconnect fails
          }
          // Reset state and local storage
          localStorage.removeItem(LS_PREFIX + 'walletAddress');
          this.walletAddress = null;
          this.walletConnected = false;
          this.walletBalance = null;
          this.connection = null; // Clear connection
          this.showToast('Wallet disconnected.', 'info');
          this.closeModals();
          // Re-initialize board if needed (e.g., switch back to free mode board)
          // this.initBoard();
        },

        // --- Game Logic ---
        async dropOrb() {
          // Prevent dropping if already dropping or insufficient balance
          if (this.dropping) return;

          const stake = this.betAmount;
          if (stake < 0.001) {
            this.showToast('Minimum bet is 0.001 SOL.', 'error');
            return;
          }

          // Check balance based on connection status
          if (!this.walletConnected && this.faucetBalance < stake) {
            this.dropResult = 'Insufficient free mode balance.';
            this.showToast('Insufficient balance.', 'error');
            return;
          }
          if (this.walletConnected && (this.walletBalance === null || this.walletBalance < stake)) {
            this.dropResult = 'Insufficient SOL balance.';
            this.showToast('Insufficient SOL balance.', 'error');
            // Attempt to refetch balance if null
            if (this.walletBalance === null) this.getWalletBalance(this.walletAddress);
            return;
          }

          // --- Start Drop ---
          this.dropping = true;
          this.totalDrops++;
          this.dailyDrops++;
          this.sessionDrops++;
          this.sessionSpent += stake;
          this.xp += 10; // Award XP per drop

          // Check for level up
          if (this.xp >= this.level * 100) {
            this.level++;
            this.showToast(`Level Up! You're now Level ${this.level}!`, 'success');
            // Trigger reward unlock based on level
            this.unlockRewards();
          }

          // Save updated stats to Local Storage
          localStorage.setItem(LS_PREFIX + 'totalDrops', this.totalDrops.toString());
          localStorage.setItem(LS_PREFIX + 'dailyDrops', this.dailyDrops.toString());
          localStorage.setItem(LS_PREFIX + 'xp', this.xp.toString());
          localStorage.setItem(LS_PREFIX + 'faucetBalance', this.faucetBalance.toFixed(3)); // Save faucet balance

          // Deduct bet amount
          if (!this.walletConnected) {
            this.faucetBalance -= stake;
          } else {
            // In a real app, this deduction happens on the backend after a successful transaction
            // For frontend simulation, we deduct immediately for UI feedback
            this.walletBalance -= stake;
          }

          this.triggerHaptic([30]); // Basic haptic feedback

          // Show temporary UI elements for anticipation
          const timer = document.createElement('div');
          timer.className = 'addiction-timer';
          timer.textContent = 'QUICK PLAY! BONUS ACTIVE!'; // Example text
          document.body.appendChild(timer);
          setTimeout(() => timer.remove(), 2000);

          const progressBar = document.createElement('div');
          progressBar.className = 'faux-progress';
          this.$refs.plinkoSvgRef.parentElement.appendChild(progressBar); // Append to the parent div
          setTimeout(() => progressBar.remove(), 2000);

          const boardElement = this.$refs.plinkoSvgRef.parentElement; // Reference the parent div for positioning
          const anticipation = document.createElement('div');
          anticipation.className = 'anticipation-glow';
          boardElement.appendChild(anticipation);

          this.playSound('click'); // Play click sound on drop button

          // Delay before starting the orb animation
          await new Promise(resolve => setTimeout(resolve, 700));
          anticipation.remove(); // Remove anticipation glow

          // --- Orb Animation (Physics Simulation) ---
          const boardSvg = this.$refs.plinkoSvgRef;
          const boardWidth = boardSvg.clientWidth || BOARD_WIDTH;
          const boardHeight = boardSvg.clientHeight || BOARD_HEIGHT;

          // Create the SVG orb element
          this.orbElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          this.orbElement.setAttribute('class', 'svg-orb');
          this.orbElement.setAttribute('r', ORB_SIZE / 2); // Radius
          // Start position at the top center
          let orbX = boardWidth / 2;
          let orbY = -ORB_SIZE; // Start slightly above the board

          this.orbElement.setAttribute('cx', orbX);
          this.orbElement.setAttribute('cy', orbY);
          boardSvg.appendChild(this.orbElement);

          // Initial velocity (slight horizontal randomness)
          let velocityX = (Math.random() - 0.5) * 3; // Random initial horizontal speed
          let velocityY = 0; // Start with no vertical speed

          // Clear any previous animation frame
          if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);

          const animate = (timestamp) => {
            if (!this.dropping || !this.orbElement) return;

            // Apply gravity
            velocityY += GRAVITY;

            // Update position
            orbX += velocityX;
            orbY += velocityY;

            // Simple horizontal bounds checking (bounce off walls)
            if (orbX - ORB_SIZE / 2 < 0) {
                orbX = ORB_SIZE / 2;
                velocityX *= -BOUNCE_FACTOR; // Reverse and dampen horizontal velocity
                this.playSound('plink'); // Play sound on wall bounce
            } else if (orbX + ORB_SIZE / 2 > boardWidth) {
                orbX = boardWidth - ORB_SIZE / 2;
                velocityX *= -BOUNCE_FACTOR;
                this.playSound('plink');
            }

            // Check for collisions with pegs
            this.pegElements.forEach(peg => {
              const dx = orbX - peg.x;
              const dy = orbY - peg.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const combinedRadius = (ORB_SIZE / 2) + peg.radius;

              if (distance < combinedRadius) {
                // Collision detected
                const overlap = combinedRadius - distance;
                // Move orb out of collision
                const nx = dx / distance; // Normal vector X
                const ny = dy / distance; // Normal vector Y
                orbX += nx * overlap;
                orbY += ny * overlap;

                // Reflect and dampen velocity
                const dotProduct = velocityX * nx + velocityY * ny;
                velocityX -= 2 * dotProduct * nx;
                velocityY -= 2 * dotProduct * ny;

                // Apply bounce factor and additional damping
                velocityX *= BOUNCE_FACTOR * PEG_COLLISION_DAMPING;
                velocityY *= BOUNCE_FACTOR * PEG_COLLISION_DAMPING;

                // Add some randomness to bounces for less predictable paths
                velocityX += (Math.random() - 0.5) * 0.5;
                velocityY += (Math.random() - 0.5) * 0.5;

                // Prevent sticking to pegs by ensuring minimum velocity
                if (Math.abs(velocityY) < 1) velocityY = Math.sign(velocityY) * 1;


                this.playSound('plink'); // Play peg hit sound
                this.triggerHaptic([10]); // Short haptic pulse
              }
            });

             // Create orb trail effect
            this.createOrbTrail(orbX, orbY);


            // Update orb position in the SVG
            this.orbElement.setAttribute('cx', orbX);
            this.orbElement.setAttribute('cy', orbY);

            // Check if orb has reached the bottom (slots area)
            if (orbY >= boardHeight - SLOT_HEIGHT) {
              const slotIndex = this.getSlotIndex(orbX, boardWidth);
              this.finishDrop(slotIndex); // Finish the drop animation
              return; // Stop animation loop
            }

             // Check if orb fell completely out of bounds (shouldn't happen with proper physics, but good fallback)
            if (orbY > boardHeight + ORB_SIZE) {
                console.warn("Orb fell out of bounds vertically.");
                 const slotIndex = this.getSlotIndex(orbX, boardWidth); // Estimate slot based on final X
                this.finishDrop(slotIndex);
                return;
            }


            // Continue animation loop
            this.currentAnimationId = requestAnimationFrame(animate);
          };

          // Start the animation
          this.currentAnimationId = requestAnimationFrame(animate);

          // Increment consecutive plays (for addiction glow)
          this.consecutivePlays++;
          this.updateBoardGlow(); // Update board glow based on consecutive plays
        },

        // Creates a visual trail element behind the orb
        createOrbTrail(x, y) {
          const trail = document.createElement('div');
          trail.className = 'orb-trail';
           // Position relative to the board container
          const boardRect = this.$refs.plinkoSvgRef.parentElement.getBoundingClientRect();
          trail.style.left = `${boardRect.left + x - 6}px`; // Center trail element
          trail.style.top = `${boardRect.top + y - 6}px`; // Center trail element
          document.body.appendChild(trail); // Append to body to avoid SVG clipping

          // Animate fade out and scale down
          setTimeout(() => {
              trail.style.opacity = '0';
              trail.style.transform = 'scale(0.2)';
          }, 10); // Small delay to ensure initial render

          // Remove trail element after animation
          setTimeout(() => trail.remove(), 800);
        },


        // Determines which slot the orb landed in based on its final X position
        getSlotIndex(finalX, boardWidth) {
          const totalSlotWidth = outcomes.length * SLOT_WIDTH;
          const totalSpacing = boardWidth - totalSlotWidth;
          const spacing = totalSpacing / (outcomes.length + 1);

          let currentX = spacing; // Start of the first slot area
          for (let i = 0; i < outcomes.length; i++) {
            const slotStartX = currentX;
            const slotEndX = currentX + SLOT_WIDTH;

            // Check if the final X position is within the horizontal bounds of the slot
            if (finalX >= slotStartX && finalX <= slotEndX) {
              return i; // Return the index of the slot
            }
            currentX += SLOT_WIDTH + spacing; // Move to the start of the next slot area
          }

          // Fallback: if for some reason it doesn't land perfectly,
          // assign to the nearest slot or edge slot
          return finalX < boardWidth / 2 ? 0 : outcomes.length - 1;
        },

        // Handles the end of the drop animation and determines the outcome
        async finishDrop(slotIndex) {
          if (!this.dropping) return; // Ensure we only process once

          // Stop the animation loop
          if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);
          this.currentAnimationId = null;

          // Get the outcome data for the landed slot
          const winningSlotData = this.slotElements[slotIndex];
          const result = winningSlotData.outcome;
          const rewardValue = this.betAmount * result.rewardMult;

          // Short delay to allow orb to settle visually (optional)
          await new Promise(resolve => setTimeout(resolve, 100));

          // Remove the orb element
          if (this.orbElement) {
            this.orbElement.remove();
            this.orbElement = null;
          }

          // Animate the winning slot
          const slotElement = winningSlotData.element; // This is the SVG rect
          const slotLabelElement = winningSlotData.label; // This is the SVG text

          // Add winning animation class
          slotElement.classList.add('winning'); // You'll need CSS for '.winning' animation

          // Change slot color temporarily for emphasis (SVG fill)
           const originalFill = slotElement.style.fill;
           slotElement.style.fill = '#FFD700'; // Gold color for win

          // Play win/loss sound
          if (rewardValue > 0) {
            this.playSound(rewardValue >= this.betAmount * 5 ? 'bigwin' : 'win'); // Play big win or regular win sound
            this.triggerHaptic([50, 30, 50]); // Stronger haptic feedback for wins
            this.createConfetti(winningSlotData.x + winningSlotData.width / 2, winningSlotData.y + winningSlotData.height / 2); // Create confetti at slot position
            this.sessionWins++; // Increment session wins
            this.sessionWon += rewardValue; // Add to session won amount

            // Show win text animation for larger wins
            if (rewardValue >= this.betAmount * 2) {
              const winText = document.createElement('div');
              winText.className = 'win-text';
              winText.textContent = rewardValue >= this.betAmount * 10 ? 'YOU BROKE THE GAME!' :
                                    rewardValue >= this.betAmount * 5 ? 'INSANE HIT!' : 'Let’s gooo!';
              document.body.appendChild(winText);
              setTimeout(() => winText.remove(), 1500); // Remove text after animation
            }

            // Update balance (for frontend simulation)
            if (!this.walletConnected) {
              this.faucetBalance += rewardValue;
               localStorage.setItem(LS_PREFIX + 'faucetBalance', this.faucetBalance.toFixed(3));
            } else {
              this.walletBalance += rewardValue;
              // In a real app, the backend confirms the win and updates balance via transaction
              // We might need to refetch balance here or rely on a socket update from backend
               this.getWalletBalance(this.walletAddress); // Refresh balance
            }

            // Show reward explosion effect
            this.createRewardExplosion(winningSlotData.x + winningSlotData.width / 2, winningSlotData.y + winningSlotData.height / 2, result.color);

            // Update consecutive wins and reset consecutive plays
            this.consecutiveWins++;
            this.lastWinTime = Date.now();
            this.consecutivePlays = 0;

            // Show win streak indicator
            if (this.consecutiveWins > 1) {
              const streak = document.createElement('div');
              streak.className = 'win-streak';
              streak.innerHTML = `WIN STREAK! <span class="text-xl ml-1">x${this.consecutiveWins}</span>`;
              document.body.appendChild(streak);
              setTimeout(() => streak.remove(), 2500);
            }

            this.showToast(`Won ${rewardValue.toFixed(5)} SOL!`, 'success'); // Show win toast

          } else { // Loss
            this.playSound('loss'); // Play loss sound
            this.triggerHaptic([20]); // Shorter haptic pulse
            this.consecutiveWins = 0; // Reset win streak

             // Add near-miss flash effect to the slot
            slotElement.classList.add('near-miss-flash');


            // Trigger near-miss message/UI based on chance
            if (Math.random() < 0.6) { // 60% chance for near miss message on loss
                const nearMissOutcomes = outcomes.filter(o => o.rewardMult > 0); // Consider any winning slot a 'near miss' possibility
                const nearMissSlot = nearMissOutcomes[Math.floor(Math.random() * nearMissOutcomes.length)];
                 this.showToast(`So close to ${nearMissSlot.slot}! Try again!`, 'error');
                 // Optionally highlight the 'near miss' slot visually
                 const nearMissSlotElement = this.slotElements.find(s => s.outcome.slot === nearMissSlot.slot)?.element;
                 if(nearMissSlotElement) {
                     nearMissSlotElement.classList.add('near-miss-flash');
                     setTimeout(() => nearMissSlotElement.classList.remove('near-miss-flash'), 800);
                 }
            } else {
                 this.showToast(`Landed on ${result.slot}`, 'info'); // Standard loss toast
            }

             // Show Loss Recovery Meter/Prompt after 5 consecutive losses
            if (this.consecutiveWins === 0 && this.consecutivePlays >= 5) {
                 this.showLossRecoveryPrompt();
            }
          }

          // Update the drop result display
          this.dropResult = `Landed on <span style="color:${result.color || '#FFFFFF'}; font-weight: bold;">${result.slot}</span>! Won ${rewardValue.toFixed(5)} SOL`;

          // Remove winning/near-miss classes after animation
          setTimeout(() => {
               slotElement.classList.remove('winning', 'near-miss-flash');
               slotElement.style.fill = originalFill; // Restore original color/gradient
          }, 1200);


          // Update progress bar (example: random increase)
          this.progress = (this.progress + Math.random() * 5 + 1) % 100;

          // Update board glow based on consecutive plays
          this.updateBoardGlow();

          // Emit drop result to the server for live feed
          const username = this.walletAddress ? this.walletAddress.slice(0, 4) + '...' + this.walletAddress.slice(-4) : 'Guest';
          if (this.socket?.connected) {
            this.socket.emit('dropResult', {
              username,
              board: this.selectedBoard,
              betAmount: this.betAmount,
              slot: result.slot,
              reward: rewardValue,
              timestamp: Date.now()
            });
          } else {
             // If socket is not connected, add to local community messages
            const message = { id: Date.now() + Math.random(), username: 'You', text: `landed on ${result.slot}!`, reward: rewardValue > 0 ? rewardValue.toFixed(5) : null };
            this.communityMessages = [message, ...this.communityMessages.slice(0, 19)];
            this.scrollToChatBottom();
          }

          // Reset dropping state
          this.dropping = false;

          // Prompt for auto-replay after a short delay
          setTimeout(() => this.showAutoReplayPrompt(), 3000);

           // Update session stats display
           localStorage.setItem(LS_PREFIX + 'sessionDrops', this.sessionDrops.toString());
           localStorage.setItem(LS_PREFIX + 'sessionWins', this.sessionWins.toString());
           localStorage.setItem(LS_PREFIX + 'sessionSpent', this.sessionSpent.toFixed(5));
           localStorage.setItem(LS_PREFIX + 'sessionWon', this.sessionWon.toFixed(5));

           // Update tooltip rewards based on current bet amount
           this.updateSlotTooltips();

        },

        // Creates confetti animation originating from a specific point
        createConfetti(x, y) {
          const boardElement = this.$refs.plinkoSvgRef.parentElement; // Parent div
          const boardRect = boardElement.getBoundingClientRect(); // Board position

          for (let i = 0; i < 30; i++) { // More confetti
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            // Position relative to the board container
            confetti.style.left = `${boardRect.left + x + (Math.random() - 0.5) * 20}px`; // Spread horizontally
            confetti.style.top = `${boardRect.top + y + (Math.random() - 0.5) * 20}px`; // Spread vertically
            confetti.style.backgroundColor = ['#f472b6', '#7b61ff', '#34d399', '#FBBF24'][Math.floor(Math.random() * 4)]; // Multiple colors
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            // Add random animation delay and duration for variety
            confetti.style.animationDelay = `${Math.random() * 0.5}s`;
            confetti.style.animationDuration = `${2 + Math.random() * 1}s`; // Vary duration
            document.body.appendChild(confetti); // Append to body

            // Remove after animation
            setTimeout(() => confetti.remove(), (2 + Math.random() * 1) * 1000 + (Math.random() * 0.5) * 1000);
          }
        },

        // Creates a reward explosion effect at the winning slot position
        createRewardExplosion(x, y, color) {
          const explosion = document.createElement('div');
          explosion.className = 'reward-explosion';
          const boardElement = this.$refs.plinkoSvgRef.parentElement; // Parent div
          const boardRect = boardElement.getBoundingClientRect(); // Board position
          // Position relative to the board container
          explosion.style.left = `${boardRect.left + x - 50}px`; // Center the 100px element
          explosion.style.top = `${boardRect.top + y - 50}px`; // Center the 100px element
          explosion.style.background = `radial-gradient(circle, ${color || '#FFFFFF'} 20%, transparent 70%)`; // Use slot color
          explosion.style.animationDuration = '0.8s'; // Match CSS animation duration
          document.body.appendChild(explosion); // Append to body

          // Remove after animation
          setTimeout(() => explosion.remove(), 800);
        },

        // Shows a prompt to drop again after a delay
        showAutoReplayPrompt() {
          if (this.dropping) return; // Don't show if dropping starts independently

          const prompt = document.createElement('div');
          prompt.className = 'addiction-timer';
          prompt.textContent = 'Drop again? 5...';
          document.body.appendChild(prompt);

          let countdown = 5;
          const interval = setInterval(() => {
            countdown--;
            prompt.textContent = `Drop again? ${countdown}...`;
            if (countdown <= 0) {
              clearInterval(interval);
              prompt.remove();
              // Auto-drop if not already dropping and user hasn't interacted
              if (!this.dropping) {
                  this.dropOrb();
              }
            }
          }, 1000);

           // Remove prompt if user interacts (e.g., clicks drop button)
           const dropButton = document.getElementById('drop-button');
           const removePrompt = () => {
               clearInterval(interval);
               if (prompt.parentElement) prompt.remove();
               dropButton.removeEventListener('click', removePrompt);
           };
           dropButton.addEventListener('click', removePrompt);
        },

        // Shows a prompt for loss recovery (free drop)
        showLossRecoveryPrompt() {
             if (this.walletConnected) return; // Only for free mode

             this.showToast('Lost 5 times in a row in Free Mode! Here\'s a free drop.', 'info', 5000);

             // Temporarily add 0.001 SOL for a free drop
             this.faucetBalance += 0.001;
             localStorage.setItem(LS_PREFIX + 'faucetBalance', this.faucetBalance.toFixed(3));

             // Reset consecutive plays after providing recovery
             this.consecutivePlays = 0;
        },


        // Updates the glow effect on the board based on consecutive plays
        updateBoardGlow() {
          const boardElement = document.getElementById('plinko-board');
          if (!boardElement) return;

          if (this.consecutivePlays > 0) {
            // Increase intensity and spread based on consecutive losses
            const intensity = Math.min(0.2 + (this.consecutivePlays * 0.05), 0.8);
            const spread = Math.min(15 + (this.consecutivePlays * 4), 40);
            boardElement.style.boxShadow = `0 0 ${spread}px rgba(123, 97, 255, ${intensity})`;
          } else {
            // No consecutive losses, remove glow
            boardElement.style.boxShadow = 'none';
          }
        },

        // Triggers haptic feedback (vibration) on supported devices
        triggerHaptic(pattern) {
          if ("vibrate" in navigator) {
            try {
              navigator.vibrate(pattern);
            } catch (e) {
              console.warn("Haptic feedback failed:", e);
            }
          }
        },

        // Scrolls the chat feed to the bottom (most recent messages)
        scrollToChatBottom() {
          this.$nextTick(() => {
            const chatFeed = this.$refs.chatFeed;
            if (chatFeed) {
              // Scroll to the top to see the newest message (since it's flex-direction: column-reverse)
              chatFeed.scrollTop = 0;
            }
          });
        },

        // Shows a temporary toast notification
        showToast(message, type = 'info', duration = 3000) {
          const toastContainer = document.body;
          const toast = document.createElement('div');
          toast.className = `toast toast-${type}`;
          toast.textContent = message;
          toast.setAttribute('role', 'alert'); // Accessibility
          toastContainer.appendChild(toast);

          // Remove toast after duration
          setTimeout(() => {
            toast.style.animation = 'toastFadeOut 0.4s ease-out forwards'; // Start fade out animation
            setTimeout(() => toast.remove(), 400); // Remove element after fade out
          }, duration);
        },

        // Updates mouse/touch position for particle interaction
        updateMousePos(event) {
            // Handle touch events
            if (event.touches && event.touches.length > 0) {
                this.mouseX = event.touches[0].clientX;
                this.mouseY = event.touches[0].clientY;
            } else { // Handle mouse events
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }
        },

        // Handles scroll events to show/hide the sticky drop button on mobile
        handleScroll() {
          const controlsElement = document.getElementById('controls');
          // Only show sticky button on small screens
          if (window.innerWidth >= 768 || !controlsElement) {
            this.showStickyButton = false;
            return;
          }

          const rect = controlsElement.getBoundingClientRect();
          // Show sticky button if the controls section is scrolled out of view (its bottom is above the viewport)
          this.showStickyButton = rect.bottom < 0;
        },

        // --- Gamification Functions ---
        unlockRewards() {
            // Example: Unlock Diamond Board at Level 5
            if (this.level >= 5 && !localStorage.getItem(LS_PREFIX + 'unlockedDiamondBoard')) {
                localStorage.setItem(LS_PREFIX + 'unlockedDiamondBoard', 'true');
                this.showToast('Unlocked Diamond Board!', 'success');
                // Optionally update available boards in the modal
            }
             // Add other reward unlocks based on level, streak, etc.
        },

        openMysteryBox() {
            if ((this.totalDrops % 10 !== 0) || this.totalDrops === 0) {
                this.showToast(`Drop ${10 - (this.totalDrops % 10)} more times to unlock!`, 'info');
                return;
            }

            this.showToast('Opening Mystery Box...', 'info');
            // Simulate mystery box outcome
            const outcomes = ['0.002 SOL', 'NFT Shard (Placeholder)', 'Multiplier Boost', 'Free Drop'];
            const randomOutcome = outcomes[Math.floor(Math.random() * outcomes.length)];

            setTimeout(() => {
                let rewardMessage = `You got: ${randomOutcome}!`;
                let rewardType = 'success';

                switch (randomOutcome) {
                    case '0.002 SOL':
                        if (!this.walletConnected) {
                            this.faucetBalance += 0.002;
                             localStorage.setItem(LS_PREFIX + 'faucetBalance', this.faucetBalance.toFixed(3));
                        } else {
                             // In a real app, this would be a transaction or backend credit
                             this.showToast('0.002 SOL added to your balance!', 'success');
                             this.getWalletBalance(this.walletAddress); // Refresh balance
                        }
                        break;
                    case 'Multiplier Boost':
                        this.addictionMechanics.triggerMultiplierBoost();
                        rewardMessage += " (Multiplier boost active for 60s!)";
                        break;
                    case 'Free Drop':
                         // Provide a free drop (logic handled in dropOrb check)
                         rewardMessage += " (Your next drop is free!)";
                         // You might need a flag if the free drop logic isn't just balance based
                        break;
                    case 'NFT Shard (Placeholder)':
                        // Placeholder for NFT reward logic
                        rewardType = 'info';
                        break;
                }
                 this.showToast(rewardMessage, rewardType, 5000);
            }, 1500); // Simulate opening delay
        }


      }));
    });
  </script>
  <style>
    /* Additional CSS for toast fade out animation */
    @keyframes toastFadeOut {
      from { opacity: 1; transform: translate(-50%, 0); }
      to { opacity: 0; transform: translate(-50%, -10px); }
    }
  </style>
</body>
</html>
