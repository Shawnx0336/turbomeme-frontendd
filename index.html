<!DOCTYPE html>
<html lang="en" x-data="cryptoDropApp" x-init="init()" :class="{ 'modal-open': modalOpen || walletModalOpen }">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#1A1A1A" />
  <meta name="description" content="Play CryptoDrop on MemePicks: Stake SOL, drop orbs, win NFTs and DropTokens!" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>CryptoDrop ‚Äì MemePicks</title>
  <link rel="icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&display=swap" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js" defer></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.0/lib/index.iife.min.js" defer></script>
  <script>
    const LS_PREFIX = 'memepicks_';
    const BASE_URL = new URLSearchParams(window.location.search).get('env') === 'dev'
      ? 'http://localhost:5001'
      : 'https://memepicks-backend.onrender.com';
    console.log('Using BASE_URL:', BASE_URL);
    const colorMap = {
      '0x': '#9CA3AF',
      '0.5x': '#60A5FA',
      '1x': '#34D399',
      '2x': '#FBBF24',
      '5x': '#F87171',
      '10x': '#A78BFA',
      'Jackpot': '#F472B6'
    };
  </script>
  <style>
    body {
      font-family: 'Sora', sans-serif;
      background: #121212;
      color: #FFFFFF;
      min-height: 100vh;
      margin: 0;
      overscroll-behavior: none;
      position: relative;
      overflow-x: hidden;
    }
    body.modal-open { overflow: hidden; }
    html.dark body {
      background: #0A0A0A;
      color: #FFFFFF;
    }
    .card {
      @apply bg-gray-800 rounded-xl p-4 mb-4 shadow-lg flex flex-col gap-3 transition-all duration-300 ease-out;
      position: relative;
      will-change: transform, box-shadow;
    }
    @media (hover: hover) and (pointer: fine) {
      .card:hover {
        @apply shadow-purple-400/40 scale-[1.02] -translate-y-0.5;
        box-shadow: 0 8px 25px rgba(167, 139, 250, 0.3);
      }
    }
    .card:active { @apply scale-[0.98]; }
    .button-primary, .button-secondary, .button-auth {
      @apply px-4 py-3 min-h-[48px] min-w-[80px] text-sm font-semibold rounded-lg transition-all duration-200 ease-out cursor-pointer inline-flex items-center justify-center shadow-md disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none disabled:transform-none;
      touch-action: manipulation;
      will-change: transform, box-shadow, background-color;
    }
    .button-primary { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white border-transparent; }
    .button-secondary { @apply bg-transparent border border-purple-500 text-purple-400; }
    .button-auth { @apply bg-gradient-to-r from-purple-500 to-blue-500 text-white font-semibold px-4 py-2 rounded-lg min-h-[44px] shadow-md; }
    @media (hover: hover) and (pointer: fine) {
      .button-primary:hover:not(:disabled), .button-secondary:hover:not(:disabled), .button-auth:hover:not(:disabled) {
        @apply shadow-lg shadow-purple-500/50 scale-[1.03] -translate-y-px;
      }
    }
    .button-primary:active:not(:disabled), .button-secondary:active:not(:disabled), .button-auth:active:not(:disabled) {
      @apply scale-[0.97] transform-none shadow-md;
    }
    .button-primary:disabled, .button-secondary:disabled, .button-auth:disabled {
      @apply bg-gray-600 text-gray-400 border-gray-600;
    }
    .button-primary:focus-visible, .button-secondary:focus-visible, .button-auth:focus-visible {
      outline: 2px solid #7B61FF;
      outline-offset: 2px;
    }
    .modal {
      @apply bg-gray-900 rounded-t-xl p-4 w-full max-w-full shadow-[-4px_0px_12px_rgba(0,0,0,0.3)] transition-transform duration-350 ease-out fixed bottom-0 left-0 z-[80] box-border max-h-[90vh] overflow-y-auto;
      padding-bottom: calc(16px + env(safe-area-inset-bottom));
      transform: translateY(100%);
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal.open { @apply translate-y-0; }
    .modal-container {
      @apply bg-black/60 transition-opacity duration-300 ease-in-out fixed inset-0 z-[75] opacity-0 pointer-events-none;
      backdrop-filter: blur(6px);
    }
    .modal-container.open { @apply opacity-100 pointer-events-auto; }
    .fade-in { animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
    @keyframes fadeIn {
      from { opacity: 0; transform: ugyanlateY(8px) scale(0.99); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .glow { animation: glow 1.8s ease-in-out infinite; }
    @keyframes glow {
      0%, 100% { @apply shadow-lg shadow-purple-500/20; }
      50% { @apply shadow-xl shadow-purple-500/40; }
    }
    #plinko-board {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 450px;
      margin: 0 auto;
      border-radius: 8px;
      overflow: hidden;
    }
    #orb {
      position: absolute;
      width: 16px;
      height: 16px;
      background: radial-gradient(circle, #fecdd3, #f472b6);
      border-radius: 50%;
      box-shadow: 0 0 10px #f472b6, 0 0 5px white;
      z-index: 10;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      will-change: top, left, transform;
    }
    .peg {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: #a78bfa;
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(167,139,250,0.7);
      transition: background-color 0.2s ease;
    }
    .peg:hover { background-color: #c4b5fd; }
    .slot-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      padding: 0 5px;
    }
    .slot {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 2px;
      font-size: 10px;
      font-weight: 600;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      position: relative;
      cursor: default;
      transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
    }
    .slot.winning {
      animation: slotBounce 0.8s ease-in-out;
      box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
    }
    @keyframes slotBounce {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-8px) scale(1.1); }
    }
    .slot-label {
      @apply text-xs font-semibold text-center mt-1;
    }
    .chat-feed {
      @apply h-48 bg-gray-900 rounded-lg p-2 overflow-y-auto mb-2 flex flex-col-reverse;
      scrollbar-width: thin;
      scrollbar-color: #7B61FF #374151;
    }
    .chat-message { @apply mb-1.5 text-xs; }
    .chat-message .username { @apply font-semibold text-purple-400 mr-1; }
    .chat-message .win-amount { @apply font-bold text-green-400 ml-1; }
    .toast {
      @apply fixed bottom-20 left-1/2 transform -translate-x-1/2 text-white text-sm py-2 px-4 rounded-lg z-[100] shadow-lg;
      animation: toastFade 0.4s ease-out forwards, toastSlideUp 0.4s ease-out forwards;
      max-width: 90%;
    }
    @keyframes toastFade {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes toastSlideUp {
      from { transform: translate(-50%, 20px); }
      to { transform: translate(-50%, 0); }
    }
    .toast-success { @apply bg-gradient-to-r from-green-500 to-emerald-500; }
    .toast-error { @apply bg-gradient-to-r from-red-500 to-pink-500; }
    .toast-info { @apply bg-gradient-to-r from-blue-500 to-indigo-500; }
    .dynamic-background {
      position: fixed;
      inset: 0;
      z-index: -1;
      animation: backgroundFlow 20s linear infinite;
      background: linear-gradient(
        45deg,
        rgba(123,97,255,0.1),
        rgba(255,105,180,0.1),
        rgba(52,211,153,0.1),
        rgba(123,97,255,0.1)
      );
      background-size: 400% 400%;
    }
    @keyframes backgroundFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #plinko-board.addiction-glow {
      transition: box-shadow 0.5s ease-out;
    }
    .anticipation-glow {
      position: absolute;
      inset: -10px;
      border-radius: 12px;
      background: rgba(123,97,255,0);
      box-shadow: 0 0 0px rgba(123,97,255,0);
      animation: anticipation 1.5s cubic-bezier(0.4,0,0.2,1) infinite;
      z-index: 5;
      pointer-events: none;
    }
    @keyframes anticipation {
      0%, 100% { opacity: 0.4; box-shadow: 0 0 15px rgba(123,97,255,0.3); transform: scale(1); }
      50% { opacity: 1; box-shadow: 0 0 35px rgba(123,97,255,0.7); transform: scale(1.05); }
    }
    .reward-explosion {
‡Æ±

      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 20;
      animation: rewardPop 0.8s cubic-bezier(0.175,0.885,0.32,1.275) forwards;
    }
    @keyframes rewardPop {
      0% { transform: scale(0); opacity: 1; }
      60% { transform: scale(2.5); opacity: 0.7; }
      100% { transform: scale(2); opacity: 0; }
    }
    .win-streak {
      @apply fixed top-20 right-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white px-4 py-2 rounded-full text-base font-bold z-[90] shadow-xl;
      animation: streakPop 0.6s cubic-bezier(0.175,0.885,0.32,1.275);
    }
    @keyframes streakPop {
      0% { transform: scale(0) rotate(-15deg); opacity: 0; }
      70% { transform: scale(1.15) rotate(5deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    #particle-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }
    .jackpot-pulse {
      background: linear-gradient(270deg, #ff6f00, #ff4081, #7b61ff);
      background-size: 600% 600%;
      animation: gradientShift 4s ease infinite;
    }
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .orb-trail {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(244,114,182,0.5);
      opacity: 1;
      filter: blur(2px);
      transition: opacity 0.8s ease-out, transform 0.8s ease-out;
      z-index: 9;
      pointer-events: none;
    }
    .sticky-drop-button {
      @apply fixed bottom-[70px] right-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-full px-5 py-3 shadow-lg z-[70] text-sm font-semibold transition-all duration-300 ease-out opacity-0 pointer-events-none;
      transform: translateY(20px);
    }
    .sticky-drop-button.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .slot-tooltip {
      @apply absolute bottom-full left-1/2 mb-2 -translate-x-1/2 bg-gray-700 text-white text-xs px-2 py-1 rounded shadow-lg whitespace-nowrap opacity-0 invisible transition-opacity duration-200 pointer-events-none;
      z-index: 30;
    }
    .slot:hover .slot-tooltip {
      @apply opacity-100 visible;
    }
    .progress-bar-container {
      @apply w-full bg-gray-700 h-2 rounded-full overflow-hidden;
    }
    .progress-bar {
      @apply bg-gradient-to-r from-purple-500 to-blue-500 h-full rounded-full transition-all duration-500 ease-out;
    }
    .orb-drop-trigger {
      animation: craveAttention 1.2s cubic-bezier(0.68,-0.55,0.27,1.55) infinite;
    }
    @keyframes craveAttention {
      0% { transform: scale(1); }
      50% { transform: scale(1.15) rotate(3deg); }
      100% { transform: scale(1); }
    }
    .faux-progress {
      position: relative;
      overflow: hidden;
    }
    .faux-progress::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: fakeProgress 2.5s infinite;
    }
    @keyframes fakeProgress {
      100% { left: 200%; }
    }
    .near-miss-flash {
      animation: nearMiss 0.8s ease-out;
    }
    @keyframes nearMiss {
      0% { background: #ff000080; }
      100% { background: transparent; }
    }
    .addiction-timer {
      position: fixed;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: #ff4757;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      box-shadow: 0 0 15px #ff475740;
    }
    .loader-orb {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #f472b6, #7b61ff);
      border-radius: 50%;
      animation: pulseLoader 2s ease-in-out infinite;
      z-index: 1000;
    }
    @keyframes pulseLoader {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.5); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #f472b6;
      opacity: 0.8;
      animation: confettiFall 2s linear forwards;
      pointer-events: none;
      z-index: 20;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 0.8; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .floating-orb {
      position: absolute;
      width: 10px;
      height: 10px;
      background: radial-gradient(circle, #a78bfa, transparent);
      border-radius: 50%;
      animation: floatUp 10s linear infinite;
      z-index: -1;
    }
    @keyframes floatUp {
      0% { transform: translateY(100vh); opacity: 0.5; }
      100% { transform: translateY(-100vh); opacity: 0; }
    }
    .win-text {
      @apply fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-2xl font-bold z-[100] text-yellow-300;
      animation: winTextPop 1.5s ease-out forwards;
    }
    @keyframes winTextPop {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }
  </style>
</head>
<body class="text-white"
      @click.outside="if(modalOpen || walletModalOpen) closeModals()"
      @keydown.escape.window="if(modalOpen || walletModalOpen) closeModals()"
      @mousemove="updateMousePos($event)"
      @scroll  @scroll="handleScroll()">
  <div class="dynamic-background"></div>
  <canvas id="particle-canvas"></canvas>
  <div x-show="!walletConnected" class="fixed top-4 left-4 bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded-full z-[90] animate-pulse" aria  aria-live="polite">
    Free Mode: <span x-text="faucetBalance.toFixed(3)"></span> SOL
  </div>
  <header class="fixed top-0 left-0 w-full z-[70] h-14 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700/50 flex items-center justify-between px-4" data-component="header">
    <div class="text-lg font-semibold text-[#7B61FF]">MemePicks</div>
    <h1 class="text-xl font-bold text-white">CryptoDrop</h1>
    <div class="flex items-center space-x-2">
      <a href="/" class="button-secondary text-sm min-h-[44px] px-3 py-2" aria-label="Back to MemePicks">Back</a>
      <button class="button-auth text-sm min-h-[44px] px-3 py-2" @click="walletConnected ? disconnectWallet() : openWalletModal()" x-text="walletConnected ? 'Disconnect' : 'Connect'" :aria-label="walletConnected ? 'Disconnect Wallet' : 'Connect Wallet'"></button>
    </div>
  </header>
  <main class="container mx-auto px-4 pt-20 pb-24 flex flex-col md:flex-row gap-6 relative z-10" data-component="main-content">
    <section class="flex-grow md:w-2/3" data-component="game-board">
      <div id="plinko-board" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl relative overflow-visible" :class="{ 'addiction-glow': consecutivePlays > 0 }">
        <div x-ref="plinkoBoardRef" class="w-full h-[450px] relative"></div>
        <div class="slot-container"></div>
      </div>
      <section id="controls" class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl mt-4 fade-in" data-component="controls">
        <div class="flex justify-between items-center mb-3">
          <h2 class="text-base font-semibold text-[#7B61FF]">Place Your Drop</h2>
          <button class="button-secondary text-xs px-3 py-1 min-h-[32px]" @click="openBoardModal" x-text="`Board: ${selectedBoard}`" aria-label="Change board type"></button>
        </div>
        <div class="mb-3">
          <label for="bet-amount" class="block text-xs text-gray-400 mb-1">Bet Amount (SOL)</label>
          <input type="number" id="bet-amount" step="0.001" min="0.001" max="1" x-model.number="betAmount"
                 class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                 :disabled="dropping"
                 aria-label="Bet amount in SOL">
        </div>
        <button id="drop-button" class="orb-drop-trigger button-primary w-full text-lg font-bold py-4 glow" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
          <span x-show="!dropping">INSTANT WIN! 0.001 SOL üé∞</span>
          <span x-show="dropping">Dropping...</span>
        </button>
        <div class="flex justify-between items-center mt-3 text-xs text-gray-400">
          <span>Balance:</span>
          <span x-text="walletConnected ? (walletBalance !== null ? walletBalance.toFixed(5) + ' SOL' : 'Loading...') : faucetBalance.toFixed(3) + ' SOL (Free)'"></span>
        </div>
        <div class="flex justify-between items-center mt-2 text-xs text-gray-400">
          <span>Drop Streak: <span class="font-semibold text-white" x-text="consecutiveWins > 0 ? `üî• ${consecutiveWins} Wins` : '0'"></span></span>
          <span>Total Drops: <span class="font-semibold text-white" x-text="totalDrops"></span></span>
        </div>
        <div class="mt-3">
          <span class="text-xs text-gray-400 block mb-1">Session Progress</span>
          <div class="progress-bar-container">
            <div class="progress-bar faux-progress" :style="`width: ${progress}%`"></div>
          </div>
        </div>
        <div class="text-xs text-gray-400 mt-2">
          <span>Today's Spent: <span x-text="(plays * 0.001).toFixed(3)"></span> SOL</span>
          <span class="mx-2">‚Ä¢</span>
          <span>Potential Wins: <span x-text="(plays * 0.005).toFixed(3)"></span> SOL</span>
        </div>
      </section>
    </section>
    <aside class="md:w-1/3 space-y-4" data-component="info-feed">
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="last-drop">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Last Drop</h2>
        <div class="text-sm text-gray-300 min-h-[20px]" x-html="dropResult" aria-live="polite">No drop yet.</div>
      </section>
      <section class="card bg-gray-800/70 backdrop-blur-sm p-4 rounded-xl fade-in" data-component="community-feed">
        <h2 class="text-sm font-semibold text-[#7B61FF] mb-2">Recent Wins</h2>
        <div class="chat-feed" x-ref="chatFeed" role="log" aria-label="Recent CryptoDrop Wins">
          <template x-for="message in communityMessages" :key="message.id">
            <div class="chat-message">
              <span class="username" x-text="message.username"></span>
              <span x-text="message.text"></span>
              <span class="win-amount" x-text="message.reward ? `(+${message.reward} SOL)` : ''"></span>
            </div>
          </template>
          <div x-show="communityMessages.length === 0" class="text-center text-gray-500 text-xs mt-4">No recent wins yet.</div>
        </div>
      </section>
    </aside>
  </main>
  <button class="sticky-drop-button" :class="{ 'visible': showStickyButton }" @click="dropOrb()" :disabled="dropping || (!walletConnected && faucetBalance < betAmount) || (walletConnected && (walletBalance === null || walletBalance < betAmount))">
    Drop Again? ‚è≥
  </button>
  <div id="boardModal" class="fixed inset-0 z-[80]" x-show="modalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="board-modal-title" data-component="board-modal">
    <div class="modal-container" :class="{ 'open': modalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': modalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h2 id="board-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Board</h2>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close board selection modal">‚úï</button>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Standard' }" @click="selectBoard('Standard')" aria-label="Select Standard Plinko Board">Standard</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'High Risk' }" @click="selectBoard('High Risk')" aria-label="Select High Risk Plinko Board">High Risk</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'NFT Boost' }" @click="selectBoard('NFT Boost')" aria-label="Select NFT Boost Plinko Board">NFT Boost</button>
        <button class="button-primary text-sm min-h-[44px]" :class="{ 'opacity-70': selectedBoard === 'Jackpot' }" @click="selectBoard('Jackpot')" aria-label="Select Jackpot Plinko Board">Jackpot</button>
      </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel board selection">Cancel</button>
    </div>
  </div>
  <div id="walletChoiceModal" class="fixed inset-0 z-[80]" x-show="walletModalOpen" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" role="dialog" aria-modal="true" aria-labelledby="wallet-choice-modal-title" data-component="wallet-modal">
    <div class="modal-container" :class="{ 'open': walletModalOpen }" @click="closeModals"></div>
    <div class="modal" :class="{ 'open': walletModalOpen }" @click.stop>
      <div class="flex justify-between items-center mb-4">
        <h3 id="wallet-choice-modal-title" class="text-base font-semibold text-[#7B61FF]">Choose Wallet</h3>
        <button class="text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center text-2xl" @click="closeModals" aria-label="Close wallet choice modal">‚úï</button>
      </div>
      <div class="space-y-3">
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('phantom')" aria-label="Connect with Phantom Wallet">
          <svg class="w-5 h-5" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M18.0002 48C8.05822 48 0 39.9418 0 30V18.0002C0 8.05822 8.05822 0 18.0002 0H30C39.9418 0 48 8.05822 48 18.0002V30C48 39.9418 39.9418 48 30 48H18.0002ZM24.0003 31.861C28.718 31.861 32.5717 28.0073 32.5717 23.2896C32.5717 18.5719 28.718 14.7182 24.0003 14.7182C19.2826 14.7182 15.4289 18.5719 15.4289 23.2896C15.4289 28.0073 19.2826 31.861 24.0003 31.861Z" fill="currentColor"></path></svg>
          Phantom
        </button>
        <button class="button-primary w-full text-sm flex items-center justify-center gap-2 min-h-[44px]" @click="connectWallet('solflare')" aria-label="Connect with Solflare Wallet">
          <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8zm4.818-10.585l-2.828 2.828-1.414-1.414 4.242-4.242 1.414 1.414-1.414 1.414zm-9.636 0l4.242 4.242-1.414 1.414-4.242-4.242 1.414-1.414z" fill="currentColor"></path></svg>
          Solflare
        </button>
      </div>
      <button class="button-secondary w-full text-sm mt-4 min-h-[44px]" @click="closeModals" aria-label="Cancel wallet connection">Cancel</button>
    </div>
  </div>
  <footer class="fixed bottom-0 left-0 w-full bg-gray-900/80 backdrop-blur-sm border-t border-gray-700/50 text-center text-xs text-gray-400 py-2 z-[50]" style="padding-bottom: calc(8px + env(safe-area-inset-bottom))" data-component="footer">
    3% staking fee | <a href="/bet" class="text-purple-500 hover:underline" aria-label="Try MemePicks Betting">Try MemePicks Betting</a> | Powered by MemePicks
  </footer>
  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('cryptoDropApp', () => ({
        walletConnected: false,
        walletAddress: null,
        walletBalance: null,
        faucetBalance: 5.000,
        connection: null,
        selectedBoard: 'Standard',
        betAmount: 0.001,
        dropping: false,
        dropResult: 'Place your first drop!',
        orbElement: null,
        pegElements: [],
        slotElements: [],
        boardRect: null,
        currentAnimationId: null,
        consecutivePlays: 0,
        consecutiveWins: 0,
        lastWinTime: null,
        totalDrops: 0,
        progress: 0,
        plays: 0,
        level: 1,
        xp: 0,
        loginStreak: 0,
        modalOpen: false,
        walletModalOpen: false,
        communityMessages: [],
        socket: null,
        showStickyButton: false,
        particleCtx: null,
        particles: [],
        mouseX: window.innerWidth / 2,
        mouseY: window.innerHeight / 2,
        audioContext: null,
        sounds: {},
        BOARD_WIDTH: 400,
        BOARD_HEIGHT: 450,
        PEG_ROWS: 12,
        PEG_SIZE: 8,
        SLOT_COUNT: 9,
        SLOT_WIDTH: 30,
        SLOT_HEIGHT: 30,
        outcomes: [
          { slot: '0x', rewardMult: 0, weight: 0.20, color: colorMap['0x'] },
          { slot: '0.5x', rewardMult: 0.5, weight: 0.25, color: colorMap['0.5x'] },
          { slot: '1x', rewardMult: 1, weight: 0.25, color: colorMap['1x'] },
          { slot: '2x', rewardMult: 2, weight: 0.15, color: colorMap['2x'] },
          { slot: '5x', rewardMult: 5, weight: 0.10, color: colorMap['5x'] },
          { slot: '10x', rewardMult: 10, weight: 0.04, color: colorMap['10x'] },
          { slot: 'Jackpot', rewardMult: 50, weight: 0.01, color: colorMap['Jackpot'] }
        ],
        addictionMechanics: {
          fakeLuckyStreak: 0,
          timeSpent: 0,
          forcedFOMO: null,
          calculateReward() {
            if (Math.random() < 0.4) {
              const nearMissSlot = this.outcomes[Math.floor(Math.random() * (this.outcomes.length - 3)) + 3];
              this.showToast(`So close to ${nearMissSlot.slot}! Try again!`, 'error');
              const slotElement = document.querySelector(`.slot[data-tooltip*="${nearMissSlot.slot}"]`);
              if (slotElement) {
                slotElement.classList.add('near-miss-flash');
                setTimeout(() => slotElement.classList.remove('near-miss-flash'), 800);
              }
            }
            const addictionFactor = 1 + (this.timeSpent * 0.01);
            return Math.random() < (0.15 * addictionFactor) ? this.forceWin() : this.generateLoss();
          },
          forceWin() {
            this.fakeLuckyStreak++;
            if (this.fakeLuckyStreak > 2) {
              setTimeout(() => this.showToast('So close! Deposit to continue streak!', 'error'), 3000);
            }
            return { slot: '2x', reward: '0.002 SOL' };
          },
          generateLoss() {
            this.fakeLuckyStreak = 0;
            return { slot: '0x', reward: '0 SOL' };
          },
          startFOMO() {
            this.forcedFOMO = setInterval(() => {
              const fakeUsers = ['ProGambler42', 'CryptoWhale', 'NFTKingpin'];
              const fakeWin = this.outcomes[Math.floor(Math.random() * (this.outcomes.length - 2)) + 2];
              this.communityMessages = [{
                id: Date.now(),
                username: fakeUsers[Math.floor(Math.random() * fakeUsers.length)],
                text: `just won ${fakeWin.rewardMult}x on ${fakeWin.slot}!`
              }, ...this.communityMessages.slice(0, 9)];
            }, 4000);
          }
        },
        init() {
          console.log('Initializing CryptoDrop App...');
          this.showLoader();
          try {
            this.walletAddress = localStorage.getItem(LS_PREFIX + 'walletAddress') || null;
            this.walletConnected = !!this.walletAddress;
            if (this.walletConnected) {
              this.connection = new SolanaWeb3.Connection(
                SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'),
                'confirmed'
              );
              this.getWalletBalance(this.walletAddress).catch(err => {
                console.error('Initial balance fetch failed:', err);
                this.showToast('Failed to load balance.', 'error');
              });
            }
          } catch (err) {
            console.error('Wallet init failed:', err);
            this.showToast('Wallet initialization error.', 'error');
            localStorage.removeItem(LS_PREFIX + 'walletAddress');
            this.walletConnected = false;
            this.walletAddress = null;
          }
          this.initSocket();
          this.initBoard();
          this.initParticles();
          this.initAudio();
          this.totalDrops = parseInt(localStorage.getItem(LS_PREFIX + 'totalDrops') || '0');
          this.plays = parseInt(localStorage.getItem(LS_PREFIX + 'plays') || '0');
          this.xp = parseInt(localStorage.getItem(LS_PREFIX + 'xp') || '0');
          this.level = Math.floor(this.xp / 100) + 1;
          this.loginStreak = parseInt(localStorage.getItem(LS_PREFIX + 'loginStreak') || '0');
          this.checkDailyLogin();
          this.updateBoardGlow();
          this.addictionMechanics.startFOMO();
          setTimeout(() => this.hideLoader(), 2000);
          setInterval(() => this.timeSpent += 10, 10000);
          setInterval(() => this.triggerJackpotEvent(), 900000);
          setInterval(() => this.triggerMultiplierBoost(), 300000);
          console.log('CryptoDrop App Initialized.');
        },
        showLoader() {
          const loader = document.createElement('div');
          loader.className = 'loader-orb';
          document.body.appendChild(loader);
        },
        hideLoader() {
          const loader = document.querySelector('.loader-orb');
          if (loader) loader.remove();
        },
        initSocket() {
          try {
            this.socket = io(BASE_URL, {
              auth: { token: localStorage.getItem(LS_PREFIX + 'authToken') },
              reconnectionAttempts: 5,
              transports: ['websocket']
            });
            this.socket.on('connect', () => {
              console.log('Socket connected:', this.socket.id);
              this.socket.emit('getRecentWins');
            });
            this.socket.on('disconnect', (reason) => {
              console.log('Socket disconnected:', reason);
              if (reason === 'io server disconnect') {
                this.showToast('Server disconnected.', 'error');
              }
            });
            this.socket.on('connect_error', (err) => {
              console.error('Socket connection error:', err.message, err.data);
              this.showToast(`Connection failed: ${err.message}`, 'error');
            });
            this.socket.on('dropResult', (data) => {
              console.log('Received dropResult:', data);
              const message = {
                id: data.timestamp || Date.now(),
                username: data.username === this.walletAddress ? 'You' : (data.username ? data.username.slice(0, 4) + '...' + data.username.slice(-4) : 'Guest'),
                text: `landed on ${data.slot}!`,
                reward: data.reward > 0 ? data.reward.toFixed(5) : null
              };
              this.communityMessages = [message, ...this.communityMessages.slice(0, 19)];
              this.scrollToChatBottom();
            });
            this.socket.on('recentWins', (wins) => {
              console.log('Received recent wins:', wins);
              this.communityMessages = wins.map(w => ({
                id: w.timestamp || Date.now(),
                username: w.username === this.walletAddress ? 'You' : (w.username ? w.username.slice(0, 4) + '...' + w.username.slice(-4) : 'Guest'),
                text: `landed on ${w.slot}!`,
                reward: w.reward > 0 ? w.reward.toFixed(5) : null
              })).slice(0, 20);
            });
          } catch (error) {
            console.error("Socket initialization failed:", error);
            this.showToast("Cannot connect to live feed.", "error");
          }
        },
        initBoard() {
          const boardContainer = this.$refs.plinkoBoardRef;
          if (!boardContainer) return;
          boardContainer.innerHTML = '';
          this.pegElements = [];
          this.slotElements = [];
          const boardWidth = boardContainer.clientWidth || this.BOARD_WIDTH;
          const boardHeight = this.BOARD_HEIGHT;
          this.boardRect = boardContainer.getBoundingClientRect();
          const rowHeight = boardHeight * 0.8 / (this.PEG_ROWS + 1);
          for (let i = 0; i < this.PEG_ROWS; i++) {
            const pegsInRow = i + 3;
            const y = rowHeight * (i + 1);
            const spacing = boardWidth / (pegsInRow + 1);
            for (let j = 0; j < pegsInRow; j++) {
              const x = spacing * (j + 1);
              const peg = document.createElement('div');
              peg.className = 'peg';
              peg.style.left = `${x - this.PEG_SIZE / 2}px`;
              peg.style.top = `${y - this.PEG_SIZE / 2}px`;
              boardContainer.appendChild(peg);
              this.pegElements.push({ element: peg, x, y, radius: this.PEG_SIZE / 2 });
            }
          }
          const totalSlotWidth = this.outcomes.length * this.SLOT_WIDTH;
          const totalSpacing = boardWidth - totalSlotWidth;
          const spacing = totalSpacing / (this.outcomes.length + 1);
          const slotContainer = boardContainer.querySelector('.slot-container') || document.createElement('div');
          if (!slotContainer.classList.contains('slot-container')) {
            slotContainer.className = 'slot-container';
            boardContainer.appendChild(slotContainer);
          } else {
            slotContainer.innerHTML = '';
          }
          this.outcomes.forEach((outcome, i) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            slot.style.backgroundColor = outcome.color || '#4B5563';
            slot.style.width = `${this.SLOT_WIDTH}px`;
            slot.style.height = `${this.SLOT_HEIGHT}px`;
            if (outcome.slot === 'Jackpot') {
              slot.classList.add('jackpot-pulse');
            }
            const label = document.createElement('span');
            label.className = 'slot-label';
            label.textContent = outcome.slot;
            slot.appendChild(label);
            const tooltip = document.createElement('div');
            tooltip.className = 'slot-tooltip';
            tooltip.innerHTML = `
              Multiplier: ${outcome.slot}<br>
              Reward: ${(this.betAmount * outcome.rewardMult).toFixed(5)} SOL<br>
              Chance: ~${(outcome.weight * 100).toFixed(1)}%
            `;
            slot.appendChild(tooltip);
            slotContainer.appendChild(slot);
            this.slotElements.push({ element: slot, outcome: outcome, index: i });
          });
        },
        initParticles() {
          const canvas = document.getElementById('particle-canvas');
          if (!canvas) return;
          this.particleCtx = canvas.getContext('2d');
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          const colors = ['#7B61FF', '#FF6BEC', '#61FF7B', '#FFB861', '#60A5FA'];
          this.particles = Array.from({ length: 80 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 2 + 0.5,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            baseVx: (Math.random() - 0.5) * 0.5,
            baseVy: (Math.random() - 0.5) * 0.5,
            color: colors[Math.floor(Math.random() * colors.length)],
            mass: Math.random() * 2 + 1
          }));
          const animateParticles = () => {
            if (!this.particleCtx) return;
            const ctx = this.particleCtx;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.particles.forEach(p => {
              const dx = this.mouseX - p.x;
              const dy = this.mouseY - p.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const maxDist = 150;
              if (distance < maxDist) {
                const force = (maxDist - distance) / maxDist;
                p.vx += (dx / distance) * force * 0.08;
                p.vy += (dy / distance) * force * 0.08;
              } else {
                p.vx += (p.baseVx - p.vx) * 0.01;
                p.vy += (p.baseVy - p.vy) * 0.01;
              }
              p.vx = Math.max(-2, Math.min(2, p.vx));
              p.vy = Math.max(-2, Math.min(2, p.vy));
              p.x += p.vx;
              p.y += p.vy;
              if (p.x < -p.radius) p.x = canvas.width + p.radius;
              if (p.x > canvas.width + p.radius) p.x = -p.radius;
              if (p.y < -p.radius) p.y = canvas.height + p.radius;
              if (p.y > canvas.height + p.radius) p.y = -p.radius;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.globalAlpha = Math.max(0.1, 1 - distance / (maxDist * 2));
              ctx.fill();
              ctx.globalAlpha = 1.0;
            });
            requestAnimationFrame(animateParticles);
          };
          animateParticles();
          window.addEventListener('resize', () => {
            if (!canvas) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          });
        },
        initAudio() {
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const loadSound = async (url, name) => {
              const response = await fetch(url);
              const arrayBuffer = await response.arrayBuffer();
              const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
              this.sounds[name] = audioBuffer;
            };
            Promise.all([
              loadSound('https://example.com/sounds/plink.mp3', 'plink'),
              loadSound('https://example.com/sounds/win.mp3', 'win'),
              loadSound('https://example.com/sounds/loss.mp3', 'loss'),
              loadSound('https://example.com/sounds/bigwin.mp3', 'bigwin'),
              loadSound('https://example.com/sounds/click.mp3', 'click')
            ]).catch(err => console.error('Sound loading failed:', err));
          } catch (err) {
            console.error('AudioContext initialization failed:', err);
          }
        },
        playSound(name) {
          if (!this.audioContext || !this.sounds[name]) return;
          const source = this.audioContext.createBufferSource();
          source.buffer = this.sounds[name];
          source.connect(this.audioContext.destination);
          source.start(0);
        },
        updateMousePos(event) {
          this.mouseX = event.clientX;
          this.mouseY = event.clientY;
        },
        handleScroll() {
          const controlsElement = document.getElementById('controls');
          if (!controlsElement) {
            this.showStickyButton = false;
            return;
          }
          const rect = controlsElement.getBoundingClientRect();
          this.showStickyButton = rect.bottom < 0;
        },
        async connectWallet(walletType) {
          this.showToast('Connecting wallet...', 'info');
          try {
            let provider;
            if (walletType === 'phantom' && ('phantom' in window) && window.phantom.solana) {
              provider = window.phantom.solana;
            } else if (walletType === 'solflare' && ('solflare' in window) && window.solflare) {
              provider = window.solflare;
            } else {
              this.showToast(`Wallet ${walletType} not found. Please install it.`, 'error');
              window.open(walletType === 'phantom' ? 'https://phantom.app/' : 'https://solflare.com/', '_blank');
              return;
            }
            if (!provider.isSolana) throw new Error('Selected provider is not a Solana wallet.');
            console.log(`Attempting to connect with ${walletType}`);
            const response = await provider.connect();
            const address = response.publicKey.toString();
            console.log('Wallet connected:', address);
            localStorage.setItem(LS_PREFIX + 'walletAddress', address);
            this.walletAddress = address;
            this.walletConnected = true;
            this.connection = new SolanaWeb3.Connection(
              SolanaWeb3.clusterApiUrl(BASE_URL.includes('localhost') ? 'devnet' : 'mainnet-beta'),
              'confirmed'
            );
            await this.getWalletBalance(address);
            this.showToast('Wallet connected!', 'success');
            this.closeModals();
            window.dispatchEvent(new CustomEvent('wallet-connected', { detail: { address } }));
            this.initBoard();
          } catch (err) {
            console.error('Wallet connection failed:', err);
            let message = 'Failed to connect wallet.';
            if (err.message.includes('User rejected')) {
              message = 'Connection request rejected.';
            } else if (err.message.includes('not found')) {
              message = `Please install ${walletType} wallet.`;
            }
            this.showToast(message, 'error');
            this.disconnectWallet();
          }
        },
        async getWalletBalance(address) {
          if (!address || !this.connection) {
            console.warn('Cannot fetch balance: No address or connection.');
            this.walletBalance = null;
            return;
          }
          try {
            console.log(`Fetching balance for ${address}...`);
            const publicKey = new SolanaWeb3.PublicKey(address);
            const balanceLamports = await this.connection.getBalance(publicKey);
            this.walletBalance = balanceLamports / SolanaWeb3.LAMPORTS_PER_SOL;
            console.log('Balance updated:', this.walletBalance);
            window.dispatchEvent(new CustomEvent('balance-updated', { detail: { balance: this.walletBalance } }));
          } catch (err) {
            console.error('Balance fetch failed:', err);
            this.showToast('Failed to fetch balance.', 'error');
            this.walletBalance = null;
          }
        },
        disconnectWallet() {
          try {
            if (window.phantom?.solana?.disconnect) window.phantom.solana.disconnect();
            if (window.solflare?.disconnect) window.solflare.disconnect();
          } catch (e) { console.warn("Error during wallet disconnect:", e); }
          localStorage.removeItem(LS_PREFIX + 'walletAddress');
          this.walletAddress = null;
          this.walletConnected = false;
          this.walletBalance = null;
          this.connection = null;
          this.showToast('Wallet disconnected.', 'info');
          this.closeModals();
          this.initBoard();
        },
        openBoardModal() { this.modalOpen = true; },
        openWalletModal() { this.walletModalOpen = true; },
        closeModals() {
          this.modalOpen = false;
          this.walletModalOpen = false;
        },
        selectBoard(board) {
          this.selectedBoard = board;
          this.dropResult = `Switched to ${board} board.`;
          this.closeModals();
          this.initBoard();
          this.showToast(`Switched to ${board} board`, 'info');
        },
        checkDailyLogin() {
          const lastLogin = localStorage.getItem(LS_PREFIX + 'lastLogin');
          const now = new Date();
          const today = now.toDateString();
          if (lastLogin !== today) {
            this.loginStreak = lastLogin ? this.loginStreak + 1 : 1;
            localStorage.setItem(LS_PREFIX + 'lastLogin', today);
            localStorage.setItem(LS_PREFIX + 'loginStreak', this.loginStreak.toString());
            this.showToast(`Day ${this.loginStreak} of 7 ‚Äì Claim your bonus drop tomorrow!`, 'success');
          }
        },
        triggerJackpotEvent() {
          this.showToast('Jackpot Round Begins in 2:00!', 'info');
          const countdown = document.createElement('div');
          countdown.className = 'addiction-timer';
          countdown.textContent = 'Jackpot Round: 2:00';
          document.body.appendChild(countdown);
          let timeLeft = 120;
          const interval = setInterval(() => {
            timeLeft--;
            countdown.textContent = `Jackpot Round: ${Math.floor(timeLeft / 60)}:${(timeLeft % 60).toString().padStart(2, '0')}`;
            if (timeLeft <= 0) {
              clearInterval(interval);
              countdown.remove();
              this.showToast('Jackpot Round Active!', 'success');
              setTimeout(() => this.showToast('Jackpot Round Ended!', 'info'), 60000);
            }
          }, 1000);
        },
        triggerMultiplierBoost() {
          this.showToast('Jackpot odds doubled for the next 60s!', 'success');
          const board = document.getElementById('plinko-board');
          board.classList.add('addiction-glow');
          setTimeout(() => board.classList.remove('addiction-glow'), 60000);
        },
        async dropOrb() {
          if (this.dropping) return;
          const stake = this.betAmount;
          if (stake < 0.001) {
            this.showToast('Minimum bet is 0.001 SOL.', 'error');
            return;
          }
          if (!this.walletConnected && this.faucetBalance < stake) {
            this.dropResult = 'Insufficient free mode balance.';
            this.showToast('Insufficient balance.', 'error');
            return;
          }
          if (this.walletConnected && (this.walletBalance === null || this.walletBalance < stake)) {
            this.dropResult = 'Insufficient SOL balance.';
            this.showToast('Insufficient SOL balance.', 'error');
            if (this.walletBalance === null) this.getWalletBalance(this.walletAddress);
            return;
          }
          this.dropping = true;
          this.totalDrops++;
          this.plays++;
          this.xp += 10;
          if (this.xp >= this.level * 100) {
            this.level++;
            this.showToast(`Level Up! You're now Level ${this.level}!`, 'success');
          }
          localStorage.setItem(LS_PREFIX + 'totalDrops', this.totalDrops.toString());
          localStorage.setItem(LS_PREFIX + 'plays', this.plays.toString());
          localStorage.setItem(LS_PREFIX + 'xp', this.xp.toString());
          this.triggerHaptic([30]);
          if (!this.walletConnected) {
            this.faucetBalance -= stake;
          } else {
            this.walletBalance -= stake;
          }
          const timer = document.createElement('div');
          timer.className = 'addiction-timer';
          timer.textContent = 'QUICK PLAY! BONUS ACTIVE!';
          document.body.appendChild(timer);
          setTimeout(() => timer.remove(), 2000);
          const progressBar = document.createElement('div');
          progressBar.className = 'faux-progress';
          this.$refs.plinkoBoardRef.appendChild(progressBar);
          setTimeout(() => progressBar.remove(), 2000);
          const boardElement = this.$refs.plinkoBoardRef;
          const anticipation = document.createElement('div');
          anticipation.className = 'anticipation-glow';
          boardElement.appendChild(anticipation);
          this.playSound('plink');
          await new Promise(resolve => setTimeout(resolve, 700));
          anticipation.remove();
          this.orbElement = document.createElement('div');
          this.orbElement.id = 'orb';
          let orbX = (boardElement.clientWidth || this.BOARD_WIDTH) / 2;
          let orbY = -10;
          this.orbElement.style.left = `${orbX - 8}px`;
          this.orbElement.style.top = `${orbY}px`;
          boardElement.appendChild(this.orbElement);
          let velocityX = (Math.random() - 0.5) * 2;
          let velocityY = 1;
          const gravity = 0.2;
          const bounceFactor = 0.6;
          let rotation = 0;
          if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);
          const animate = (timestamp) => {
            if (!this.dropping || !this.orbElement) return;
            velocityY += gravity;
            orbY += velocityY;
            orbX += velocityX;
            rotation += velocityX * 3;
            this.orbElement.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
            this.createOrbTrail(orbX, orbY);
            this.pegElements.forEach(peg => {
              const dx = orbX - peg.x;
              const dy = orbY - peg.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const combinedRadius = (this.orbElement.offsetWidth / 2) + peg.radius;
              if (distance < combinedRadius) {
                const overlap = combinedRadius - distance;
                const nx = dx / distance;
                const ny = dy / distance;
                orbX += nx * overlap * 0.5;
                orbY += ny * overlap * 0.5;
                const dotProduct = velocityX * nx + velocityY * ny;
                velocityX -= 2 * dotProduct * nx;
                velocityY -= 2 * dotProduct * ny;
                velocityX *= bounceFactor * (0.9 + Math.random() * 0.2);
                velocityY *= bounceFactor * (0.9 + Math.random() * 0.2);
                if (velocityY < -5) velocityY = -5;
                this.playSound('plink');
                this.triggerHaptic([10]);
              }
            });
            this.orbElement.style.left = `${orbX - this.orbElement.offsetWidth / 2}px`;
            this.orbElement.style.top = `${orbY}px`;
            if (orbY >= this.BOARD_HEIGHT - this.SLOT_HEIGHT) {
              const slotIndex = this.getSlotIndex(orbX);
              this.finishDrop(slotIndex);
              return;
            }
            if (orbY > this.BOARD_HEIGHT + 50) {
              console.warn("Orb fell out of bounds.");
              this.finishDrop(this.getSlotIndex(orbX));
              return;
            }
            this.currentAnimationId = requestAnimationFrame(animate);
          };
          this.currentAnimationId = requestAnimationFrame(animate);
          this.consecutivePlays++;
          this.updateBoardGlow();
        },
        createOrbTrail(x, y) {
          const trail = document.createElement('div');
          trail.className = 'orb-trail';
          trail.style.left = `${x - 6}px`;
          trail.style.top = `${y + this.orbElement.offsetHeight / 2 - 6}px`;
          this.$refs.plinkoBoardRef.appendChild(trail);
          trail.offsetHeight;
          trail.style.opacity = '0';
          trail.style.transform = 'scale(0.2)';
          setTimeout(() => trail.remove(), 800);
        },
        getSlotIndex(finalX) {
          const boardWidth = this.$refs.plinkoBoardRef.clientWidth || this.BOARD_WIDTH;
          const totalSlotWidth = this.outcomes.length * this.SLOT_WIDTH;
          const totalSpacing = boardWidth - totalSlotWidth;
          const spacing = totalSpacing / (this.outcomes.length + 1);
          let currentX = spacing;
          for (let i = 0; i < this.outcomes.length; i++) {
            const slotStartX = currentX;
            const slotEndX = currentX + this.SLOT_WIDTH;
            if (finalX >= slotStartX && finalX <= slotEndX) {
              return i;
            }
            currentX += this.SLOT_WIDTH + spacing;
          }
          return finalX < boardWidth / 2 ? 0 : this.outcomes.length - 1;
        },
        async finishDrop(slotIndex) {
          if (!this.dropping) return;
          if (this.currentAnimationId) cancelAnimationFrame(this.currentAnimationId);
          this.currentAnimationId = null;
          const winningSlotData = this.slotElements[slotIndex];
          const result = winningSlotData.outcome;
          const rewardValue = this.betAmount * result.rewardMult;
          await new Promise(resolve => setTimeout(resolve, 600));
          if (this.orbElement) {
            this.orbElement.remove();
            this.orbElement = null;
          }
          const slotElement = winningSlotData.element;
          slotElement.classList.add('winning');
          if (rewardValue > 0) {
            slotElement.style.backgroundColor = '#FFD700';
            setTimeout(() => slotElement.style.backgroundColor = result.color, 1200);
          } else {
            slotElement.style.opacity = '0.3';
            setTimeout(() => slotElement.style.opacity = '1', 1200);
          }
          setTimeout(() => slotElement.classList.remove('winning'), 800);
          if (rewardValue > 0) {
            this.playSound(rewardValue >= this.betAmount * 5 ? 'bigwin' : 'win');
            this.triggerHaptic([50, 30, 50]);
            this.createConfetti();
            if (rewardValue >= this.betAmount * 2) {
              const winText = document.createElement('div');
              winText.className = 'win-text';
              winText.textContent = rewardValue >= this.betAmount * 10 ? 'YOU BROKE THE GAME!' :
                                    rewardValue >= this.betAmount * 5 ? 'INSANE HIT!' : 'Let‚Äôs gooo!';
              document.body.appendChild(winText);
              setTimeout(() => winText.remove(), 1500);
            }
            if (!this.walletConnected) {
              this.faucetBalance += rewardValue;
            } else {
              this.walletBalance += rewardValue;
            }
            const explosion = document.createElement('div');
            explosion.className = 'reward-explosion';
            const slotRect = slotElement.getBoundingClientRect();
            const boardRect = this.$refs.plinkoBoardRef.getBoundingClientRect();
            const explosionX = slotRect.left + slotRect.width / 2 - boardRect.left;
            const explosionY = slotRect.top + slotRect.height / 2 - boardRect.top;
            explosion.style.left = `${explosionX - 50}px`;
            explosion.style.top = `${explosionY - 50}px`;
            explosion.style.background = `radial-gradient(circle, ${result.color} 20%, transparent 70%)`;
            this.$refs.plinkoBoardRef.appendChild(explosion);
            setTimeout(() => explosion.remove(), 800);
            if (rewardValue >= this.betAmount * 2) {
              setTimeout(() => this.showReplay(slotIndex), 1000);
            }
          } else {
            this.playSound('loss');
            this.triggerHaptic([20]);
          }
          this.dropResult = `Landed on <span style="color:${result.color}; font-weight: bold;">${result.slot}</span>! Won ${rewardValue.toFixed(5)} SOL`;
          if (rewardValue > 0.00001) {
            this.consecutiveWins++;
            this.lastWinTime = Date.now();
            this.consecutivePlays = 0;
            if (this.consecutiveWins > 1) {
              const streak = document.createElement('div');
              streak.className = 'win-streak';
              streak.innerHTML = `WIN STREAK! <span class="text-xl ml-1">x${this.consecutiveWins}</span>`;
              document.body.appendChild(streak);
              setTimeout(() => streak.remove(), 2500);
            }
            this.showToast(`Won ${rewardValue.toFixed(5)} SOL!`, 'success');
          } else {
            this.consecutiveWins = 0;
            this.showToast(`Landed on ${result.slot}`, 'info');
          }
          this.progress = (this.progress + Math.random() * 5 + 1) % 100;
          this.updateBoardGlow();
          const username = this.walletAddress ? this.walletAddress.slice(0, 4) + '...' + this.walletAddress.slice(-4) : 'Guest';
          if (this.socket?.connected) {
            this.socket.emit('dropResult', {
              username,
              board: this.selectedBoard,
              betAmount: this.betAmount,
              slot: result.slot,
              reward: rewardValue,
              timestamp: Date.now()
            });
          } else {
            const message = { id: Date.now(), username: 'You', text: `landed on ${result.slot}!`, reward: rewardValue > 0 ? rewardValue.toFixed(5) : null };
            this.communityMessages = [message, ...this.communityMessages.slice(0, 19)];
            this.scrollToChatBottom();
          }
          this.dropping = false;
          setTimeout(() => this.showAutoReplayPrompt(), 3000);
        },
        createConfetti() {
          for (let i = 0; i < 20; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = `${Math.random() * window.innerWidth}px`;
            confetti.style.backgroundColor = ['#f472b6', '#7b61ff', '#34d399'][Math.floor(Math.random() * 3)];
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 2000);
          }
        },
        showReplay(slotIndex) {
          const replay = document.createElement('div');
          replay.className = 'reward-explosion';
          const slotElement = this.slotElements[slotIndex].element;
          const slotRect = slotElement.getBoundingClientRect();
          const boardRect = this.$refs.plinkoBoardRef.getBoundingClientRect();
          const replayX = slotRect.left + slotRect.width / 2 - boardRect.left;
          const replayY = slotRect.top + slotRect.height / 2 - boardRect.top;
          replay.style.left = `${replayX - 50}px`;
          replay.style.top = `${replayY - 50}px`;
          replay.style.background = `radial-gradient(circle, ${this.slotElements[slotIndex].outcome.color} 20%, transparent 70%)`;
          replay.style.animationDuration = '1.5s';
          this.$refs.plinkoBoardRef.appendChild(replay);
          setTimeout(() => replay.remove(), 1500);
        },
        showAutoReplayPrompt() {
          if (this.dropping) return;
          const prompt = document.createElement('div');
          prompt.className = 'addiction-timer';
          prompt.textContent = 'Drop again? 5...';
          document.body.appendChild(prompt);
          let countdown = 5;
          const interval = setInterval(() => {
            countdown--;
            prompt.textContent = `Drop again? ${countdown}...`;
            if (countdown <= 0) {
              clearInterval(interval);
              prompt.remove();
              if (!this.dropping) this.dropOrb();
            }
          }, 1000);
        },
        updateBoardGlow() {
          const boardElement = document.getElementById('plinko-board');
          if (!boardElement) return;
          if (this.consecutivePlays > 0) {
            const intensity = Math.min(0.2 + (this.consecutivePlays * 0.05), 0.8);
            const spread = Math.min(15 + (this.consecutivePlays * 4), 40);
            boardElement.style.boxShadow = `0 0 ${spread}px rgba(123, 97, 255, ${intensity})`;
          } else {
            boardElement.style.boxShadow = 'none';
          }
        },
        triggerHaptic(pattern) {
          if ("vibrate" in navigator) {
            try {
              navigator.vibrate(pattern);
            } catch (e) {
              console.warn("Haptic feedback failed:", e);
            }
          }
        },
        scrollToChatBottom() {
          this.$nextTick(() => {
            const chatFeed = this.$refs.chatFeed;
            if (chatFeed) {
              chatFeed.scrollTop = 0;
            }
          });
        },
        showToast(message, type = 'info', duration = 3000) {
          const toastContainer = document.body;
          const toast = document.createElement('div');
          toast.className = `toast toast-${type}`;
          toast.textContent = message;
          toast.setAttribute('role', 'alert');
          toastContainer.appendChild(toast);
          setTimeout(() => {
            toast.style.animation = 'toastFadeOut 0.4s ease-out forwards';
            setTimeout(() => toast.remove(), 400);
          }, duration);
        }
      }));
    });
  </script>
  <style>
    @keyframes toastFadeOut {
      from { opacity: 1; transform: translate(-50%, 0); }
      to { opacity: 0; transform: translate(-50%, -10px); }
    }
  </style>
</body>
</html>