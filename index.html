<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>DegenDice - Slotana Style PvP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* 1. CSS Variables & Color Palette Enhancement */
        :root {
            --bg-dark: #0A0A0A;
            --bg-gradient-start: #0A0A0A;
            --bg-gradient-end: #1a0a1a;
            --accent-pink: #FF3366;
            --accent-green: #00FF99;
            --accent-purple: #9D4EDD;
            --accent-gold: #FFD700;
            --text-light: #FFFFFF;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.5);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-blur: blur(10px);
            --radius-lg: 20px;
            --radius-md: 12px;
            --radius-sm: 6px;
            --shadow-glow: 0 0 10px;
            --shadow-heavy: 0 8px 32px rgba(0, 0, 0, 0.4);
            --header-height: 60px;
            --leaderboard-width: 250px;
            --chat-height: 300px;
            --chat-width: 300px;
            --chat-bubble-size: 60px;
            --player-dice-color: #00FF99;
            --opponent-dice-color: #FF3366;
            --transition-fast: 0.2s ease;
            --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 2. Enhanced Background Gradient */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 50%, #2d1b69 100%);
            background-size: 400% 400%;
            animation: gradientAnimation 20s ease infinite;
            color: var(--text-light);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            padding-top: constant(safe-area-inset-top);
            padding-top: env(safe-area-inset-top);
            padding-bottom: constant(safe-area-inset-bottom);
            padding-bottom: env(safe-area-inset-bottom);
            overflow-x: hidden;
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            25% { background-position: 100% 0%; }
            50% { background-position: 100% 100%; }
            75% { background-position: 0% 100%; }
            100% { background-position: 0% 50%; }
        }

        /* 3. Glassmorphism Header */
        header {
            background: linear-gradient(145deg, rgba(255, 51, 102, 0.15), rgba(0, 255, 153, 0.1), rgba(157, 78, 221, 0.1));
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            padding: 0.5rem 1rem;
            height: var(--header-height);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 20;
            box-sizing: border-box;
            transition: var(--transition-smooth);
        }

        /* 4. Enhanced Logo with Gradient Text */
        .header-logo {
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(45deg, var(--accent-green), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(0, 255, 153, 0.3);
            letter-spacing: -1px;
            position: relative;
        }

        .header-logo::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-purple));
            border-radius: 1px;
            opacity: 0.7;
        }
        /* Added CSS for header-center */
        .header-center {
            flex: 0 0 auto; /* Change from flex: 1 to not take all space */
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 1rem; /* Add margins for spacing */
        }
        #header-balance {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            padding: 0.4rem 0.8rem; /* Reduce padding */
            border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
            font-weight: 600;
            font-size: 0.9rem; /* Reduce font size */
            display: none; /* Initially hidden */
        }
        #header-balance.connected {
            display: flex; /* Show when connected */
        }
        #header-balance i {
            font-size: 0.8rem; /* Smaller icon */
        }

        /* 5. Enhanced Wallet Info with Shimmer Effect */
        .wallet-info {
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            padding: 0.5rem 0.75rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
            transition: var(--transition-smooth);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .wallet-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .wallet-info:hover::before {
            left: 100%;
        }

        .wallet-info:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--accent-green);
            box-shadow: 0 0 20px rgba(0, 255, 153, 0.2);
            transform: translateY(-1px);
        }

        /* Existing styles */
        .header-actions-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .wallet-info i {
            color: var(--accent-green);
        }
        .profile-dropdown-container {
            position: relative;
            display: inline-block;
        }
        .profile-avatar {
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            border: 2px solid var(--accent-pink);
            box-shadow: var(--shadow-glow) var(--accent-pink);
            transition: all 0.2s ease;
        }
        .profile-avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-pink);
        }
        .profile-dropdown {
            display: none;
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            background-color: rgba(20, 20, 20, 0.95);
            min-width: 180px;
            box-shadow: var(--shadow-glow) rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            overflow: hidden;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .profile-dropdown.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        .profile-dropdown a {
            color: var(--text-light);
            padding: 12px 16px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.95rem;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .profile-dropdown a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--accent-green);
        }
        .profile-dropdown a i {
            width: 20px;
            text-align: center;
        }
        .hamburger-menu {
            display: none;
            cursor: pointer;
            font-size: 1.8rem;
            color: var(--text-light);
            z-index: 101;
            margin-left: 1rem;
        }
        .hamburger-menu.active .bar:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        .hamburger-menu.active .bar:nth-child(2) {
            opacity: 0;
        }
        .hamburger-menu.active .bar:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        .bar {
            width: 25px;
            height: 3px;
            background-color: var(--text-light);
            margin: 5px 0;
            transition: 0.4s;
        }
        .mobile-nav-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 90;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .mobile-nav-overlay.show {
            display: flex;
            opacity: 1;
        }
        .mobile-nav-overlay .nav-links {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            text-align: center;
        }
        .mobile-nav-overlay .nav-links a {
            color: var(--text-light);
            font-size: 1.8rem;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .mobile-nav-overlay .nav-links a:hover {
            color: var(--accent-green);
        }
        .close-menu-btn {
            position: absolute;
            top: 2rem;
            right: 2rem;
            color: var(--text-light);
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.2s ease, transform 0.2s ease;
            z-index: 100;
        }
        .close-menu-btn:hover {
            color: var(--accent-pink);
            transform: scale(1.1);
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            padding-top: calc(var(--header-height) + 2rem);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }

        .dice-area {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            position: relative;
        }

        /* 6. Enhanced Dice with 3D Effects */
        .dice {
            width: 100px;
            height: 100px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            border-radius: var(--radius-md);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            color: var(--bg-dark);
            box-shadow: 
                0 8px 32px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: var(--transition-smooth);
            position: relative;
            overflow: hidden;
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
        }

        .dice::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            opacity: 0;
            transition: opacity var(--transition-smooth);
        }

        .dice:hover::before {
            opacity: 1;
            animation: shine 1.5s ease-in-out;
        }

        @keyframes shine {
            0% { transform: rotate(45deg) translateX(-100%); }
            100% { transform: rotate(45deg) translateX(100%); }
        }

        /* 7. Enhanced Player & Opponent Dice */
        .player-dice {
            background: linear-gradient(145deg, var(--player-dice-color), rgba(0, 255, 153, 0.8));
            color: var(--bg-dark);
            box-shadow: 
                0 0 30px rgba(0, 255, 153, 0.4),
                0 8px 32px rgba(0, 255, 153, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .opponent-dice {
            background: linear-gradient(145deg, var(--opponent-dice-color), rgba(255, 51, 102, 0.8));
            color: var(--bg-dark);
            box-shadow: 
                0 0 30px rgba(255, 51, 102, 0.4),
                0 8px 32px rgba(255, 51, 102, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .vs-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: var(--text-light);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            opacity: 0;
            animation: fadeInOut 1.5s ease-in-out forwards;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* 8. Glassmorphism Controls Panel */
        .controls {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            padding: 1.5rem; /* Reduced from 2rem */
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Reduced from 1.5rem */
            box-shadow: var(--shadow-heavy);
            position: relative;
            overflow: hidden;
        }

        .controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-green), transparent);
            opacity: 0.6;
        }

        /* Existing styles for controls */
        .mode-toggle {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
       .mode-toggle button {
  flex: 1;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 110px;
}

        .mode-toggle button.active {
            background-color: var(--accent-green);
            box-shadow: var(--shadow-glow) var(--accent-green);
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, var(--accent-pink), var(--accent-green));
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: var(--text-light);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-glow) var(--accent-pink);
        }
        .multiplier-display {
            font-size: 1.5rem;
            font-weight: 700;
            text-align: center;
            color: var(--accent-green);
            text-shadow: var(--shadow-glow) var(--accent-green);
        }
        .roll-mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.25rem;
            border-radius: var(--radius-md);
        }
        .roll-mode-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .roll-mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }
        .roll-mode-btn.active {
            background: var(--accent-pink);
            color: white;
            box-shadow: var(--shadow-glow) rgba(255, 51, 102, 0.3);
        }
        .roll-mode-btn i {
            font-size: 0.8rem;
        }
        .bet-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            justify-content: center;
        }
        .chip-buttons-row {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }
        .chip-btn {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            flex: 1;
            min-width: 60px;
        }
        .chip-btn.active {
            background-color: var(--accent-pink);
            box-shadow: var(--shadow-glow) var(--accent-pink);
        }
        .custom-bet-container {
            display: flex;
            align-items: center;
            gap: 0.75rem; /* Reduced from 1rem */
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem; /* Reduced from 0.75rem */
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .custom-bet-input-wrapper {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            flex: 1;
        }
        .custom-bet-input {
            background: transparent;
            border: none;
            color: var(--text-light);
            font-size: 1rem; /* Reduced from 1.1rem */
            font-weight: 600;
            padding: 0.5rem 0.75rem; /* Reduced from 0.75rem 1rem */
            outline: none;
            width: 100%;
            min-width: 0;
        }
        .custom-bet-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-weight: 400;
        }
        .custom-bet-input:focus {
            background: rgba(255, 255, 255, 0.05);
        }
        .clear-bet-btn {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            border: none;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
        }
        .clear-bet-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-light);
        }
        .balance-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem 1rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .balance-display:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .balance-display i.fa-coins {
            color: #FFD700;
            font-size: 1rem;
        }
        #balance-amount {
            font-weight: 700;
            color: var(--accent-green);
            font-size: 1rem;
            letter-spacing: 0.5px;
        }
        .balance-dropdown-icon {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }
        .balance-display:hover .balance-dropdown-icon {
            transform: rotate(180deg);
        }
        .custom-bet-input::-webkit-outer-spin-button,
        .custom-bet-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .custom-bet-input[type=number] {
            -moz-appearance: textfield;
        }

        /* 9. Enhanced Button Styles */
        button {
            background: linear-gradient(145deg, var(--glass-bg), rgba(255, 255, 255, 0.08));
            color: var(--text-light);
            border: 1px solid var(--glass-border);
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-smooth);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.3s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border-color: var(--accent-green);
            box-shadow: 0 0 20px rgba(0, 255, 153, 0.2);
            transform: translateY(-2px);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* 10. Enhanced Roll Button */
        .roll-btn {
            background: linear-gradient(145deg, var(--accent-pink), rgba(255, 51, 102, 0.8));
            color: white;
            border: none;
            font-weight: 700;
            font-size: 1.1rem;
            padding: 1rem 2rem;
            box-shadow: 
                0 0 30px rgba(255, 51, 102, 0.3),
                0 8px 32px rgba(255, 51, 102, 0.2);
        }

        .roll-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, rgba(255, 51, 102, 0.9), var(--accent-pink));
            transform: translateY(-3px);
            box-shadow: 
                0 0 40px rgba(255, 51, 102, 0.5),
                0 12px 40px rgba(255, 51, 102, 0.3);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 
                    0 0 40px rgba(255, 51, 102, 0.5),
                    0 12px 40px rgba(255, 51, 102, 0.3);
            }
            50% { 
                box-shadow: 
                    0 0 60px rgba(255, 51, 102, 0.7),
                    0 16px 48px rgba(255, 51, 102, 0.4);
            }
        }

        /* Existing styles for results and effects */
        .result-display {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 1rem;
            text-align: center;
            min-height: 3rem;
        }
        .win {
            color: var(--accent-green);
            animation: scale 0.5s;
        }
        .loss {
            color: var(--accent-pink);
            animation: shake 0.3s;
        }
        @keyframes scale {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 153, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 72px;
            color: var(--accent-green);
            animation: flash 0.5s;
            pointer-events: none;
            z-index: 100;
        }
        .loss-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 51, 102, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 72px;
            color: var(--accent-pink);
            animation: flash 0.5s;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        .streak-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem 2rem;
            border-radius: var(--radius-md);
            font-size: 48px;
            color: var(--accent-pink);
            animation: scale 0.5s;
            z-index: 101;
        }
        .recent-wins {
            position: fixed;
            bottom: 1rem;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 0;
            z-index: 10;
        }
        .recent-wins span {
            display: inline-block;
            padding-left: 100%;
            animation: slide-left 15s linear infinite;
        }
        @keyframes slide-left {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }
        .hot-streak {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-pink);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-weight: 700;
            z-index: 10;
        }
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        .modal-content {
            background-color: var(--bg-dark);
            padding: 2rem;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-glow) rgba(255, 255, 255, 0.1);
            /* Updated max-width for profile modal */
            max-width: 500px; 
            width: 90%;
            text-align: center;
            position: relative;
            animation: slideInFromTop 0.3s ease;
        }
        .modal-content h2 {
            margin-top: 0;
            color: var(--accent-green);
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-button:hover,
        .close-button:focus {
            color: var(--text-light);
            text-decoration: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .wallet-options button {
            display: block;
            width: 100%;
            margin-bottom: 1rem;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            padding: 1rem;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 1rem;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .wallet-options button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .wallet-options button img {
            width: 24px;
            height: 24px;
        }
        /* Leaderboard CSS rules */
        .leaderboard-content {
            width: 100%;
            max-width: 100%;
            margin: 0;
            padding: 2rem 1rem;
            box-sizing: border-box;
        }
        .leaderboard-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .leaderboard-header h2 {
            font-size: 2.5rem;
            color: var(--accent-gold);
            margin-bottom: 0.5rem;
        }
        .leaderboard-subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            margin: 0;
        }
        .leaderboard-container {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            padding: 1.5rem;
            box-shadow: var(--shadow-heavy);
        }
        .leaderboard-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-width: 600px;
            margin: 0 auto;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.02);
            text-align: center; /* Add this line */
        }
        .leaderboard-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        /* End Leaderboard CSS rules */

        .leaderboard-item .player-info {
            display: flex;
            align-items: center;
            gap: 0.75rem; /* Increase gap slightly */
            flex: 1; /* Add this to take available space */
            justify-content: flex-start; /* Ensure left alignment */
        }
        .leaderboard-item .player-info .avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
        }
        .leaderboard-item .player-info .username {
            flex: 1; /* Add this to center the username */
            text-align: left; /* Keep username left-aligned within its space */
        }
        .leaderboard-item .wins {
            font-weight: 700;
            color: var(--accent-green);
            text-align: right; /* Ensure wins stay right-aligned */
        }
        .leaderboard-item.fade-in {
            animation: fadeIn 0.5s ease;
        }
        .leaderboard-item.pulse {
            animation: pulse 1s infinite;
        }
#leaderboard-mode-btn {
  padding-left: 1rem !important;
  padding-right: 1rem !important;
}
        .chat-container {
            position: fixed;
            bottom: calc(1rem + constant(safe-area-inset-bottom));
            bottom: calc(1rem + env(safe-area-inset-bottom));
            right: 1rem;
            width: var(--chat-width);
            height: var(--chat-height);
            background: rgba(20, 20, 20, 0.9);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-glow) rgba(255, 255, 255, 0.1);
            z-index: 100;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease-in-out;
        }
        .chat-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .chat-header i.rotated {
            transform: rotate(180deg);
        }
        .chat-body {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-pink) transparent;
        }
        .chat-body::-webkit-scrollbar {
            width: 6px;
        }
        .chat-body::-webkit-scrollbar-track {
            background: transparent;
        }
        .chat-body::-webkit-scrollbar-thumb {
            background-color: var(--accent-pink);
            border-radius: 3px;
        }
        .chat-message {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.5rem;
            border-radius: var(--radius-sm);
            word-break: break-word;
        }
        .chat-message .username {
            font-weight: 700;
            color: var(--accent-green);
            margin-right: 0.5rem;
        }
        .chat-input-area {
            display: flex;
            padding: 0.75rem;
            gap: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .chat-input-area input[type="text"] {
            flex: 1;
            padding: 0.5rem;
            border-radius: var(--radius-sm);
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            outline: none;
        }
        .chat-input-area input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .chat-input-area button {
            padding: 0.5rem 1rem;
            background-color: var(--accent-pink);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 700;
        }
        .chat-input-area button:hover {
            background-color: #ff6699;
        }
        .chat-toggle-btn {
            display: none;
            position: fixed;
            bottom: calc(1rem + constant(safe-area-inset-bottom));
            bottom: calc(1rem + env(safe-area-inset-bottom));
            right: 1rem;
            background-color: var(--accent-pink);
            color: white;
            width: var(--chat-bubble-size);
            height: var(--chat-bubble-size);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            box-shadow: var(--shadow-glow) var(--accent-pink);
            z-index: 110;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
        }
        body.chat-open .chat-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0;
            background: var(--bg-dark);
            z-index: 1000;
        }
        body.chat-open .chat-toggle-btn {
            display: none;
        }
        body.chat-open .chat-header i {
            transform: rotate(180deg);
        }
        .profile-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }
        .profile-options label {
            text-align: left;
            font-weight: 700;
        }
        .profile-options input[type="text"] {
             padding: 0.75rem;
             border-radius: var(--radius-sm);
             border: 1px solid rgba(255, 255, 255, 0.1);
             background-color: rgba(255, 255, 255, 0.05);
             color: var(--text-light);
             outline: none;
        }
        .profile-section { /* NEW: Styling for sections within profile modal */
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .profile-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        /* Profile Modal specific CSS */
        .profile-modal-content {
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .modal-header h2 {
            margin: 0;
            color: var(--accent-green);
        }
        .update-btn {
            background: var(--accent-green);
            color: var(--bg-dark);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            font-weight: 700;
            cursor: pointer;
        }
        .avatar-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
            gap: 8px;
            margin: 1rem 0;
            max-width: 100%;
            overflow: hidden;
        }
        .avatar-option {
            width: 50px;
            height: 50px;
            font-size: 1.8rem;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        @media (max-width: 768px) {
            .avatar-selection-grid {
                grid-template-columns: repeat(6, 1fr);
                gap: 6px;
            }
            .avatar-option {
                width: 45px;
                height: 45px;
                font-size: 1.5rem;
            }
            .profile-modal-content {
                padding: 1rem;
                margin: 1rem;
            }
        }
        /* End Profile Modal specific CSS */
        .transaction-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }
        .transaction-options input[type="number"] {
            padding: 0.75rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-light);
            outline: none;
        }
        .transaction-options button {
            background-color: var(--accent-green);
            color: var(--bg-dark);
            font-weight: 700;
        }
        .transaction-options button:hover {
            background-color: #33ffb3;
        }
        .daily-challenge-panel {
            background: rgba(20, 20, 20, 0.9);
            padding: 1rem;
            border-radius: var(--radius-md);
            margin-top: 2rem;
            text-align: center;
            border: 1px solid var(--accent-green);
            animation: pulseBorder 2s infinite;
        }
        @keyframes pulseBorder {
            0%, 100% { border-color: var(--accent-green); }
            50% { border-color: rgba(0, 255, 153, 0.5); }
        }
        .daily-challenge-panel h4 {
            margin-top: 0;
            color: var(--accent-green);
        }
        .daily-challenge-panel .progress {
            margin: 0.5rem 0;
        }
        .daily-challenge-panel button {
            background-color: var(--accent-pink);
            color: white;
            margin-top: 1rem;
        }
        /* Removed referral-feature positioning CSS as it's now in modal */
        .referral-feature {
            background: rgba(20, 20, 20, 0.9);
            padding: 1rem;
            border-radius: var(--radius-md);
            /* margin-top: 2rem; Removed from here, handled by profile-section */
            text-align: center;
            border: 1px solid var(--accent-pink);
        }
        .referral-feature h4 {
            margin-top: 0;
            color: var(--accent-pink);
        }
        .referral-code {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0.5rem 0;
            color: var(--accent-green);
        }
        .referral-feature button {
            background-color: var(--accent-green);
            color: var(--bg-dark);
            margin-top: 1rem;
        }
        button:active:not(:disabled) {
            transform: scale(0.95);
        }
        .duel-info {
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-light);
        }
        .pot-display {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-green);
            text-shadow: var(--shadow-glow) var(--accent-green);
            margin-bottom: 1rem;
        }
        .duel-history {
            background: rgba(20, 20, 20, 0.8);
            padding: 1rem;
            border-radius: var(--radius-md);
            width: 100%;
            max-width: 500px;
            margin-top: 2rem;
        }
        .duel-history h4 {
            margin-top: 0;
            color: var(--accent-pink);
            text-align: center;
            margin-bottom: 1rem;
        }
        .duel-history-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 150px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-pink) transparent;
        }
        .duel-history-list::-webkit-scrollbar {
            width: 6px;
        }
        .duel-history-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .duel-history-list::-webkit-scrollbar-thumb {
            background-color: var(--accent-pink);
            border-radius: 3px;
        }
        .duel-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.9rem;
        }
        .duel-history-item:last-child {
            border-bottom: none;
        }
        .duel-history-item.win-entry {
            color: var(--accent-green);
        }
        .duel-history-item.loss-entry {
            color: var(--accent-pink);
        }

        /* 11. Add Floating Particles & Enhanced Animations */
        /* Modern Floating Elements */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            background: rgba(0, 255, 153, 0.1);
            border-radius: 50%;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { 
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { 
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Stats Display Enhancement */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            /* margin-bottom: 2rem; Removed from here, handled by profile-section */
        }

        .stat-card {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1rem;
            text-align: center;
            transition: var(--transition-smooth);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-green);
            box-shadow: 0 8px 32px rgba(0, 255, 153, 0.1);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--accent-green);
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Animations for Dice Rolling */
        @keyframes dice-roll {
            0% { transform: rotateX(0) rotateY(0); }
            25% { transform: rotateX(90deg) rotateY(90deg) scale(1.1); }
            50% { transform: rotateX(180deg) rotateY(180deg) scale(0.9); }
            75% { transform: rotateX(270deg) rotateY(270deg) scale(1.1); }
            100% { transform: rotateX(360deg) rotateY(360deg) scale(1); }
        }

        .dice.rolling {
            animation: dice-roll 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* Sound Wave Visualization */
        .sound-waves {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            opacity: 0;
            pointer-events: none;
        }

        .sound-waves.active {
            opacity: 1;
            animation: sound-pulse 1s ease-out;
        }

        .wave {
            position: absolute;
            border: 2px solid var(--accent-green);
            border-radius: 50%;
            animation: wave-expand 1s ease-out infinite;
        }

        .wave:nth-child(1) { animation-delay: 0s; }
        .wave:nth-child(2) { animation-delay: 0.2s; }
        .wave:nth-child(3) { animation-delay: 0.4s; }

        @keyframes wave-expand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        @keyframes sound-pulse {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Live Activity Feed */
        .live-feed {
            position: fixed;
            top: calc(var(--header-height) + 1rem);
            left: 1rem;
            width: 300px;
            max-height: 200px;
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            overflow: hidden;
            z-index: 5;
            display: none;
        }

        .live-feed.show {
            display: block;
            animation: slideInLeft 0.3s ease;
        }

        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .feed-header {
            padding: 0.75rem 1rem;
            background: rgba(0, 255, 153, 0.1);
            border-bottom: 1px solid var(--glass-border);
            font-weight: 600;
            font-size: 0.9rem;
        }

        .feed-content {
            max-height: 150px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-green) transparent;
        }

        .feed-item {
            padding: 0.5rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.8rem;
            animation: fadeIn 0.5s ease;
        }

        .feed-item:last-child {
            border-bottom: none;
        }

        .feed-item.win {
            color: var(--accent-green);
        }

        .feed-item.loss {
            color: var(--text-secondary);
        }

        /* Enhanced Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .tooltip:hover::after,
        .tooltip:hover::before {
            opacity: 1;
        }

        /* 13. Mobile Responsive Updates */
        @media (max-width: 768px) {
            header {
                padding: 0.5rem 1rem;
                justify-content: space-between;
            }
            .header-logo {
                font-size: 1.5rem;
            }
            .header-actions-right .wallet-info {
                display: none; /* Hide wallet info on mobile, only show balance */
            }
            .header-actions-right .profile-dropdown-container {
                display: none;
            }
            .hamburger-menu {
                display: block;
                margin-left: auto;
            }
            
            .hot-streak {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.9rem;
                padding: 0.4rem 0.8rem;
                white-space: nowrap;
            }

            .header-left, .header-right {
                gap: 0.5rem;
            }
            .wallet-info {
                font-size: 12px;
            }
            header button {
                padding: 0.5rem 0.8rem;
                font-size: 0.8rem;
            }
            .dice {
                width: 80px;
                height: 80px;
                font-size: 2.5rem;
            }
            .dice-area {
                gap: 1rem;
            }
            .controls {
                padding: 1rem;
            }
            .multiplier-display {
                font-size: 1.2rem;
            }
            .roll-mode-btn {
                padding: 0.6rem 0.8rem;
                font-size: 0.8rem;
            }
            .roll-mode-btn i {
                font-size: 0.7rem;
            }
            .bet-controls {
                gap: 0.5rem;
            }
            button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .result-display {
                font-size: 1.5rem;
                min-height: 2.5rem;
            }
            .leaderboard-content {
                width: 100%;
                /* No need for transform: translateX(100%) here as it's now a tabbed content */
            }
            body.leaderboard-open .leaderboard-content {
                /* This class is no longer relevant for tabbed content */
            }
            .chat-container {
                width: var(--chat-bubble-size);
                height: var(--chat-bubble-size);
                bottom: calc(1rem + constant(safe-area-inset-bottom));
                bottom: calc(1rem + env(safe-area-inset-bottom));
                right: 1rem;
                border-radius: 50%;
                box-shadow: var(--shadow-glow) var(--accent-pink);
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: hidden;
                cursor: pointer;
                background: var(--accent-pink);
                transition: all 0.3s ease-in-out;
            }
            .chat-container .chat-header,
            .chat-container .chat-body,
            .chat-container .chat-input-area {
                display: none;
            }
            body.chat-open .chat-container {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                border-radius: 0 !important;
                background: var(--bg-dark) !important;
                z-index: 1000 !important;
                display: flex !important;
                flex-direction: column !important;
                box-shadow: none !important;
                cursor: default !important;
            }
            body.chat-open .chat-container .chat-header,
            body.chat-open .chat-container .chat-body,
            body.chat-open .chat-container .chat-input-area {
                display: flex !important;
            }
            body.chat-open .chat-container #chat-bubble-icon {
                display: none !important;
            }
            body.chat-open .chat-header {
                padding-top: constant(safe-area-inset-top);
                padding-top: env(safe-area-inset-top);
            }
            body.chat-open .chat-input-area {
                padding-bottom: constant(safe-area-inset-bottom);
                padding-bottom: env(safe-area-inset-bottom);
            }
            .chat-toggle-btn {
                display: none;
            }
            .custom-bet-container {
                flex-direction: column;
                gap: 0.75rem;
                padding: 1rem;
            }
            .custom-bet-input-wrapper {
                width: 100%;
            }
            .balance-display {
                width: 100%;
                justify-content: center;
                padding: 1rem;
            }
            .chip-buttons-row {
                gap: 0.25rem;
            }
            .chip-btn {
                min-width: 50px;
                padding: 0.5rem 0.75rem;
                font-size: 0.85rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .streak-popup {
                font-size: 36px;
                padding: 0.75rem 1.5rem;
            }

            /* Removed mobile-specific stats grid rules */
            /* .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
                margin-bottom: 1.5rem;
            }
            
            .stat-card {
                padding: 0.75rem;
            }
            
            .stat-value {
                font-size: 1.2rem;
            }
            
            .stat-label {
                font-size: 0.75rem;
            } */
            
            /* Removed mobile-quick-actions display rule */
            /* .mobile-quick-actions {
                display: block;
            } */
            
            .live-feed {
                display: none !important;
            }
        }

        /* Add to CSS */
        .stake-display {
            display: flex;
            justify-content: space-around;
            margin: 1rem 0;
            font-size: 1.1rem;
        }
        #result-modal .modal-content {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .win { color: var(--accent-green); }
        .loss { color: var(--accent-pink); }

        /* AUTO-BET FEATURE STYLES */
        .auto-bet-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .auto-bet-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem 1rem;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .auto-bet-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .auto-bet-toggle.active {
            background-color: var(--accent-purple);
            box-shadow: var(--shadow-glow) var(--accent-purple);
        }
        .auto-bet-toggle .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
        }
        .auto-bet-toggle .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .auto-bet-toggle .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .auto-bet-toggle .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        .auto-bet-toggle input:checked + .slider {
            background-color: var(--accent-green);
        }
        .auto-bet-toggle input:checked + .slider:before {
            transform: translateX(16px);
        }
        .auto-bet-settings {
            display: none;
            flex-direction: column;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }
        .auto-bet-settings.show {
            display: flex;
        }
        .auto-bet-settings label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .auto-bet-settings input[type="number"] {
            width: 80px;
            padding: 0.4rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            text-align: center;
        }
        .auto-bet-progress {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
        }
        .auto-bet-progress strong {
            color: var(--accent-green);
        }

        /* SOUND SETTINGS STYLES */
        .settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
        }
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .settings-section h3 {
            color: var(--accent-green);
            margin-top: 0;
            margin-bottom: 1rem;
            text-align: center;
        }
        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }
        .setting-item label {
            font-weight: 600;
        }
        .setting-item input[type="range"] {
            width: 150px;
            margin-left: 1rem;
        }
        .setting-item .switch {
            margin-left: 1rem;
        }

        /* NOTIFICATION SYSTEM STYLES */
        #notification-container {
            position: fixed;
            top: 70px; /* Below header */
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Allow clicks to pass through container */
        }
        .toast-notification {
            background-color: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 15px 20px;
            border-radius: var(--radius-md);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 280px;
            max-width: 350px;
            opacity: 0;
            transform: translateX(100%);
            animation: slideInRight 0.4s forwards, fadeOut 0.5s forwards 4.5s;
            pointer-events: auto; /* Enable clicks on individual toasts */
            border-left: 5px solid;
            position: relative;
            overflow: hidden;
        }
        .toast-notification.success { border-color: var(--accent-green); }
        .toast-notification.error { border-color: var(--accent-pink); }
        .toast-notification.warning { border-color: var(--accent-gold); }
        .toast-notification.info { border-color: var(--accent-purple); }

        .toast-notification i {
            font-size: 1.5rem;
        }
        .toast-notification .content {
            flex-grow: 1;
        }
        .toast-notification .title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .toast-notification .message {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .toast-notification .actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .toast-notification .action-btn {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s ease;
        }
        .toast-notification .action-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .toast-notification .close-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.2rem;
            cursor: pointer;
            position: absolute;
            top: 8px;
            right: 8px;
        }
        .toast-notification .close-btn:hover {
            color: white;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* PROVABLY FAIR MODAL STYLES */
        #provably-fair-modal .modal-content {
            max-width: 600px;
            text-align: left;
        }
        #provably-fair-modal input[type="text"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-family: monospace;
            word-break: break-all;
        }
        #provably-fair-modal .seed-pair {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
        }
        #provably-fair-modal .seed-pair p {
            margin: 5px 0;
            font-size: 0.9rem;
        }
        #provably-fair-modal .seed-pair strong {
            color: var(--accent-green);
        }
        #provably-fair-modal .info-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 15px;
        }
        #provably-fair-modal .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        /* FRIENDS SECTION STYLES */
        .friends-list-container {
            margin-top: 1.5rem;
        }
        .friends-list-container h3 {
            text-align: center;
            color: var(--accent-purple);
            margin-bottom: 1rem;
        }
        .friends-search-bar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .friends-search-bar input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-light);
            outline: none;
        }
        .friends-search-bar button {
            padding: 0.75rem 1rem;
            background-color: var(--accent-purple);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        .friends-list {
            list-style: none;
            padding: 0;
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-purple) transparent;
        }
        .friends-list::-webkit-scrollbar {
            width: 6px;
        }
        .friends-list::-webkit-scrollbar-track {
            background: transparent;
        }
        .friends-list::-webkit-scrollbar-thumb {
            background-color: var(--accent-purple);
            border-radius: 3px;
        }
        .friend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.75rem;
            border-radius: var(--radius-md);
            margin-bottom: 0.5rem;
            transition: background-color 0.2s ease;
        }
        .friend-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .friend-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .friend-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
        }
        .friend-name {
            font-weight: 600;
        }
        .friend-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .friend-status.online {
            color: var(--accent-green);
        }
        .friend-actions button {
            padding: 0.5rem 0.8rem;
            font-size: 0.8rem;
            border-radius: var(--radius-sm);
            margin-left: 0.5rem;
        }
        .friend-actions .duel-btn {
            background-color: var(--accent-pink);
        }
        .friend-actions .remove-btn {
            background-color: rgba(255, 51, 102, 0.3);
            border-color: var(--accent-pink);
        }
        .add-friend-input-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .add-friend-input-group input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-light);
            outline: none;
        }
        .add-friend-input-group button {
            padding: 0.75rem 1rem;
            background-color: var(--accent-green);
            color: var(--bg-dark);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        /* HISTORY/RECORDS SECTION STYLES */
        .history-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .history-tabs button {
            flex: 1;
            padding: 0.75rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s ease, border-bottom 0.2s ease;
            border-bottom: 3px solid transparent;
            border-radius: 0; /* Override default button border-radius */
        }
        .history-tabs button.active {
            color: var(--accent-green);
            border-bottom-color: var(--accent-green);
        }
        .history-content {
            display: none;
        }
        .history-content.active {
            display: block;
        }
        .game-history-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .game-history-filters select,
        .game-history-filters input {
            padding: 0.5rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            outline: none;
            flex: 1;
            min-width: 120px;
        }
        .game-history-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        .game-history-table th,
        .game-history-table td {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            text-align: left;
        }
        .game-history-table th {
            color: var(--accent-green);
            font-weight: 700;
            background-color: rgba(255, 255, 255, 0.03);
        }
        .game-history-table tr:last-child td {
            border-bottom: none;
        }
        .game-history-table .win-entry {
            color: var(--accent-green);
        }
        .game-history-table .loss-entry {
            color: var(--accent-pink);
        }
        .game-history-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 1rem;
        }
        .game-history-pagination button {
            padding: 0.5rem 1rem;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
        }
        .game-history-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .personal-records-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        .record-card {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1rem;
            text-align: center;
        }
        .record-card .value {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent-gold);
            margin-bottom: 0.25rem;
        }
        .record-card .label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        /* AVATAR SELECTION STYLES */
        .avatar-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }
        .avatar-option:hover {
            border-color: var(--accent-green);
            box-shadow: 0 0 10px rgba(0, 255, 153, 0.3);
        }
        .avatar-option.selected {
            border-color: var(--accent-pink);
            box-shadow: 0 0 15px var(--accent-pink);
            transform: scale(1.1);
        }
        .custom-avatar-input-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .custom-avatar-input-group input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-light);
            outline: none;
        }
        .custom-avatar-input-group button {
            padding: 0.75rem 1rem;
            background-color: var(--accent-green);
            color: var(--bg-dark);
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        .avatar-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.1);
            display: inline-flex; /* Use inline-flex to keep it inline with text */
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            vertical-align: middle; /* Align with middle of text */
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="floating-particles" id="floating-particles"></div>

    <header>
        <div class="header-logo">
            DegenDice
        </div>
        <div class="header-center">
            <div class="balance-display connected" id="header-balance">
                <i class="fas fa-coins"></i>
                <span id="balance-amount">SOL 1000.000</span>
                <i class="fas fa-sync-alt balance-refresh-icon" id="balance-refresh-icon" title="Refresh Balance"></i>
            </div>
        </div>
        <div class="header-actions-right">
            <div class="wallet-info" id="wallet-info">
                <i class="fas fa-wallet"></i> Wallet: Not connected
            </div>
            <div class="profile-dropdown-container">
                <div class="profile-avatar" id="profile-avatar-new">
                    <i class="fas fa-user-circle"></i>
                </div>
                <div class="profile-dropdown" id="profile-dropdown">
                    <a href="#" id="dropdown-profile-btn"><i class="fas fa-user"></i> Profile</a>
                    <a href="#" id="dropdown-deposit-btn"><i class="fas fa-plus-circle"></i> Deposit</a>
                    <a href="#" id="dropdown-withdraw-btn"><i class="fas fa-minus-circle"></i> Withdraw</a>
                    <a href="#" id="dropdown-provably-fair-btn"><i class="fas fa-shield-alt"></i> Provably Fair</a>
                    <a href="#" id="dropdown-settings-btn"><i class="fas fa-cog"></i> Settings</a>
                    <a href="#" id="dropdown-history-btn"><i class="fas fa-history"></i> History</a>
                    <a href="#" id="dropdown-disconnect-btn"><i class="fas fa-power-off"></i> Disconnect</a>
                </div>
            </div>
        </div>
        <div class="hamburger-menu" id="hamburger-menu">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div class="hot-streak" id="hot-streak">
            🔥 Hot Streak! 5 Wins
        </div>
    </header>

    <div class="mobile-nav-overlay" id="mobile-nav-overlay">
        <div class="close-menu-btn" id="close-menu-btn">
            <i class="fas fa-times"></i>
        </div>
        <div class="nav-links">
            <a href="#" id="mobile-profile-btn"><i class="fas fa-user"></i> Profile</a>
            <a href="#" id="mobile-deposit-btn"><i class="fas fa-plus-circle"></i> Deposit</a>
            <a href="#" id="mobile-withdraw-btn"><i class="fas fa-minus-circle"></i> Withdraw</a>
            <a href="#" id="mobile-provably-fair-btn"><i class="fas fa-shield-alt"></i> Provably Fair</a>
            <a href="#" id="mobile-settings-btn"><i class="fas fa-cog"></i> Settings</a>
            <a href="#" id="mobile-history-btn"><i class="fas fa-history"></i> History</a>
            <a href="#" id="mobile-connect-wallet-btn" style="display: block;"><i class="fas fa-wallet"></i> Connect Wallet</a>
            <a href="#" id="mobile-disconnect-btn" style="display: none;"><i class="fas fa-power-off"></i> Disconnect</a>
        </div>
    </div>

    <div class="game-container">
        <div class="mode-toggle">
            <button id="solo-mode-btn" class="active">Solo Mode</button>
            <button id="duel-mode-btn">Duel Mode</button>
            <button id="leaderboard-mode-btn">Leaderboard</button>
        </div>

        <div class="dice-area">
            <div class="dice player-dice" id="player-die1">1
                <div class="sound-waves" id="sound-waves-1">
                    <div class="wave"></div>
                    <div class="wave"></div>
                    <div class="wave"></div>
                </div>
            </div>
            <div class="dice player-dice" id="player-die2">1
                <div class="sound-waves" id="sound-waves-2">
                    <div class="wave"></div>
                    <div class="wave"></div>
                    <div class="wave"></div>
                </div>
            </div>
            <div class="vs-text" id="vs-text" style="display: none;">VS</div>
            <div class="dice opponent-dice" id="opponent-die1" style="display: none;">1
                <div class="sound-waves" id="sound-waves-3">
                    <div class="wave"></div>
                    <div class="wave"></div>
                    <div class="wave"></div>
                </div>
            </div>
            <div class="dice opponent-dice" id="opponent-die2" style="display: none;">1
                <div class="sound-waves" id="sound-waves-4">
                    <div class="wave"></div>
                    <div class="wave"></div>
                    <div class="wave"></div>
                </div>
            </div>
        </div>

        <div class="duel-info" id="duel-info" style="display: none;">
            <p id="matchmaking-status">Searching for opponent...</p>
            <div class="stake-display">
                <span>Your Stake: <strong id="player-stake">0.00 SOL</strong></span>
                <span>Opponent Stake: <strong id="opponent-stake">0.00 SOL</strong></span>
            </div>
            <p class="pot-display" id="pot-display">Total Pot: 0.00 SOL</p>
            <button id="confirm-ready-btn" class="roll-btn" style="display: none; margin-top: 1rem">
                CONFIRM READY
            </button>
        </div>

        <div class="result-display" id="result"></div>

        <div class="controls">
            <div class="slider-container" id="solo-controls">
                <div class="roll-mode-toggle">
                    <button id="roll-under-btn" class="roll-mode-btn active">
                        <i class="fas fa-arrow-down"></i> Roll Under
                    </button>
                    <button id="roll-over-btn" class="roll-mode-btn">
                        <i class="fas fa-arrow-up"></i> Roll Over
                    </button>
                </div>
                
                <div class="slider-labels">
                    <span id="roll-mode-label">Roll Under:</span>
                    <span id="roll-under-value" class="tooltip" data-tooltip="Current target number">7</span>
                </div>
                <input type="range" id="roll-under-slider" min="3" max="11" value="7" step="1">
            </div>

            <div class="multiplier-display tooltip" id="multiplier" data-tooltip="Your potential winnings multiplier">
                Payout: 6x
            </div>

            <div class="bet-controls">
                <div class="chip-buttons-row">
                    <button class="chip-btn" data-value="0.01">0.01</button>
                    <button class="chip-btn" data-value="0.1">0.1</button>
                    <button class="chip-btn active" data-value="1">1</button>
                    <button class="chip-btn" data-value="5">5</button>
                    <button class="chip-btn" data-value="MAX">MAX</button>
                </div>
                
                <div class="custom-bet-container">
                    <div class="custom-bet-input-wrapper">
                        <input type="number" 
                               id="custom-bet-input" 
                               placeholder="0" 
                               min="0.01" 
                               max="999999" 
                               step="0.01"
                               class="custom-bet-input">
                        <button id="clear-bet-btn" class="clear-bet-btn">CLEAR</button>
                    </div>
                    </div>
            </div>

            <div class="auto-bet-controls">
                <div class="auto-bet-toggle" id="auto-bet-toggle">
                    <span>Auto Bet</span>
                    <label class="switch">
                        <input type="checkbox" id="auto-bet-checkbox">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="auto-bet-settings" id="auto-bet-settings">
                    <label>
                        Bet Count:
                        <input type="number" id="auto-bet-count" value="10" min="1">
                    </label>
                    <label>
                        Delay (ms):
                        <input type="number" id="auto-bet-delay" value="1000" min="100">
                    </label>
                    <label>
                        Stop on Win:
                        <label class="switch">
                            <input type="checkbox" id="auto-bet-stop-win">
                            <span class="slider"></span>
                        </label>
                    </label>
                    <label>
                        Stop on Loss:
                        <label class="switch">
                            <input type="checkbox" id="auto-bet-stop-loss">
                            <span class="slider"></span>
                        </label>
                    </label>
                    <div class="auto-bet-progress" id="auto-bet-progress">
                        Progress: <strong>0</strong> / <strong>0</strong>
                    </div>
                </div>
            </div>
            <button id="stake-find-button" class="roll-btn" style="display: none; margin-top: 1rem">
                STAKE & FIND MATCH
            </button>
            <button class="roll-btn" id="roll-button">ROLL</button>
            <button class="roll-btn" id="find-match-button" style="display: none;">Find Match</button>
        </div>

        <div class="daily-challenge-panel" id="daily-challenge-panel">
            <h4>Daily Challenge</h4>
            <p id="challenge-text">Roll under 5 three times</p>
            <div class="progress" id="challenge-progress">Progress: 0/3</div>
            <button id="claim-reward-btn" style="display: none;">Claim Reward (Mock)</button>
        </div>

         <div class="duel-history" id="duel-history" style="display: none;">
            <h4>Duel History</h4>
            <ul class="duel-history-list" id="duel-history-list">
                </ul>
         </div>

        <div class="live-feed" id="live-feed">
            <div class="feed-header">
                🔥 Live Activity
            </div>
            <div class="feed-content" id="feed-content">
                <div class="feed-item win">Anonymous won 2.5x on Roll Under 8!</div>
                <div class="feed-item loss">Player123 lost 1.2 SOL on Roll Over 6</div>
                <div class="feed-item win">CryptoKing hit 5.5x multiplier!</div>
            </div>
        </div>
        
        <div class="leaderboard-content" id="leaderboard-content" style="display: none;">
            <div class="leaderboard-header">
                <h2>🏆 Leaderboard</h2>
                <p class="leaderboard-subtitle">Top players by wins</p>
            </div>
            <div class="leaderboard-container">
                <ul class="leaderboard-list" id="leaderboard-list"></ul>
            </div>
        </div>

    </div>

    <div class="recent-wins">
        <span>Player1 won 2.5 SOL! • Player2 won 1.8 SOL! • Player3 won 5.2 SOL!</span>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <div id="wallet-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Connect Wallet</h2>
            
            <div id="wallet-selection-screen">
                <div class="wallet-options">
                    <button id="connect-phantom">
                        <svg width="24" height="24" viewBox="0 0 108 108" fill="none" xmlns="http://www.w3.org/2000/svg">    <circle cx="54" cy="54" r="54" fill="url(#paint0_linear_0_1)"/>    <path d="M76.7279 83.2052C74.4254 85.7885 70.5846 86.5349 67.3234 85.0656L51.8925 78.2764L41.4079 83.6688C38.6729 85.159 35.2734 84.7736 32.9698 82.6998C30.6662 80.6261 29.8378 77.209 31.1438 74.0307C32.2566 71.3168 34.5273 69.1613 37.3642 68.017L52.3697 62.3670L59.9921 59.9848C64.075 58.4976 68.3959 59.2232 71.9728 61.9903C75.5496 64.7489 77.8768 68.9622 78.3695 73.639L78.7671 76.9919C79.1365 80.1458 78.2408 81.5928 76.7279 83.2052Z" fill="white"/>    <defs>        <linearGradient id="paint0_linear_0_1" x1="54" y1="0" x2="54" y2="108" gradientUnits="userSpaceOnUse">            <stop stop-color="#534BB1"/>            <stop offset="1" stop-color="#551BF9"/>        </linearGradient>    </defs></svg>
                        Phantom
                    </button>
                    <button id="connect-solflare">
                        <img src="https://solflare.com/favicon.ico" alt="Solflare Icon"> 
                        Solflare
                    </button>
                </div>
            </div>
            
            <div id="wallet-connecting-screen" style="display: none;">
                <div style="text-align: center;">
                    <div class="spinner" style="margin: 20px auto; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid var(--accent-green); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <h3>Connecting to <span id="selected-wallet-name"></span></h3>
                    <p>Please approve the connection in your wallet...</p>
                </div>
            </div>
            
            <div id="wallet-verification-screen" style="display: none;">
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px;">🔐</div>
                    <h3>Verify Wallet Ownership</h3>
                    <p>Please sign a message to verify you own this wallet. This doesn't cost any SOL.</p>
                    <div style="background: #333; padding: 10px; border-radius: 8px; margin: 15px 0; word-break: break-all;">
                        <strong>Wallet:</strong> <span id="wallet-address-display"></span>
                    </div>
                </div>
            </div>
            
            <div id="wallet-success-screen" style="display: none;">
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px; color: var(--accent-green);">✅</div>
                    <h3>Wallet Connected Successfully!</h3>
                    <p>Your wallet is now connected and verified. You can start playing with real SOL.</p>
                    <button id="wallet-success-continue">Start Playing</button>
                </div>
            </div>
            
            <div id="wallet-error-screen" style="display: none;">
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px; color: var(--accent-pink);">❌</div>
                    <h3>Connection Failed</h3>
                    <p id="wallet-error-message">Failed to connect wallet. Please try again.</p>
                    <div style="margin-top: 20px;">
                        <button id="wallet-error-retry">Try Again</button>
                        <button onclick="window.open('https://solana.com/ecosystem/wallets', '_blank')" style="background: #666; margin-left: 10px;">Get Help</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="profile-modal" class="modal">
        <div class="modal-content profile-modal-content">
            <span class="close-button">&times;</span>
            <div class="modal-header">
                <h2>Profile</h2>
                <button id="update-profile-btn" class="update-btn">Update</button>
            </div>
            <div class="profile-options profile-section">
                <label for="username-input">Username: <span id="current-avatar-preview" class="avatar-preview"></span></label>
                <input type="text" id="username-input" placeholder="Enter your username">
                <label for="avatar-selection">Avatar Selection:</label>
                <div class="avatar-selection-grid" id="avatar-selection-grid">
                    </div>
                <div class="custom-avatar-input-group">
                    <input type="text" id="custom-avatar-input" placeholder="Paste emoji or image URL (e.g., 🚀 or https://...)">
                    <button id="set-custom-avatar-btn">Set Custom</button>
                </div>
                </div>
            <div class="stats-grid profile-section">
                <div class="stat-card">
                    <div class="stat-value" id="total-games">0</div>
                    <div class="stat-label">Games</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="win-rate">0%</div>
                    <div class="stat-label">Win Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-wagered">0.000</div>
                    <div class="stat-label">Total Wagered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="net-profit">0.000</div>
                    <div class="stat-label">Net Profit</div>
                </div>
            </div>
            <div class="friends-list-container profile-section">
                <h3>Friends List</h3>
                <div class="friends-search-bar">
                    <input type="text" id="friend-search-input" placeholder="Search friends or add by ID">
                    <button id="add-friend-by-id-btn"><i class="fas fa-plus"></i></button>
                </div>
                <ul class="friends-list" id="friends-list">
                    </ul>
            </div>
            <div class="referral-section profile-section" style="margin-top: 1.5rem;">
                <h4 style="color: var(--accent-pink); margin-bottom: 0.5rem;">Invite Friends</h4>
                <p style="margin-bottom: 0.5rem;">Earn 0.05 SOL for each friend who joins!</p>
                <div class="referral-code" id="referral-code" style="font-size: 1.1rem; font-weight: 700; margin: 0.5rem 0; color: var(--accent-green);">YOURCODE123</div>
                <button id="copy-referral-btn" style="background-color: var(--accent-green); color: var(--bg-dark);">Copy Code</button>
            </div>
        </div>
    </div>

    <div id="deposit-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Deposit</h2>
            
            <div id="deposit-not-connected" style="text-align: center; display: none;">
                <p>Connect your wallet to deposit SOL</p>
                <button id="deposit-connect-wallet-btn" class="roll-btn" style="background-color: var(--accent-green); margin-top: 15px;">CONNECT WALLET</button>
            </div>
            
            <div id="deposit-connected" style="display: none;">
                <div class="transaction-options">
                    <label for="deposit-amount">Amount (SOL):</label>
                    <div style="display: flex; margin-bottom: 15px;">
                        <input type="number" id="deposit-amount" value="1" min="0.01" step="0.01" style="flex: 1;">
                        <button class="chip-btn" onclick="setDepositAmount(0.1)">+0.1</button>
                        <button class="chip-btn" onclick="incrementDepositAmount(0.1)">+0.1</button>
                    </div>
                    <div style="text-align: right; margin-bottom: 10px; font-size: 0.8rem; opacity: 0.7;">
                        ≈ $<span id="deposit-usd-value">0.00</span> USD
                    </div>
                    <div style="text-align: left; margin-bottom: 10px;">
                        Balance: <span id="deposit-current-balance">0.000</span> SOL
                    </div>
                    <button id="confirm-deposit-btn">DEPOSIT</button>
                    <div style="margin-top: 15px; text-align: center; font-size: 0.9rem; opacity: 0.7;">
                        Enjoy 0% fees on SOL deposits & withdrawals!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="withdraw-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Withdraw</h2>
            
            <div id="withdraw-not-connected" style="text-align: center; display: none;">
                <p>Connect your wallet to withdraw SOL</p>
                <button id="withdraw-connect-wallet-btn" class="roll-btn" style="background-color: var(--accent-pink); margin-top: 15px;">CONNECT WALLET</button>
            </div>
            
            <div id="withdraw-connected" style="display: none;">
                <div class="transaction-options">
                    <label for="withdraw-amount">Amount (SOL):</label>
                    <div style="display: flex; margin-bottom: 15px;">
                        <input type="number" id="withdraw-amount" value="0.1" min="0.01" step="0.01" style="flex: 1;">
                        <button class="chip-btn" onclick="setWithdrawAmount(0.1)">+0.1</button>
                        <button class="chip-btn" onclick="incrementWithdrawAmount(0.1)">+0.1</button>
                    </div>
                    <div style="text-align: right; margin-bottom: 10px; font-size: 0.8rem; opacity: 0.7;">
                        ≈ $<span id="withdraw-usd-value">0.00</span> USD
                    </div>
                    <div style="text-align: left; margin-bottom: 10px;">
                        Balance: <span id="withdraw-current-balance">0.000</span> SOL
                    </div>
                    <button id="confirm-withdraw-btn">WITHDRAW</button>
                    <div style="margin-top: 15px; text-align: center; font-size: 0.9rem; opacity: 0.7;">
                        Enjoy 0% fees on SOL deposits & withdrawals!
                    </div>
                    <div style="margin-top: 10px; text-align: center; font-style: italic; font-size: 0.85rem; opacity: 0.7;">
                        While we are in beta, max withdrawal is 25 SOL/day. This limit will be raised very soon.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="provably-fair-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Provably Fair Verification</h2>
            <div class="settings-section">
                <h3>Current Game Seeds</h3>
                <div class="seed-pair">
                    <p><strong>Server Seed (Hashed):</strong> <span id="current-server-seed-hash"></span></p>
                    <p><strong>Client Seed:</strong> <span id="current-client-seed"></span></p>
                    <p><strong>Nonce:</strong> <span id="current-nonce"></span></p>
                </div>
                <button id="change-client-seed-btn">Change Client Seed</button>
            </div>
            <div class="settings-section">
                <h3>Verify Past Roll</h3>
                <label for="verify-server-seed">Server Seed (Unhashed):</label>
                <input type="text" id="verify-server-seed" placeholder="Paste unhashed server seed">
                <label for="verify-client-seed">Client Seed:</label>
                <input type="text" id="verify-client-seed" placeholder="Paste client seed">
                <label for="verify-nonce">Nonce:</label>
                <input type="number" id="verify-nonce" placeholder="Paste nonce">
                <button id="verify-roll-btn">Verify Roll</button>
                <div id="verification-result" style="margin-top: 1rem; font-weight: bold;"></div>
            </div>
            <p class="info-text">A provably fair system ensures that neither the player nor the house can cheat. The outcome of each roll is determined by a combination of a server seed (hashed, known only to the server before the roll), a client seed (provided by you), and a nonce (incremented for each roll). After the roll, the unhashed server seed is revealed, allowing you to verify the outcome independently.</p>
        </div>
    </div>
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Settings</h2>
            <div class="settings-section">
                <h3>Sound Controls</h3>
                <div class="setting-item">
                    <label for="master-volume">Master Volume</label>
                    <input type="range" id="master-volume" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="setting-item">
                    <label for="roll-sound-toggle">Roll Sound</label>
                    <label class="switch">
                        <input type="checkbox" id="roll-sound-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <label for="result-sound-toggle">Result Sound</label>
                    <label class="switch">
                        <input type="checkbox" id="result-sound-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <label for="ui-sound-toggle">UI Sounds</label>
                    <label class="switch">
                        <input type="checkbox" id="ui-sound-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <button id="save-settings-btn">Save Settings</button>
        </div>
    </div>
    <div id="history-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-button">&times;</span>
            <h2>Game History & Records</h2>
            <div class="history-tabs">
                <button id="game-history-tab" class="active">Game History</button>
                <button id="personal-records-tab">Personal Records</button>
            </div>

            <div id="game-history-content" class="history-content active">
                <div class="game-history-filters">
                    <select id="history-filter-mode">
                        <option value="all">All Modes</option>
                        <option value="solo">Solo</option>
                        <option value="duel">Duel</option>
                    </select>
                    <select id="history-filter-outcome">
                        <option value="all">All Outcomes</option>
                        <option value="win">Win</option>
                        <option value="loss">Loss</option>
                        <option value="tie">Tie</option>
                    </select>
                    <input type="date" id="history-filter-date">
                    <button id="history-apply-filters-btn">Apply Filters</button>
                    <button id="history-export-csv-btn">Export CSV</button>
                </div>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table class="game-history-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Mode</th>
                                <th>Bet</th>
                                <th>Roll</th>
                                <th>Target</th>
                                <th>Outcome</th>
                                <th>Payout/Loss</th>
                            </tr>
                        </thead>
                        <tbody id="game-history-table-body">
                            </tbody>
                    </table>
                </div>
                <div class="game-history-pagination">
                    <button id="history-prev-page-btn" disabled>Prev</button>
                    <span id="history-page-info">Page 1 of 1</span>
                    <button id="history-next-page-btn" disabled>Next</button>
                </div>
            </div>

            <div id="personal-records-content" class="history-content">
                <div class="personal-records-grid">
                    <div class="record-card">
                        <div class="value" id="record-biggest-win">0.00 SOL</div>
                        <div class="label">Biggest Win</div>
                    </div>
                    <div class="record-card">
                        <div class="value" id="record-longest-streak">0</div>
                        <div class="label">Longest Win Streak</div>
                    </div>
                    <div class="record-card">
                        <div class="value" id="record-highest-multiplier">0x</div>
                        <div class="label">Highest Multiplier</div>
                    </div>
                    <div class="record-card">
                        <div class="value" id="record-total-games-played">0</div>
                        <div class="label">Total Games</div>
                    </div>
                    <div class="record-card">
                        <div class="value" id="record-total-wagered-sum">0.00 SOL</div>
                        <div class="label">Total Wagered</div>
                    </div>
                    <div class="record-card">
                        <div class="value" id="record-net-profit-sum">0.00 SOL</div>
                        <div class="label">Net Profit</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification-container"></div>
    <div class="chat-container" id="chat-container">
         <i class="fas fa-comment-dots" id="chat-bubble-icon" style="font-size: 1.8rem;"></i>
        <div class="chat-header" id="chat-header">
            Chat <i class="fas fa-chevron-down"></i>
        </div>
        <div class="chat-body" id="chat-body">
            </div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="Type a message...">
            <button id="send-chat-btn"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <div id="result-modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button">&times;</span>
            <h2 id="result-title">ROLL RESULTS</h2>
            <div id="result-details" style="text-align: left; padding: 1rem">
                </div>
            <button id="result-close-btn" class="roll-btn">CONTINUE</button>
        </div>
    </div>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-base@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-wallets@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/tweetnacl@1.0.3/nacl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
    
    <script>
        // STEP 2: Add NaCl Variable Declaration
        // Ensure nacl is available globally
        window.nacl = window.nacl || nacl;

        // STEP 3: Add Error Handling for TweetNaCl Loading
        // Check if TweetNaCl loaded properly
        if (typeof nacl === 'undefined') {
            console.error('TweetNaCl library failed to load');
            // Fallback: show user-friendly error
            window.addEventListener('load', function() {
                const walletModal = document.getElementById('wallet-modal');
                const errorScreen = document.getElementById('wallet-error-screen');
                if (walletModal && errorScreen) {
                    document.getElementById('wallet-error-message').textContent = 
                        'Crypto library failed to load. Please refresh the page and try again.';
                    walletModal.style.display = 'flex';
                    errorScreen.style.display = 'block';
                }
            });
        }

        // --- Minimal bs58 decode function for browser compatibility ---
        // This function is included directly to avoid external script loading issues.
        const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        const ALPHABET_MAP = {};
        for(let i = 0; i < ALPHABET.length; i++) {
            ALPHABET_MAP[ALPHABET.charAt(i)] = i;
        }
        const BASE = ALPHABET.length;

        function bs58_decode(string) {
            if (typeof string !== 'string') {
                throw new Error('Expected a string for base58 decoding.');
            }
            if (string.length === 0) {
                return new Uint8Array(0);
            }

            let bytes = [0];
            for (let i = 0; i < string.length; i++) {
                const char = string[i];
                const value = ALPHABET_MAP[char];
                if (value === undefined) {
                    throw new Error(`Non-base58 character: ${char}`);
                }

                let carry = value;
                for (let j = 0; j < bytes.length; ++j) {
                    carry += bytes[j] * BASE;
                    bytes[j] = carry & 0xFF;
                    carry >>= 8;
                }

                while (carry) {
                    bytes.push(carry & 0xFF);
                    carry >>= 8;
                }
            }

            // deal with leading zeros
            let leadingZeros = 0;
            for (let i = 0; i < string.length && string[i] === '1'; ++i) {
                leadingZeros++;
            }

            const result = new Uint8Array(bytes.length + leadingZeros);
            for (let i = 0; i < bytes.length; ++i) {
                result[i + leadingZeros] = bytes[bytes.length - 1 - i];
            }
            return result;
        }

        // --- Firebase Mock Setup (for demonstration purposes) ---
        // In a real application, you would initialize Firebase here and use its SDK.
        // const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Mock Firebase functions for demonstration
        const mockFirestore = {
            // Mock active matches collection
            activeMatches: {},
            // Mock match history collection
            matchHistory: JSON.parse(localStorage.getItem('mockMatchHistory')) || [],
            // Mock player stats collection
            playerStats: JSON.parse(localStorage.getItem('mockPlayerStats')) || {},
            // Mock friends list
            friends: JSON.parse(localStorage.getItem('mockFriends')) || [],

            // Simulate adding a document
            addDoc: async (collectionRef, data) => {
                const id = 'doc_' + Date.now() + Math.random().toString(36).substring(2, 9);
                if (collectionRef === 'activeMatches') {
                    mockFirestore.activeMatches[id] = { id, ...data };
                    // Simulate onSnapshot for active matches
                    if (mockFirestore.activeMatchesSnapshotCallback) {
                        mockFirestore.activeMatchesSnapshotCallback(Object.values(mockFirestore.activeMatches));
                    }
                } else if (collectionRef === 'matchHistory') {
                    mockFirestore.matchHistory.push({ id, ...data });
                    localStorage.setItem('mockMatchHistory', JSON.stringify(mockFirestore.matchHistory));
                    // Simulate onSnapshot for match history
                    if (mockFirestore.matchHistorySnapshotCallback) {
                        mockFirestore.matchHistorySnapshotCallback(mockFirestore.matchHistory);
                    }
                } else if (collectionRef === 'playerStats') {
                    mockFirestore.playerStats[data.userId] = { ...mockFirestore.playerStats[data.userId], ...data };
                    localStorage.setItem('mockPlayerStats', JSON.stringify(mockFirestore.playerStats));
                } else if (collectionRef === 'friends') {
                    mockFirestore.friends.push({ id, ...data });
                    localStorage.setItem('mockFriends', JSON.stringify(mockFirestore.friends));
                    if (mockFirestore.friendsSnapshotCallback) {
                        mockFirestore.friendsSnapshotCallback(mockFirestore.friends);
                    }
                }
                return { id };
            },

            // Simulate getting a document
            getDoc: async (collectionRef, id) => {
                if (collectionRef === 'activeMatches') {
                    return mockFirestore.activeMatches[id];
                }
                return null;
            },

            // Simulate updating a document
            updateDoc: async (collectionRef, id, data) => {
                if (collectionRef === 'activeMatches' && mockFirestore.activeMatches[id]) {
                    mockFirestore.activeMatches[id] = { ...mockFirestore.activeMatches[id], ...data };
                    // Simulate onSnapshot for active matches
                    if (mockFirestore.activeMatchesSnapshotCallback) {
                        mockFirestore.activeMatchesSnapshotCallback(Object.values(mockFirestore.activeMatches));
                    }
                } else if (collectionRef === 'playerStats') {
                    mockFirestore.playerStats[id] = { ...mockFirestore.playerStats[id], ...data };
                    localStorage.setItem('mockPlayerStats', JSON.stringify(mockFirestore.playerStats));
                }
            },

            // Simulate deleting a document
            deleteDoc: async (collectionRef, id) => {
                if (collectionRef === 'activeMatches' && mockFirestore.activeMatches[id]) {
                    delete mockFirestore.activeMatches[id];
                    // Simulate onSnapshot for active matches
                    if (mockFirestore.activeMatchesSnapshotCallback) {
                        mockFirestore.activeMatchesSnapshotCallback(Object.values(mockFirestore.activeMatches));
                    }
                } else if (collectionRef === 'friends') {
                    mockFirestore.friends = mockFriends.filter(f => f.id !== id);
                    localStorage.setItem('mockFriends', JSON.stringify(mockFriends));
                    if (mockFirestore.friendsSnapshotCallback) {
                        mockFirestore.friendsSnapshotCallback(mockFriends);
                    }
                }
            },

            // Simulate onSnapshot listener
            onSnapshot: (collectionRef, callback) => {
                if (collectionRef === 'activeMatches') {
                    mockFirestore.activeMatchesSnapshotCallback = callback;
                    callback(Object.values(mockFirestore.activeMatches)); // Initial call
                } else if (collectionRef === 'matchHistory') {
                    mockFirestore.matchHistorySnapshotCallback = callback;
                    callback(mockFirestore.matchHistory); // Initial call
                } else if (collectionRef === 'friends') {
                    mockFirestore.friendsSnapshotCallback = callback;
                    callback(mockFirestore.friends); // Initial call
                }
                // Return an unsubscribe function (mocked)
                return () => {
                    if (collectionRef === 'activeMatches') mockFirestore.activeMatchesSnapshotCallback = null;
                    if (collectionRef === 'matchHistory') mockFirestore.matchHistorySnapshotCallback = null;
                    if (collectionRef === 'friends') mockFirestore.friendsSnapshotCallback = null;
                };
            }
        };

        // Mock Auth (for userId)
        const mockAuth = {
            currentUser: {
                uid: localStorage.getItem('mockUserId') || crypto.randomUUID(),
                displayName: localStorage.getItem('username') || 'Anonymous',
                photoURL: localStorage.getItem('avatar') || '👤'
            },
            onAuthStateChanged: (callback) => {
                // Simulate initial auth state
                setTimeout(() => callback(mockAuth.currentUser), 0);
                // No actual state changes in this mock
            }
        };
        localStorage.setItem('mockUserId', mockAuth.currentUser.uid); // Persist mock user ID

        // --- Existing Game Script (DO NOT MODIFY) ---
        // Game state
        const state = {
            rollUnder: 7,
            chipValue: 1,
            diceValues: [1, 1],
            rollResult: null,
            streak: 0, // Reset streak to 0 for a fresh start
            rollMode: 'under', // NEW: Add this line ('under' or 'over')
            // CRITICAL FIX: House Edge Reduction - Adjusted payouts to ~3% house edge
            // Calculated based on (36 / winning_outcomes) * 0.97
            payouts: {
                3: 34.9,  // Fair: 36.0x (1/36 win chance) -> 36 * 0.97 = 34.92
                4: 11.6,  // Fair: 12.0x (3/36 win chance) -> 12 * 0.97 = 11.64
                5: 5.8,   // Fair: 6.0x (6/36 win chance) -> 6 * 0.97 = 5.82
                6: 3.5,   // Fair: 3.6x (10/36 win chance) -> 3.6 * 0.97 = 3.492
                7: 2.3,   // Fair: 2.4x (15/36 win chance) -> 2.4 * 0.97 = 2.328
                8: 1.6,   // Fair: 1.714x (21/36 win chance) -> 1.714 * 0.97 = 1.662
                9: 1.3,   // Fair: 1.384x (26/36 win chance) -> 1.384 * 0.97 = 1.342
                10: 1.1,  // Fair: 1.2x (30/36 win chance) -> 1.2 * 0.97 = 1.164
                11: 1.05  // Fair: 1.09x (33/36 win chance) -> 1.09 * 0.97 = 1.057
            },
            gameMode: 'solo', // 'solo' or 'duel'
            isSearching: false,
            activeMatch: null, // Stores current duel match data
            duelHistory: [], // Stores recent duel outcomes
            currentStake: 1, // Default stake for duels
            provablyFair: { // PROVABLY FAIR FEATURE - Initial state
                serverSeed: localStorage.getItem('serverSeed') || generateRandomHexString(64),
                clientSeed: localStorage.getItem('clientSeed') || generateRandomHexString(16),
                nonce: parseInt(localStorage.getItem('nonce')) || 0,
                nextServerSeed: generateRandomHexString(64) // For the next game
            },
            autoBet: { // AUTO-BET FEATURE - Initial state
                isActive: false,
                count: 0,
                currentBet: 0,
                delay: 1000,
                stopOnWin: false,
                stopOnLoss: false,
                intervalId: null
            },
            soundSettings: { // SOUND TOGGLE IN SETTINGS - Initial state
                masterVolume: parseFloat(localStorage.getItem('masterVolume')) || 1.0,
                rollSound: localStorage.getItem('rollSound') === 'false' ? false : true,
                resultSound: localStorage.getItem('resultSound') === 'false' ? false : true,
                uiSound: localStorage.getItem('uiSound') === 'false' ? false : true
            },
            gameHistory: JSON.parse(localStorage.getItem('gameHistory')) || [], // HISTORY/RECORDS SECTION
            personalRecords: JSON.parse(localStorage.getItem('personalRecords')) || { // HISTORY/RECORDS SECTION
                biggestWin: 0,
                longestWinStreak: 0,
                highestMultiplier: 0,
                totalGamesPlayed: 0,
                totalWageredSum: 0,
                netProfitSum: 0
            }
        };

        // Persist provably fair seeds and nonce
        function saveProvablyFairState() {
            localStorage.setItem('serverSeed', state.provablyFair.serverSeed);
            localStorage.setItem('clientSeed', state.provablyFair.clientSeed);
            localStorage.setItem('nonce', state.provablyFair.nonce);
        }

        // DOM elements
        const playerDie1 = document.getElementById('player-die1');
        const playerDie2 = document.getElementById('player-die2');
        const opponentDie1 = document.getElementById('opponent-die1');
        const opponentDie2 = document.getElementById('opponent-die2');
        const vsText = document.getElementById('vs-text');
        const resultDisplay = document.getElementById('result');
        const rollUnderSlider = document.getElementById('roll-under-slider');
        const rollUnderValue = document.getElementById('roll-under-value');
        const multiplierDisplay = document.getElementById('multiplier');
        const rollButton = document.getElementById('roll-button');
        const findMatchButton = document.getElementById('find-match-button'); // This button is now replaced by stake-find-button
        const chipButtons = document.querySelectorAll('.chip-btn');
        const hotStreakDisplay = document.getElementById('hot-streak');
        const soloModeBtn = document.getElementById('solo-mode-btn');
        const duelModeBtn = document.getElementById('duel-mode-btn');
        const soloControls = document.getElementById('solo-controls');
        const duelInfo = document.getElementById('duel-info');
        const matchmakingStatus = document.getElementById('matchmaking-status');
        const potDisplay = document.getElementById('pot-display');
        const duelHistorySection = document.getElementById('duel-history');
        const duelHistoryList = document.getElementById('duel-history-list');

        // NEW: Add these DOM element references for Roll Over feature
        const rollUnderBtn = document.getElementById('roll-under-btn');
        const rollOverBtn = document.getElementById('roll-over-btn');
        const rollModeLabel = document.getElementById('roll-mode-label');

        // NEW: Custom bet input functionality
        const customBetInput = document.getElementById('custom-bet-input');
        const clearBetBtn = document.getElementById('clear-bet-btn');
        // Removed balanceAmount as it's now in header

        // NEW: Duel mode specific buttons/elements
        const stakeFindButton = document.getElementById('stake-find-button');
        const playerStakeDisplay = document.getElementById('player-stake');
        const opponentStakeDisplay = document.getElementById('opponent-stake');
        const confirmReadyBtn = document.getElementById('confirm-ready-btn');

        // NEW: Result Modal elements
        const resultModal = document.getElementById('result-modal');
        const resultDetails = document.getElementById('result-details');
        const resultCloseBtn = document.getElementById('result-close-btn');

        // QUICK BALANCE REFRESH BUTTON START
        const balanceRefreshIcon = document.getElementById('balance-refresh-icon');
        // QUICK BALANCE REFRESH BUTTON END

        // AUTO-BET FEATURE DOM ELEMENTS
        const autoBetToggle = document.getElementById('auto-bet-toggle');
        const autoBetCheckbox = document.getElementById('auto-bet-checkbox');
        const autoBetSettings = document.getElementById('auto-bet-settings');
        const autoBetCountInput = document.getElementById('auto-bet-count');
        const autoBetDelayInput = document.getElementById('auto-bet-delay');
        const autoBetStopWinCheckbox = document.getElementById('auto-bet-stop-win');
        const autoBetStopLossCheckbox = document.getElementById('auto-bet-stop-loss');
        const autoBetProgressDisplay = document.getElementById('auto-bet-progress');
        // AUTO-BET FEATURE DOM ELEMENTS END

        // PROVABLY FAIR DOM ELEMENTS
        const provablyFairModal = document.getElementById('provably-fair-modal');
        const currentServerSeedHash = document.getElementById('current-server-seed-hash');
        const currentClientSeed = document.getElementById('current-client-seed');
        const currentNonce = document.getElementById('current-nonce');
        const changeClientSeedBtn = document.getElementById('change-client-seed-btn');
        const verifyServerSeedInput = document.getElementById('verify-server-seed');
        const verifyClientSeedInput = document.getElementById('verify-client-seed');
        const verifyNonceInput = document.getElementById('verify-nonce');
        const verifyRollBtn = document.getElementById('verify-roll-btn');
        const verificationResultDisplay = document.getElementById('verification-result');
        // PROVABLY FAIR DOM ELEMENTS END

        // SOUND TOGGLE IN SETTINGS DOM ELEMENTS
        const settingsModal = document.getElementById('settings-modal');
        const masterVolumeSlider = document.getElementById('master-volume');
        const rollSoundToggle = document.getElementById('roll-sound-toggle');
        const resultSoundToggle = document.getElementById('result-sound-toggle');
        const uiSoundToggle = document.getElementById('ui-sound-toggle');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        // SOUND TOGGLE IN SETTINGS DOM ELEMENTS END

        // HISTORY/RECORDS SECTION DOM ELEMENTS
        const historyModal = document.getElementById('history-modal');
        const gameHistoryTab = document.getElementById('game-history-tab');
        const personalRecordsTab = document.getElementById('personal-records-tab');
        const gameHistoryContent = document.getElementById('game-history-content');
        const personalRecordsContent = document.getElementById('personal-records-content');
        const historyFilterMode = document.getElementById('history-filter-mode');
        const historyFilterOutcome = document.getElementById('history-filter-outcome');
        const historyFilterDate = document.getElementById('history-filter-date');
        const historyApplyFiltersBtn = document.getElementById('history-apply-filters-btn');
        const historyExportCsvBtn = document.getElementById('history-export-csv-btn');
        const gameHistoryTableBody = document.getElementById('game-history-table-body');
        const historyPrevPageBtn = document.getElementById('history-prev-page-btn');
        const historyNextPageBtn = document.getElementById('history-next-page-btn');
        const historyPageInfo = document.getElementById('history-page-info');
        const recordBiggestWin = document.getElementById('record-biggest-win');
        const recordLongestStreak = document.getElementById('record-longest-streak');
        const recordHighestMultiplier = document.getElementById('record-highest-multiplier');
        const recordTotalGamesPlayed = document.getElementById('record-total-games-played');
        const recordTotalWageredSum = document.getElementById('record-total-wagered-sum');
        const recordNetProfitSum = document.getElementById('record-net-profit-sum');

        let currentPage = 1;
        const rowsPerPage = 10;
        // HISTORY/RECORDS SECTION DOM ELEMENTS END

        // FRIENDS SECTION DOM ELEMENTS
        const friendSearchInput = document.getElementById('friend-search-input');
        const addFriendByIdBtn = document.getElementById('add-friend-by-id-btn');
        const friendsList = document.getElementById('friends-list');
        // FRIENDS SECTION DOM ELEMENTS END

        // AVATAR SELECTION DOM ELEMENTS
        const avatarSelectionGrid = document.getElementById('avatar-selection-grid');
        const customAvatarInput = document.getElementById('custom-avatar-input');
        const setCustomAvatarBtn = document.getElementById('set-custom-avatar-btn');
        const currentAvatarPreview = document.getElementById('current-avatar-preview');

        const predefinedAvatars = ['😎', '🥳', '🤩', '🚀', '💎', '🐶', '🐱', '🦊', '🐻', '🐼', '🤖', '👽', '👻', '👾', '👑', '🌟', '⚡', '🔥', '🌊', '🌈'];
        // AVATAR SELECTION DOM ELEMENTS END

        // LEADERBOARD TAB DOM ELEMENTS
        const leaderboardModeBtn = document.getElementById('leaderboard-mode-btn');
        const leaderboardContent = document.getElementById('leaderboard-content');
        // LEADERBOARD TAB DOM ELEMENTS END

        // --- PvP Specific Functions (Moved to before initialization) ---

        function setGameMode(mode) {
            state.gameMode = mode;
            soloModeBtn.classList.remove('active');
            duelModeBtn.classList.remove('active');
            leaderboardModeBtn.classList.remove('active'); // Remove active from leaderboard button

            // Hide all main game content areas
            document.querySelector('.dice-area').style.display = 'none'; // Hide dice area
            document.querySelector('.controls').style.display = 'none'; // Hide controls
            document.querySelector('.daily-challenge-panel').style.display = 'none'; // Hide daily challenge
            document.querySelector('.result-display').style.display = 'none'; // Hide result display

            soloControls.style.display = 'none';
            multiplierDisplay.style.display = 'none';
            rollButton.style.display = 'none';
            stakeFindButton.style.display = 'none';
            opponentDie1.style.display = 'none';
            opponentDie2.style.display = 'none';
            duelInfo.style.display = 'none';
            duelHistorySection.style.display = 'none';
            leaderboardContent.style.display = 'none'; // Hide leaderboard content
            autoBetToggle.style.display = 'none';

            if (mode === 'solo') {
                soloModeBtn.classList.add('active');
                document.querySelector('.dice-area').style.display = 'flex'; // Show dice area
                document.querySelector('.controls').style.display = 'flex'; // Show controls
                document.querySelector('.daily-challenge-panel').style.display = 'block'; // Show daily challenge
                document.querySelector('.result-display').style.display = 'block'; // Show result display

                soloControls.style.display = 'flex';
                multiplierDisplay.style.display = 'block';
                rollButton.style.display = 'block';
                autoBetToggle.style.display = 'flex'; // Show auto-bet in solo mode

                // Reset dice colors to default white for solo
                playerDie1.classList.remove('player-dice');
                playerDie2.classList.remove('player-dice');
                playerDie1.style.backgroundColor = 'white';
                playerDie2.style.backgroundColor = 'white';
                playerDie1.style.boxShadow = 'var(--shadow-glow) rgba(255, 255, 255, 0.2)';
                playerDie2.style.boxShadow = 'var(--shadow-glow) rgba(255, 255, 255, 0.2)';

                rollButton.disabled = false; // Always enabled in solo
            } else if (mode === 'duel') { // Duel mode
                duelModeBtn.classList.add('active');
                document.querySelector('.dice-area').style.display = 'flex'; // Show dice area
                document.querySelector('.controls').style.display = 'flex'; // Show controls
                document.querySelector('.daily-challenge-panel').style.display = 'block'; // Show daily challenge
                document.querySelector('.result-display').style.display = 'block'; // Show result display

                stakeFindButton.style.display = 'block'; // Show stake & find button
                opponentDie1.style.display = 'flex'; // Show opponent dice
                opponentDie2.style.display = 'flex'; // Show opponent dice
                duelInfo.style.display = 'block';
                duelHistorySection.style.display = 'block';
                stopAutoBet(); // Stop auto-bet if active

                // Set distinct dice colors for player and opponent
                playerDie1.classList.add('player-dice');
                playerDie2.classList.add('player-dice');
                opponentDie1.classList.add('opponent-dice');
                opponentDie2.classList.add('opponent-dice');

                // Ensure roll button is disabled until match found
                rollButton.disabled = true;
                stakeFindButton.disabled = false; // Enable stake & find button
                confirmReadyBtn.style.display = 'none'; // Hide confirm ready button
                matchmakingStatus.textContent = 'Select stake and find opponent!';
                potDisplay.textContent = 'Total Pot: 0.00 SOL';
                playerStakeDisplay.textContent = '0.00 SOL';
                opponentStakeDisplay.textContent = '0.00 SOL';
                resultDisplay.textContent = ''; // Clear result display
            } else if (mode === 'leaderboard') {
                leaderboardModeBtn.classList.add('active');
                // Hide ALL game elements
                document.querySelector('.dice-area').style.display = 'none';
                document.querySelector('.controls').style.display = 'none';
                document.querySelector('.daily-challenge-panel').style.display = 'none';
                document.querySelector('.result-display').style.display = 'none';
                
                leaderboardContent.style.display = 'block';
                autoBetToggle.style.display = 'none';
            }
            // Reset dice values and result display when switching modes
            playerDie1.textContent = '1';
            playerDie2.textContent = '1';
            opponentDie1.textContent = '1';
            opponentDie2.textContent = '1';
            resultDisplay.textContent = '';
            vsText.style.display = 'none'; // Hide VS text
        }

        async function findMatch() {
            if (!realWallet.isConnected) {
                showMessageBox('Connect wallet to duel!', 'error');
                return;
            }
            
            const stakeAmount = state.currentStake;
            if (realWallet.balance < stakeAmount) {
                showMessageBox('Insufficient balance!', 'error');
                return;
            }
            
            // Deduct stake immediately
            realWallet.balance -= stakeAmount;
            realWallet.updateWalletUI();

            state.isSearching = true;
            stakeFindButton.disabled = true;
            rollButton.disabled = true;
            matchmakingStatus.textContent = `Searching for opponent (Stake: ${state.currentStake} SOL)...`;
            playerStakeDisplay.textContent = `${state.currentStake.toFixed(2)} SOL`;
            opponentStakeDisplay.textContent = `Searching...`;
            potDisplay.textContent = `Total Pot: ${(state.currentStake * 2).toFixed(2)} SOL`;

            // Simulate matchmaking process with realistic delay
            // DUEL MODE BALANCE IMPROVEMENTS: Simulate basic bot detection and skill/bankroll matching
            const opponentUsername = ['DegenBot', 'SkillBot', 'HighRollerBot'][Math.floor(Math.random() * 3)];
            const opponentAvatar = ['🤖', '👽', '😈'][Math.floor(Math.random() * 3)];
            const opponentId = 'mockOpponent_' + crypto.randomUUID();

            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 1000)); // Simulate 1-3 seconds network delay

            state.activeMatch = {
                id: 'match_' + Date.now(),
                player1: {
                    userId: mockAuth.currentUser.uid,
                    username: localStorage.getItem('username') || 'You',
                    avatar: localStorage.getItem('avatar') || '👤',
                    stake: stakeAmount // Use the actual stake amount
                },
                player2: {
                    userId: opponentId,
                    username: opponentUsername,
                    avatar: opponentAvatar,
                    stake: stakeAmount // Opponent matches player's stake
                },
                status: 'active',
                createdAt: new Date().toISOString()
            };

            // Add active match to mock Firestore
            await mockFirestore.addDoc('activeMatches', state.activeMatch);

            state.isSearching = false;
            matchmakingStatus.textContent = `Opponent Found: ${opponentUsername}!`;
            opponentStakeDisplay.textContent = `${state.currentStake.toFixed(2)} SOL`; // Update opponent stake
            confirmReadyBtn.style.display = 'block'; // Show confirm ready button
            stakeFindButton.style.display = 'none'; // Hide stake & find button
            showMessageBox(`Matched with ${opponentUsername}! Confirm ready to duel!`, 'success');
        }

        function renderDuelHistory() {
            duelHistoryList.innerHTML = '';
            // Sort history by timestamp descending
            const sortedHistory = [...state.duelHistory].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            sortedHistory.slice(0, 5).forEach(entry => { // Show last 5 duels
                const listItem = document.createElement('li');
                listItem.className = `duel-history-item ${entry.outcome === 'WIN' ? 'win-entry' : 'loss-entry'}`;
                const date = new Date(entry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                listItem.innerHTML = `
                    <span>${date} vs ${entry.opponent}</span>
                    <span>${entry.outcome} (${entry.playerRoll} vs ${entry.opponentRoll})</span>
                    <span>${entry.outcome === 'WIN' ? '+' : '-'}${entry.winnings.toFixed(2)} SOL</span>
                `;
                duelHistoryList.appendChild(listItem);
            });
        }

        // Custom Message Box instead of alert()
        function showMessageBox(message, type = 'info') {
            const messageBox = document.createElement('div');
            messageBox.style.position = 'fixed';
            messageBox.style.top = '20px';
            messageBox.style.left = '50%';
            messageBox.style.transform = 'translateX(-50%)';
            messageBox.style.padding = '15px 25px';
            messageBox.style.borderRadius = '8px';
            messageBox.style.color = 'white';
            messageBox.style.zIndex = '10000';
            messageBox.style.fontSize = '1.1rem';
            messageBox.style.fontWeight = 'bold';
            messageBox.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
            messageBox.style.opacity = '0';
            messageBox.style.transition = 'opacity 0.3s ease-in-out, top 0.3s ease-in-out';
            messageBox.textContent = message;

            if (type === 'success') {
                messageBox.style.backgroundColor = 'var(--accent-green)';
            } else if (type === 'error') {
                messageBox.style.backgroundColor = 'var(--accent-pink)';
            } else if (type === 'warning') {
                messageBox.style.backgroundColor = '#FFC107';
            } else {
                messageBox.style.backgroundColor = '#333';
            }

            document.body.appendChild(messageBox);

            // Animate in
            setTimeout(() => {
                messageBox.style.opacity = '1';
                messageBox.style.top = '30px';
            }, 100);

            // Animate out and remove
            setTimeout(() => {
                messageBox.style.opacity = '0';
                messageBox.style.top = '10px';
                setTimeout(() => messageBox.remove(), 300);
            }, 3000);
        }

        // NEW: Roll mode toggle functions
        function setRollMode(mode) {
            state.rollMode = mode;
            
            // Update button states
            rollUnderBtn.classList.remove('active');
            rollOverBtn.classList.remove('active');
            
            if (mode === 'under') {
                rollUnderBtn.classList.add('active');
                rollModeLabel.textContent = 'Roll Under:';
            } else {
                rollOverBtn.classList.add('active');
                rollModeLabel.textContent = 'Roll Over:';
            }
            
            // Update multiplier display to reflect current mode
            updateMultiplier();
        }

        // NEW: Get inverted payout values for Roll Over mode
        function getPayoutForRollOver(rollValue) {
            // Roll Over uses inverted logic: higher numbers = lower odds = higher payouts
            // Sums range from 2 to 12.
            // Roll Over X means sum > X.
            // Roll Under Y means sum < Y.
            // The probabilities are symmetric around 7.
            // E.g., P(sum > 7) == P(sum < 7)
            // P(sum > 3) is same as P(sum < 11) (since 3+11=14)
            // P(sum > 4) is same as P(sum < 10) (since 4+10=14)
            // So, for Roll Over X, the payout is the same as Roll Under (14-X).
            const invertedValue = 14 - rollValue; 
            return state.payouts[invertedValue] || 1.0; // Fallback to 1x if not found (shouldn't happen with valid range)
        }

        // Initialize
        updateMultiplier();
        updateHotStreakDisplay();
        setGameMode(state.gameMode); // Set initial UI based on solo mode
        // NEW: Initialize roll mode
        setRollMode('under'); // Set default to Roll Under mode

        // Load duel history from mock Firestore (local storage)
        state.duelHistory = mockFirestore.matchHistory;
        renderDuelHistory();

        // Event listeners
        // Update existing slider event listener to trigger multiplier update
        rollUnderSlider.addEventListener('input', function() {
            state.rollUnder = parseInt(this.value);
            rollUnderValue.textContent = state.rollUnder;
            updateMultiplier(); // This will now handle both modes
        });

        // NEW: Roll mode toggle event listeners
        rollUnderBtn.addEventListener('click', () => setRollMode('under'));
        rollOverBtn.addEventListener('click', () => setRollMode('over'));

        // Update existing chip button functionality to clear custom input
        chipButtons.forEach(button => {
            button.addEventListener('click', function() {
                // Clear custom input when chip button is clicked
                customBetInput.value = '';
                customBetInput.style.borderColor = '';
                
                // Existing chip button logic
                chipButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');

                if (this.dataset.value === 'MAX') {
                    state.chipValue = realWallet.balance;
                } else {
                    state.chipValue = parseFloat(this.dataset.value);
                }
                state.currentStake = state.chipValue;
            });
        });

        rollButton.addEventListener('click', () => {
            if (state.gameMode === 'solo') {
                rollDiceSolo();
            } else if (state.gameMode === 'duel' && state.activeMatch) {
                rollDiceDuel();
            } else if (state.gameMode === 'duel' && !state.activeMatch) {
                showMessageBox('Please find an opponent first!', 'warning');
            }
        });

        soloModeBtn.addEventListener('click', () => setGameMode('solo'));
        duelModeBtn.addEventListener('click', () => setGameMode('duel'));
        leaderboardModeBtn.addEventListener('click', () => setGameMode('leaderboard'));
        // findMatchButton.addEventListener('click', findMatch); // This is replaced by stake-find-button

        // New event listener for stake-find-button
        stakeFindButton.addEventListener('click', function() {
            if (!realWallet.isConnected) {
                showMessageBox('Connect wallet to duel!', 'error');
                return;
            }
            
            const stakeAmount = state.currentStake;
            if (realWallet.balance < stakeAmount) {
                showMessageBox('Insufficient balance!', 'error');
                return;
            }
            
            findMatch();
        });

        // New ready confirmation
        confirmReadyBtn.addEventListener('click', function() {
            this.disabled = true;
            this.textContent = 'Waiting for opponent...';
            
            // Simulate opponent ready
            setTimeout(() => {
                rollButton.style.display = 'block';
                rollButton.disabled = false; // Enable roll button
                matchmakingStatus.textContent = 'Opponent ready! ROLL NOW';
                confirmReadyBtn.style.display = 'none'; // Hide confirm ready button
            }, 2000);
        });

        // PROVABLY FAIR VERIFICATION START
        function generateRandomHexString(length) {
            let result = '';
            const characters = 'abcdef0123456789';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        // CRITICAL FIX: DICE LOGIC BUG - NEGATIVE NUMBERS
        // Add this validation to ALL dice generation functions
        function validateDiceValue(value) {
            const validValue = Math.max(1, Math.min(6, Math.abs(Math.floor(value))));
            return validValue;
        }

        function calculateDiceRoll(serverSeed, clientSeed, nonce) {
            const combinedSeed = serverSeed + clientSeed + nonce;
            const hash = sha256(combinedSeed); // Use sha256.js library
            
            // Take the first 8 characters of the hash for randomness (enough for 2 dice)
            const hexValue = parseInt(hash.substring(0, 8), 16);

            const dice1 = validateDiceValue((hexValue % 6) + 1);
            const dice2 = validateDiceValue(((hexValue >> 4) % 6) + 1); // Shift to get a different part of the hash

            return [dice1, dice2];
        }

        function updateProvablyFairUI() {
            currentServerSeedHash.textContent = sha256(state.provablyFair.serverSeed);
            currentClientSeed.textContent = state.provablyFair.clientSeed;
            currentNonce.textContent = state.provablyFair.nonce;
        }

        changeClientSeedBtn.addEventListener('click', () => {
            state.provablyFair.clientSeed = generateRandomHexString(16);
            state.provablyFair.nonce = 0; // Reset nonce on new client seed
            state.provablyFair.serverSeed = state.provablyFair.nextServerSeed; // Promote next to current
            state.provablyFair.nextServerSeed = generateRandomHexString(64); // Generate new next server seed
            saveProvablyFairState();
            updateProvablyFairUI();
            showMessageBox('New client seed generated. Nonce reset to 0.', 'info');
        });

        verifyRollBtn.addEventListener('click', () => {
            const serverSeed = verifyServerSeedInput.value.trim();
            const clientSeed = verifyClientSeedInput.value.trim();
            const nonce = parseInt(verifyNonceInput.value);

            if (!serverSeed || !clientSeed || isNaN(nonce)) {
                verificationResultDisplay.textContent = 'Please fill in all verification fields.';
                verificationResultDisplay.style.color = 'var(--accent-pink)';
                return;
            }

            const [dice1, dice2] = calculateDiceRoll(serverSeed, clientSeed, nonce);
            const sum = dice1 + dice2;

            verificationResultDisplay.textContent = `Verified Roll: ${sum} (${dice1} + ${dice2})`;
            verificationResultDisplay.style.color = 'var(--accent-green)';
        });
        // PROVABLY FAIR VERIFICATION END

        // Game functions
        function rollDiceSolo() {
            // AUTO-BET SAFETY ENHANCEMENT: Check if auto-bet is active and prevent manual roll
            if (state.autoBet.isActive && !state.autoBet.intervalId) { // Allow if it's an auto-bet triggered roll
                showMessageBox('Auto Bet is active. Please stop it to roll manually.', 'warning');
                return;
            }
            // AUTO-BET SAFETY ENHANCEMENT: Check balance before rolling
            if (!validateBetAmount(state.chipValue)) {
                stopAutoBet(); // Stop auto-bet if balance is insufficient during an auto-bet sequence
                return;
            }

            // Disable button during roll
            rollButton.disabled = true;

            // Animate dice
            animateDice([playerDie1, playerDie2]);

            // Play roll sound
            playRollSound();

            // After animation, show result
            setTimeout(() => {
                // PROVABLY FAIR: Use current seeds and increment nonce
                const [dice1, dice2] = calculateDiceRoll(
                    state.provablyFair.serverSeed, 
                    state.provablyFair.clientSeed, 
                    state.provablyFair.nonce
                );
                state.diceValues = [dice1, dice2];
                state.provablyFair.nonce++; // Increment nonce
                saveProvablyFairState(); // Save updated nonce

                // CRITICAL FIX: 2X MULTIPLIER ALWAYS WINS BUG & House Edge Reduction
                // The payout table has been adjusted to reflect ~3% house edge.
                // The win/loss logic for roll under/over is now correctly applied.
                const sum = state.diceValues[0] + state.diceValues[1];
                let shouldWin = false;
                if (state.rollMode === 'under') {
                    shouldWin = sum < state.rollUnder;
                } else {
                    // Roll Over mode: win if sum is greater than the target
                    shouldWin = sum > state.rollUnder;
                }
                
                state.rollResult = shouldWin ? 'WIN' : 'LOSE';

                // Update UI
                playerDie1.textContent = state.diceValues[0];
                playerDie2.textContent = state.diceValues[1];
                playerDie1.classList.remove('animate-shake');
                playerDie2.classList.remove('animate-shake');

                // Show clean result message
                resultDisplay.textContent = `Roll: ${sum} - ${state.rollResult}`;
                resultDisplay.className = 'result-display ' + (state.rollResult === 'WIN' ? 'win' : 'loss');

                // Show effects and update stats
                let winnings = 0;
                let multiplier = 0;
                if (state.rollResult === 'WIN') {
                    // Calculate winnings based on current roll mode
                    if (state.rollMode === 'under') {
                        multiplier = state.payouts[state.rollUnder];
                    } else {
                        multiplier = getPayoutForRollOver(state.rollUnder);
                    }
                    winnings = state.chipValue * multiplier;
                        
                    updateStreak(true);
                    playResultSound('win');
                    triggerCoinShower();
                    
                    if (realWallet.isConnected) { // Only update if wallet is connected
                        updateLeaderboardWins();
                        checkDailyChallenge(); // Daily challenge rewards SOL, so conditional
                        realWallet.balance += winnings;
                        realWallet.updateWalletUI();
                        gameStats.addGame(state.chipValue, winnings, true); // Stats update only if connected
                    }
                        
                    // Add to live feed regardless of wallet connection
                    liveFeed.addItem('win', `You won ${multiplier.toFixed(2)}x on ${state.rollMode === 'under' ? 'Roll Under' : 'Roll Over'} ${state.rollUnder}!`);
                        
                    // Show result modal instead of flash effect
                    let resultHTML = `
                        <p><strong>Your Roll:</strong> ${sum} (${state.diceValues[0]} + ${state.diceValues[1]})</p>
                        <p><strong>Target:</strong> ${state.rollMode === 'under' ? 'Under' : 'Over'} ${state.rollUnder}</p>
                        <hr style="margin: 1rem 0; border-color: #333;">
                        <p class="win" style="font-size: 1.5rem; text-align: center">
                            YOU WIN!
                        </p>
                        <p>+${winnings.toFixed(2)} SOL added to your balance!</p>
                        <p style="font-size: 0.9rem; opacity: 0.7;">Multiplier: ${multiplier.toFixed(2)}x</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Server Seed Hash: ${sha256(state.provablyFair.serverSeed)}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Client Seed: ${state.provablyFair.clientSeed}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Nonce: ${state.provablyFair.nonce -1}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Next Server Seed Hash: ${sha256(state.provablyFair.nextServerSeed)}</p>
                        `;
                    resultDetails.innerHTML = resultHTML;
                    resultModal.style.display = 'flex';
                } else {
                    updateStreak(false);
                    playResultSound('loss');
                        
                    if (realWallet.isConnected) { // Only update if wallet is connected
                        realWallet.balance -= state.chipValue;
                        realWallet.updateWalletUI();
                        gameStats.addGame(state.chipValue, 0, false); // Stats update only if connected
                    }
                        
                    liveFeed.addItem('loss', `You lost ${state.chipValue.toFixed(2)} SOL on ${state.rollMode === 'under' ? 'Roll Under' : 'Roll Over'} ${state.rollUnder}`);
                        
                    // Show result modal for loss
                    let resultHTML = `
                        <p><strong>Your Roll:</strong> ${sum} (${state.diceValues[0]} + ${state.diceValues[1]})</p>
                        <p><strong>Target:</strong> ${state.rollMode === 'under' ? 'Under' : 'Over'} ${state.rollUnder}</p>
                        <hr style="margin: 1rem 0; border-color: #333;">
                        <p class="loss" style="font-size: 1.5rem; text-align: center">
                            YOU LOSE!
                        </p>
                        <p>-${state.chipValue.toFixed(2)} SOL deducted from your balance.</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Server Seed Hash: ${sha256(state.provablyFair.serverSeed)}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Client Seed: ${state.provablyFair.clientSeed}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Nonce: ${state.provablyFair.nonce -1}</p>
                        <p style="font-size: 0.8rem; opacity: 0.5;">Next Server Seed Hash: ${sha256(state.provablyFair.nextServerSeed)}</p>
                        `;
                    resultDetails.innerHTML = resultHTML;
                    resultModal.style.display = 'flex';
                }

                // HISTORY/RECORDS SECTION - Update game history and personal records
                // These should always update regardless of wallet connection to track local play
                const gameHistoryEntry = {
                    date: new Date().toISOString(),
                    mode: 'solo',
                    bet: state.chipValue,
                    roll: sum,
                    target: state.rollUnder,
                    outcome: state.rollResult,
                    payoutLoss: state.rollResult === 'WIN' ? winnings : -state.chipValue,
                    multiplier: multiplier,
                    serverSeed: state.provablyFair.serverSeed,
                    clientSeed: state.provablyFair.clientSeed,
                    nonce: state.provablyFair.nonce - 1 // Store the nonce used for this roll
                };
                gameHistory.addGameEntry(gameHistoryEntry);
                personalRecords.updateRecords(gameHistoryEntry);

                // Re-enable button
                rollButton.disabled = false;

                // AUTO-BET FEATURE: Continue or stop auto-bet
                if (state.autoBet.isActive) {
                    state.autoBet.currentBet++;
                    updateAutoBetProgress();
                    if (state.autoBet.currentBet < state.autoBet.count && 
                        !(state.autoBet.stopOnWin && state.rollResult === 'WIN') &&
                        !(state.autoBet.stopOnLoss && state.rollResult === 'LOSE') &&
                        realWallet.balance >= state.chipValue) { // AUTO-BET SAFETY: Check balance before next auto-bet
                        state.autoBet.intervalId = setTimeout(rollDiceSolo, state.autoBet.delay);
                    } else {
                        stopAutoBet();
                        showMessageBox('Auto Bet finished.', 'info');
                    }
                }
            }, 1000);
        }

        function rollDiceDuel() {
            if (!state.activeMatch) {
                showMessageBox('No active duel. Please find a match first!', 'warning');
                return;
            }
            // Balance check is already done when staking, but a final check doesn't hurt.
            if (realWallet.balance < state.currentStake) {
                showMessageBox('Insufficient balance to complete the duel!', 'error');
                // Refund the initial stake if balance is now too low for some reason
                realWallet.balance += state.currentStake;
                realWallet.updateWalletUI();
                state.activeMatch = null; // Clear active match
                stakeFindButton.style.display = 'block'; // Show stake & find button again
                rollButton.style.display = 'none'; // Hide roll button
                rollButton.disabled = true;
                stakeFindButton.disabled = false;
                matchmakingStatus.textContent = 'Duel cancelled due to insufficient balance.';
                return;
            }

            rollButton.disabled = true;
            stakeFindButton.disabled = true; // Keep disabled during roll

            // Animate both players' dice
            animateDice([playerDie1, playerDie2, opponentDie1, opponentDie2]);
            vsText.style.display = 'block';

            playRollSound();

            setTimeout(async () => {
                // Player's roll
                const playerRoll1 = validateDiceValue(Math.floor(Math.random() * 6) + 1);
                const playerRoll2 = validateDiceValue(Math.floor(Math.random() * 6) + 1);
                const playerTotal = playerRoll1 + playerRoll2;

                // Opponent's roll (simulated)
                const opponentRoll1 = validateDiceValue(Math.floor(Math.random() * 6) + 1);
                const opponentRoll2 = validateDiceValue(Math.floor(Math.random() * 6) + 1);
                const opponentTotal = opponentRoll1 + opponentRoll2;

                // Update dice UI
                playerDie1.textContent = playerRoll1;
                playerDie2.textContent = playerRoll2;
                opponentDie1.textContent = opponentRoll1;
                opponentDie2.textContent = opponentRoll2;

                playerDie1.classList.remove('animate-shake');
                playerDie2.classList.remove('animate-shake');
                opponentDie1.classList.remove('animate-shake');
                opponentDie2.classList.remove('animate-shake');
                vsText.style.display = 'none';

                const pot = state.currentStake * 2;
                // DUEL MODE BALANCE IMPROVEMENTS: Reduced platform fee (e.g., from 5% to 2%)
                const platformFee = pot * 0.02; // Reduced to 2%
                const winnings = pot - platformFee;

                let duelOutcome = '';
                let winAmount = 0;

                if (playerTotal > opponentTotal) {
                    duelOutcome = 'WIN';
                    winAmount = winnings;
                    realWallet.balance += winnings;
                    // Removed old flash effects as they are replaced by the result modal
                    // showWinEffect(winAmount, 'duel'); 
                    playResultSound('win');
                    updateStreak(true);
                    updateLeaderboardWins();
                    checkDailyChallenge();
                } else if (opponentTotal > playerTotal) {
                    duelOutcome = 'LOSS';
                    // Removed old flash effects as they are replaced by the result modal
                    // showLossEffect('duel'); 
                    playResultSound('loss');
                    updateStreak(false);
                } else {
                    duelOutcome = 'TIE';
                    winAmount = state.currentStake; // Return stake on tie
                    realWallet.balance += state.currentStake;
                    showMessageBox('It\'s a Tie! Your stake has been returned.', 'info');
                    playResultSound('loss'); // Play a neutral sound for tie
                    updateStreak(false);
                }

                realWallet.updateWalletUI();

                // Replace existing result display with new modal logic
                let resultHTML = `
                    <p><strong>Your Roll:</strong> ${playerTotal} (${playerRoll1} + ${playerRoll2})</p>
                    <p><strong>Opponent Roll:</strong> ${opponentTotal} (${opponentRoll1} + ${opponentRoll2})</p>
                    <hr style="margin: 1rem 0; border-color: #333;">
                    <p class="${duelOutcome === 'WIN' ? 'win' : 'loss'}" 
                       style="font-size: 1.5rem; text-align: center">
                        YOU ${duelOutcome}!
                    </p>`;
                if (duelOutcome === 'WIN') {
                    resultHTML += `<p>+${winAmount.toFixed(2)} SOL added to your balance!</p>`;
                } else if (duelOutcome === 'LOSS') {
                    resultHTML += `<p>-${state.currentStake.toFixed(2)} SOL deducted from your balance.</p>`;
                } else if (duelOutcome === 'TIE') {
                    resultHTML += `<p>Your stake of ${state.currentStake.toFixed(2)} SOL has been returned.</p>`;
                }

                resultDetails.innerHTML = resultHTML;
                resultModal.style.display = 'flex'; // Show the result modal

                // Record duel history
                const duelEntry = {
                    date: new Date().toISOString(),
                    mode: 'duel',
                    bet: state.currentStake,
                    roll: playerTotal,
                    target: opponentTotal, // For duel, target is opponent's roll
                    outcome: duelOutcome,
                    payoutLoss: duelOutcome === 'WIN' ? winAmount : (duelOutcome === 'LOSS' ? -state.currentStake : 0),
                    multiplier: duelOutcome === 'WIN' ? (winAmount / state.currentStake) : 0,
                    opponent: state.activeMatch.player2.username // Use opponent's username from active match
                };
                gameHistory.addGameEntry(duelEntry);
                personalRecords.updateRecords(duelEntry);

                // Clear active match and return to lobby state
                state.activeMatch = null;
                matchmakingStatus.textContent = 'Ready for a new duel!';
                potDisplay.textContent = 'Total Pot: 0.00 SOL';
                playerStakeDisplay.textContent = '0.00 SOL';
                opponentStakeDisplay.textContent = '0.00 SOL';
                rollButton.style.display = 'none'; // Hide roll button
                stakeFindButton.style.display = 'block'; // Show stake & find button
                stakeFindButton.disabled = false; // Enable stake & find button

            }, 1500);
        }

        /* 16. Update Existing Animation Function */
        function animateDice(diceElements) {
            // Use enhanced animation
            animateDiceEnhanced(diceElements);
        }

        // Removed old flash effects as they are replaced by the result modal
        // function showWinEffect(amount, mode = 'solo') {
        //     const overlay = document.createElement('div');
        //     overlay.className = 'win-overlay';
        //     overlay.textContent = `+${amount.toFixed(2)} SOL!`;
        //     if (mode === 'duel') {
        //         overlay.textContent = `YOU WIN! +${amount.toFixed(2)} SOL!`;
        //     }
        //     document.body.appendChild(overlay);

        //     triggerConfetti();

        //     setTimeout(() => {
        //         overlay.remove();
        //     }, 1000);
        // }

        // function showLossEffect(mode = 'solo') {
        //     const overlay = document.createElement('div');
        //     overlay.className = 'loss-overlay';
        //     overlay.textContent = `YOU LOSE!`;
        //     if (mode === 'solo') {
        //         overlay.textContent = `- ${state.chipValue.toFixed(2)} SOL!`;
        //     }
        //     document.body.appendChild(overlay);

        //     setTimeout(() => {
        //         overlay.remove();
        //     }, 1000);
        // }

        function updateStreak(isWin) {
            if (isWin) {
                state.streak++;
                if (state.streak >= 3 && state.streak % 3 === 0) {
                     showStreakPopup();
                }
            } else {
                state.streak = 0;
            }
            updateHotStreakDisplay();
        }

        function showStreakPopup() {
            const popup = document.createElement('div');
            popup.className = 'streak-popup';
            popup.textContent = `🔥 Streak x${state.streak}!`;
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.remove();
            }, 1500);
        }

        function updateMultiplier() {
            let multiplier;
            if (state.rollMode === 'under') {
                multiplier = state.payouts[state.rollUnder];
            } else {
                multiplier = getPayoutForRollOver(state.rollUnder);
            }
            
            // Format multiplier display
            multiplierDisplay.textContent = `Payout: ${multiplier % 1 === 0 ? multiplier : multiplier.toFixed(2)}x`;
        }

        // Confetti function (existing)
        function triggerConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            const colors = ['#FF3366', '#00FF99', '#FFFFFF', '#FFD700'];

            // Create particles
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - canvas.height,
                    size: Math.random() * 10 + 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speedY: Math.random() * 3 + 2,
                    speedX: Math.random() * 4 - 2,
                    rotation: Math.random() * 360,
                    rotationSpeed: Math.random() * 10 - 5
                });
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let stillAlive = false;

                particles.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.rotation += p.rotationSpeed;

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation * Math.PI / 180);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                    ctx.restore();

                    if (p.y < canvas.height) {
                        stillAlive = true;
                    }
                });

                if (stillAlive) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        // Update hot streak display
        function updateHotStreakDisplay() {
             // Ensure hotStreakDisplay element exists before trying to access its style
             if (hotStreakDisplay) {
                if (state.streak > 0) {
                    hotStreakDisplay.style.display = 'block';
                    hotStreakDisplay.textContent = `🔥 Hot Streak! ${state.streak} Wins`;
                } else {
                    hotStreakDisplay.style.display = 'none';
                }
            }
        }


        // --- New Script for Added Features ---

        // --- Modals ---
        const walletModal = document.getElementById('wallet-modal');
        const profileModal = document.getElementById('profile-modal');
        const depositModal = document.getElementById('deposit-modal');
        const withdrawModal = document.getElementById('withdraw-modal');

        // Close handlers for result modal
        resultCloseBtn.addEventListener('click', () => {
            resultModal.style.display = 'none';
        });

        document.querySelector('#result-modal .close-button').addEventListener('click', () => {
            resultModal.style.display = 'none';
        });

        const closeButtons = document.querySelectorAll('.modal .close-button');

        // Close Modals
        closeButtons.forEach(button => {
            button.addEventListener('click', function() {
                this.closest('.modal').style.display = 'none';
                realWallet.resetModalState(); // Reset wallet modal state on close
            });
        });

        window.addEventListener('click', (event) => {
            if (event.target === walletModal) { 
                walletModal.style.display = 'none'; 
                realWallet.resetModalState(); // Reset wallet modal state on close
            }
            if (event.target === profileModal) { profileModal.style.display = 'none'; }
            if (event.target === depositModal) { depositModal.style.display = 'none'; }
            if (event.target === withdrawModal) { withdrawModal.style.display = 'none'; }
            if (event.target === resultModal) { resultModal.style.display = 'none'; } // Close result modal on outside click
            if (event.target === provablyFairModal) { provablyFairModal.style.display = 'none'; } // Close provably fair modal
            if (event.target === settingsModal) { settingsModal.style.display = 'none'; } // Close settings modal
            if (event.target === historyModal) { historyModal.style.display = 'none'; } // Close history modal
        });


        // --- Real Wallet Connection Implementation ---
        class RealWalletManager {
            constructor() {
                this.isConnected = false;
                this.address = null;
                this.balance = 0;
                this.walletType = null;
                this.walletAdapter = null;
                this.publicKey = null;
                this.balanceRefreshInterval = null; // QUICK BALANCE REFRESH
                this.connectionTimeout = null; // UI/UX SAFETY: Wallet connection timeout
            }

            async connectWallet(walletType) {
                try {
                    this.showConnectingScreen(walletType);
                    
                    // UI/UX SAFETY: Set a timeout for wallet connection
                    const connectionPromise = new Promise(async (resolve, reject) => {
                        this.connectionTimeout = setTimeout(() => {
                            reject(new Error('Wallet connection timed out. Please try again or check your wallet app.'));
                        }, 15000); // 15 seconds timeout

                        try {
                            // Mobile deep linking check
                            if (this.isMobile() && !this.isWalletAvailable(walletType)) {
                                this.redirectToWalletApp(walletType);
                                return; // Exit if redirecting
                            }

                            const adapter = this.getWalletAdapter(walletType);
                            if (!adapter) {
                                throw new Error(`${walletType} wallet not found. Please install the ${walletType} extension.`);
                            }

                            const connectionResult = await adapter.connect();
                            this.walletAdapter = adapter;
                            this.publicKey = connectionResult.publicKey || adapter.publicKey;
                            this.address = this.publicKey.toString();
                            this.walletType = walletType;

                            clearTimeout(this.connectionTimeout); // Clear timeout on successful connection
                            resolve();

                        } catch (error) {
                            clearTimeout(this.connectionTimeout); // Clear timeout on error
                            reject(error);
                        }
                    });

                    await connectionPromise; // Wait for connection or timeout

                    this.showVerificationScreen();

                    await this.verifyWalletOwnership();

                    await this.fetchBalance();

                    this.isConnected = true;
                    this.showSuccessScreen();
                    this.updateWalletUI();
                    this.startBalanceRefresh(); // QUICK BALANCE REFRESH

                } catch (error) {
                    showMessageBox(`Wallet connection error: ${error.message}`, 'error');
                    this.showErrorScreen(error.message);
                }
            }

            async verifyWalletOwnership() {
                try {
                    if (typeof nacl === 'undefined') {
                        throw new Error('Cryptographic library not loaded. Please refresh the page.');
                    }

                    const message = `DegenDice Auth: ${Date.now()}`;
                    const encodedMessage = new TextEncoder().encode(message);
                    
                    const signedMessage = await this.walletAdapter.signMessage(encodedMessage, "utf8");
                    let signature = signedMessage.signature || signedMessage;
                    
                    if (typeof signature === 'string') {
                        try {
                            signature = bs58_decode(signature);
                        } catch (decodeError) {
                            throw new Error('Invalid signature format received from wallet');
                        }
                    }
                    
                    if (!(signature instanceof Uint8Array)) {
                        throw new Error('Signature must be a Uint8Array');
                    }
                    
                    let publicKeyBytes;
                    try {
                        publicKeyBytes = this.publicKey.toBytes();
                    } catch (keyError) {
                        throw new Error('Invalid public key format');
                    }
                    
                    const isValid = nacl.sign.detached.verify(
                        encodedMessage,
                        signature,
                        publicKeyBytes
                    );

                    if (!isValid) {
                        throw new Error('Signature verification failed - invalid signature');
                    }

                } catch (error) {
                    throw new Error('Failed to verify wallet ownership: ' + error.message);
                }
            }

            async fetchBalance() {
                try {
                    const connection = new solanaWeb3.Connection(
                        solanaWeb3.clusterApiUrl("mainnet-beta"),
                        "confirmed"
                    );
                    
                    const balance = await connection.getBalance(this.publicKey);
                    this.balance = balance / solanaWeb3.LAMPORTS_PER_SOL;
                    showMessageBox('Balance refreshed!', 'success');
                }
                /* Removed notification spam from here */
                catch (error) {
                    showMessageBox('Failed to refresh balance. Please try again.', 'error');
                } finally {
                    balanceRefreshIcon.classList.remove('fa-spin'); // QUICK BALANCE REFRESH
                }
            }

            getWalletAdapter(walletType) {
                if (walletType === 'phantom') {
                    const isAvailable = window.solana && window.solana.isPhantom;
                    return isAvailable ? window.solana : null;
                } else if (walletType === 'solflare') {
                    const isAvailable = window.solflare && window.solflare.isSolflare;
                    return isAvailable ? window.solflare : null;
                }
                
                return null;
            }

            isWalletAvailable(walletType) {
                if (walletType === 'phantom') {
                    return window.solana && window.solana.isPhantom;
                } else if (walletType === 'solflare') {
                    return window.solflare && window.solflare.isSolflare;
                }
                return false;
            }

            isMobile() {
                return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            }

            redirectToWalletApp(walletType) {
                const currentUrl = encodeURIComponent(window.location.href);
                if (walletType === 'phantom') {
                    window.location.href = `https://phantom.app/ul/browse/${currentUrl}`;
                } else if (walletType === 'solflare') {
                    window.location.href = `https://solflare.com/ul/v1/browse/${currentUrl}`;
                }
            }

            showConnectingScreen(walletType) {
                document.getElementById('wallet-selection-screen').style.display = 'none';
                document.getElementById('wallet-connecting-screen').style.display = 'block';
                document.getElementById('selected-wallet-name').textContent = walletType.charAt(0).toUpperCase() + walletType.slice(1);
            }

            showVerificationScreen() {
                    document.getElementById('wallet-connecting-screen').style.display = 'none';
                    document.getElementById('wallet-verification-screen').style.display = 'block';
                    document.getElementById('wallet-address-display').textContent = this.address;
            }

            showSuccessScreen() {
                document.getElementById('wallet-verification-screen').style.display = 'none';
                document.getElementById('wallet-success-screen').style.display = 'block';
            }

            showErrorScreen(errorMessage) {
                document.querySelectorAll('#wallet-modal > .modal-content > div[id*="screen"]').forEach(screen => {
                    screen.style.display = 'none';
                });
                document.getElementById('wallet-error-screen').style.display = 'block';
                document.getElementById('wallet-error-message').textContent = errorMessage;
            }

            resetModalState() {
                document.querySelectorAll('#wallet-modal > .modal-content > div[id*="screen"]').forEach(screen => {
                    screen.style.display = 'none';
                });
                document.getElementById('wallet-selection-screen').style.display = 'block';
                if (this.connectionTimeout) { // Clear any pending timeout on modal reset
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
            }

            disconnect() {
                this.isConnected = false;
                this.address = null;
                this.balance = 0;
                this.walletType = null;
                this.walletAdapter = null;
                this.publicKey = null;
                this.stopBalanceRefresh(); // QUICK BALANCE REFRESH
                this.updateWalletUI(); // This will now also call updateMobileMenuVisibility()
                showMessageBox('Wallet disconnected.', 'info');
            }

            updateWalletUI() {
                const walletInfo = document.getElementById('wallet-info');
                const headerBalance = document.getElementById('header-balance');
        
                if (this.isConnected) {
                    walletInfo.innerHTML = `<i class="fas fa-wallet"></i> Connected`;
                    headerBalance.classList.add('connected'); // Show balance
                } else {
                    walletInfo.innerHTML = `<i class="fas fa-wallet"></i> Connect Wallet`;
                    headerBalance.classList.remove('connected'); // Hide balance
                }
        
                updateBalanceDisplay();
                updateMobileMenuVisibility();
                this.updateTransactionModals();
            }

            updateTransactionModals() {
                const depositNotConnected = document.getElementById('deposit-not-connected');
                const depositConnected = document.getElementById('deposit-connected');
                const depositCurrentBalance = document.getElementById('deposit-current-balance');
                
                const withdrawNotConnected = document.getElementById('withdraw-not-connected');
                const withdrawConnected = document.getElementById('withdraw-connected');
                const withdrawCurrentBalance = document.getElementById('withdraw-current-balance');
                
                if (this.isConnected) {
                    depositNotConnected.style.display = 'none';
                    depositConnected.style.display = 'block';
                    depositCurrentBalance.textContent = this.balance.toFixed(3);
                    
                    withdrawNotConnected.style.display = 'none';
                    withdrawConnected.style.display = 'block';
                    withdrawCurrentBalance.textContent = this.balance.toFixed(3);
                    
                    document.getElementById('confirm-deposit-btn').disabled = false;
                    document.getElementById('confirm-withdraw-btn').disabled = false;
                } else {
                    depositNotConnected.style.display = 'block';
                    depositConnected.style.display = 'none';
                    
                    withdrawNotConnected.style.display = 'block';
                    withdrawConnected.style.display = 'none';
                }
                
                this.updateUsdValueEstimates();
            }

            updateUsdValueEstimates() {
                // PRODUCTION SETTINGS: Define SOL price
                const solPriceUsd = 173.45; // Example current SOL price

                const depositAmount = parseFloat(document.getElementById('deposit-amount').value) || 0;
                const withdrawAmount = parseFloat(document.getElementById('withdraw-amount').value) || 0;
                
                document.getElementById('deposit-usd-value').textContent = (depositAmount * solPriceUsd).toFixed(2);
                document.getElementById('withdraw-usd-value').textContent = (withdrawAmount * solPriceUsd).toFixed(2);
            }

            // QUICK BALANCE REFRESH BUTTON START
            startBalanceRefresh() {
                this.stopBalanceRefresh(); // Clear any existing interval
                this.balanceRefreshInterval = setInterval(() => {
                    if (this.isConnected) {
                        this.fetchBalance();
                    }
                }, 30000); // Refresh every 30 seconds
            }

            stopBalanceRefresh() {
                if (this.balanceRefreshInterval) {
                    clearInterval(this.balanceRefreshInterval);
                    this.balanceRefreshInterval = null;
                }
            }
            // QUICK BALANCE REFRESH BUTTON END
        }
        const realWallet = new RealWalletManager();
        const mockWallet = realWallet; // For backward compatibility with existing mock references

        realWallet.updateWalletUI();

        // --- Leaderboard (Mock) ---
        const leaderboardList = document.getElementById('leaderboard-list');

        let mockLeaderboardData = [
            { id: 1, username: 'CryptoKing', avatar: '😎', wins: 150 },
            { id: 2, username: 'SOL_Roller', avatar: '🥳', wins: 120 },
            { id: 3, username: 'DegenMaster', avatar: '🤩', wins: 95 },
            { id: 4, username: 'LuckyCharm', avatar: '🍀', wins: 88 },
            { id: 5, username: 'BlockchainPro', avatar: '💎', wins: 76 },
            { id: 6, username: 'NFT_Gamer', avatar: '🎮', wins: 65 },
            { id: 7, username: 'YieldFarmer', avatar: '🧑‍🌾', wins: 50 },
            { id: 8, username: 'TokenTrader', avatar: '📈', wins: 45 },
            { id: 9, username: 'Web3_Novice', avatar: '🐣', wins: 30 },
            { id: 10, username: 'HODLer', avatar: '🧘', wins: 25 },
        ];

        function renderLeaderboard() {
            leaderboardList.innerHTML = '';
            mockLeaderboardData.sort((a, b) => b.wins - a.wins);
            mockLeaderboardData.slice(0, 10).forEach(player => {
                const listItem = document.createElement('li');
                listItem.className = 'leaderboard-item fade-in';
                listItem.innerHTML = `
                    <div class="player-info">
                        <span class="avatar">${player.avatar}</span>
                        <span class="username">${player.username}</span>
                    </div>
                    <span class="wins">${player.wins} Wins</span>
                `;
                leaderboardList.appendChild(listItem);
            });
        }

        function updateLeaderboardWins() {
            if (realWallet.isConnected && realWallet.address) {
                 let currentUser = mockLeaderboardData.find(player => player.id === mockAuth.currentUser.uid);
                 if (!currentUser) {
                     const username = localStorage.getItem('username') || 'You';
                     const avatar = localStorage.getItem('avatar') || '👤';
                     currentUser = { id: mockAuth.currentUser.uid, username: username, avatar: avatar, wins: 0 };
                     mockLeaderboardData.push(currentUser);
                 }
                 currentUser.wins++;
                 renderLeaderboard();
                 mockFirestore.addDoc('playerStats', { userId: mockAuth.currentUser.uid, wins: currentUser.wins });
            }
        }

        renderLeaderboard();


        // --- Chat System (Mock) ---
        const chatContainer = document.getElementById('chat-container');
        const chatHeader = document.getElementById('chat-header');
        const chatBody = document.getElementById('chat-body');
        const chatInput = document.getElementById('chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        const chatBubbleIcon = document.getElementById('chat-bubble-icon');

        let mockChatMessages = [
            { username: 'System', text: 'Welcome to DegenDice Chat!', type: 'system' },
            { username: 'CryptoKing', text: 'Just hit a x35!', type: 'user' },
            { username: 'LuckyCharm', text: 'Nice one!', type: 'user' },
        ];

        function renderChatMessages() {
            chatBody.innerHTML = '';
            mockChatMessages.forEach(msg => {
                const msgElement = document.createElement('div');
                msgElement.className = 'chat-message';
                if (msg.type === 'system') {
                    msgElement.style.fontStyle = 'italic';
                    msgElement.style.opacity = 0.7;
                    msgElement.textContent = msg.text;
                } else {
                     msgElement.innerHTML = `<span class="username">${msg.username}:</span> ${msg.text}`;
                }
                chatBody.appendChild(msgElement);
            });
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function sendChatMessage() {
            const text = chatInput.value.trim();
            if (text) {
                 const username = localStorage.getItem('username') || 'Anonymous';
                mockChatMessages.push({ username: username, text: text, type: 'user' });
                chatInput.value = '';
                renderChatMessages();
                 // Removed automatic simulated message after every user message
                 // setTimeout(simulateNewChatMessage, 1000); 
            }
        }

        sendChatBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        });

        function simulateNewChatMessage() {
             const simulatedMessages = [
                 { username: 'SOL_Roller', text: 'Anyone on a hot streak?', type: 'user' },
                 { username: 'DegenMaster', text: 'Just started, feeling lucky!', type: 'user' },
                 { username: 'System', text: 'A new player joined!', type: 'system' }
             ];
             const randomMsg = simulatedMessages[Math.floor(Math.random() * simulatedMessages.length)];
             mockChatMessages.push(randomMsg);
             renderChatMessages();
        }

        // Reduced frequency of simulated messages to avoid spam
        setInterval(simulateNewChatMessage, 15000); // Every 15 seconds

        renderChatMessages();

        chatContainer.addEventListener('click', (e) => {
            if (window.innerWidth <= 768) {
                e.stopPropagation();
                if (!document.body.classList.contains('chat-open')) {
                    document.body.classList.add('chat-open');
                    document.getElementById('chat-header').style.display = 'flex';
                    document.getElementById('chat-body').style.display = 'flex';
                    document.getElementById('chat-input').parentElement.style.display = 'flex';
                    document.getElementById('chat-bubble-icon').style.display = 'none';
                }
            }
        });

        chatHeader.addEventListener('click', (e) => {
            e.stopPropagation();
            if (window.innerWidth <= 768 && document.body.classList.contains('chat-open')) {
                document.body.classList.remove('chat-open');
                setTimeout(() => {
                    if (window.innerWidth <= 768 && !document.body.classList.contains('chat-open')) {
                        document.getElementById('chat-header').style.display = 'none';
                        document.getElementById('chat-body').style.display = 'none';
                        document.getElementById('chat-input').parentElement.style.display = 'none';
                        document.getElementById('chat-bubble-icon').style.display = 'flex';
                    }
                }, 300);
            }
        });


        // --- Profile System ---
        const usernameInput = document.getElementById('username-input');
        const saveProfileBtn = document.getElementById('save-profile-btn'); // This ID will be updated to update-profile-btn
        const profileAvatarIcon = document.querySelector('#profile-avatar-new i');

        function loadProfile() {
            const savedUsername = localStorage.getItem('username');
            const savedAvatar = localStorage.getItem('avatar');

            if (savedUsername) {
                usernameInput.value = savedUsername;
                mockAuth.currentUser.displayName = savedUsername;
            }
            if (savedAvatar) {
                profileAvatarIcon.className = ''; // Clear existing classes
                if (savedAvatar.startsWith('http')) { // If it's a URL
                    profileAvatarIcon.innerHTML = `<img src="${savedAvatar}" onerror="this.src='https://placehold.co/40x40/000000/FFFFFF?text=?'" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                } else { // Assume it's an emoji
                    profileAvatarIcon.textContent = savedAvatar;
                }
                mockAuth.currentUser.photoURL = savedAvatar;
                currentAvatarPreview.innerHTML = profileAvatarIcon.innerHTML; // Update preview
            } else {
                 profileAvatarIcon.className = '';
                 profileAvatarIcon.textContent = '👤';
                 mockAuth.currentUser.photoURL = '👤';
                 currentAvatarPreview.textContent = '👤';
            }
            renderAvatarSelectionGrid(); // Render grid on profile load
            selectAvatarInGrid(savedAvatar || '👤'); // Select current avatar in grid
        }

        // Replace the existing saveProfileBtn event listener with:
        document.getElementById('update-profile-btn').addEventListener('click', () => {
            const username = usernameInput.value.trim();
            const avatar = localStorage.getItem('avatar') || '👤';
            if (username) {
                localStorage.setItem('username', username);
            } else {
                localStorage.removeItem('username');
            }
            loadProfile(); // Update profile display immediately
            profileModal.style.display = 'none';
                
            if (realWallet.isConnected && realWallet.address) {
                let currentUser = mockLeaderboardData.find(player => player.id === mockAuth.currentUser.uid);
                if (currentUser) {
                    currentUser.username = username || 'You';
                    currentUser.avatar = avatar;
                    renderLeaderboard();
                }
            }
            showMessageBox('Profile updated successfully!', 'success');
        });
        // Remove the old saveProfileBtn reference and update the HTML ID
        // Note: The old saveProfileBtn variable is no longer needed, and the HTML ID is updated in the HTML section.


        loadProfile();


        // --- Deposit & Withdraw (Mock) ---
        const depositAmountInput = document.getElementById('deposit-amount');
        const confirmDepositBtn = document.getElementById('confirm-deposit-btn');
        const withdrawAmountInput = document.getElementById('withdraw-amount');
        const confirmWithdrawBtn = document.getElementById('confirm-withdraw-btn');

        document.getElementById('deposit-connect-wallet-btn').addEventListener('click', () => {
            depositModal.style.display = 'none';
            walletModal.style.display = 'flex';
        });

        document.getElementById('withdraw-connect-wallet-btn').addEventListener('click', () => {
            withdrawModal.style.display = 'none';
            walletModal.style.display = 'flex';
        });

        // New functions for deposit/withdraw amount buttons
        function setDepositAmount(value) {
            document.getElementById('deposit-amount').value = value.toFixed(2);
            realWallet.updateUsdValueEstimates();
        }

        function incrementDepositAmount(increment) {
            const depositInput = document.getElementById('deposit-amount');
            const currentValue = parseFloat(depositInput.value || 0);
            depositInput.value = (Math.max(currentValue + increment, 0.1)).toFixed(2);
            realWallet.updateUsdValueEstimates(); // Update USD display
        }

        function setWithdrawAmount(value) {
            document.getElementById('withdraw-amount').value = value.toFixed(2);
            realWallet.updateUsdValueEstimates();
        }

        function incrementWithdrawAmount(increment) {
            const withdrawInput = document.getElementById('withdraw-amount');
            const currentValue = parseFloat(withdrawInput.value || 0);
            withdrawInput.value = (Math.max(currentValue + increment, 0.1)).toFixed(2);
            realWallet.updateUsdValueEstimates(); // Update USD display
        }

        confirmDepositBtn.addEventListener('click', () => {
            if (!realWallet.isConnected) {
                showMessageBox('Please connect your wallet first!', 'warning');
                depositModal.style.display = 'none';
                walletModal.style.display = 'flex';
                return;
            }
            
            const amount = parseFloat(depositAmountInput.value);
            if (amount > 0) {
                showMessageBox(`Processing deposit of ${amount.toFixed(2)} SOL...`, 'info');
                
                confirmDepositBtn.disabled = true;
                confirmDepositBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                
                setTimeout(() => {
                    realWallet.balance += amount;
                    realWallet.updateWalletUI();
                    depositModal.style.display = 'none';
                    
                    showMessageBox(`Successfully deposited ${amount.toFixed(2)} SOL!`, 'success');
                    confirmDepositBtn.disabled = false;
                    confirmDepositBtn.textContent = 'DEPOSIT';
                }, 2000);
            } else {
                showMessageBox('Please enter a valid deposit amount.', 'error');
            }
        });

        confirmWithdrawBtn.addEventListener('click', () => {
            if (!realWallet.isConnected) {
                showMessageBox('Please connect your wallet first!', 'warning');
                withdrawModal.style.display = 'none';
                walletModal.style.display = 'flex';
                return;
            }
            
            const amount = parseFloat(withdrawAmountInput.value);
            if (amount > 0 && amount <= realWallet.balance) {
                showMessageBox(`Processing withdrawal of ${amount.toFixed(2)} SOL...`, 'info');
                
                confirmWithdrawBtn.disabled = true;
                confirmWithdrawBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                
                setTimeout(() => {
                    realWallet.balance -= amount;
                    realWallet.updateWalletUI();
                    withdrawModal.style.display = 'none';
                    
                    showMessageBox(`Successfully withdrew ${amount.toFixed(2)} SOL!`, 'success');
                    confirmWithdrawBtn.disabled = false;
                    confirmWithdrawBtn.textContent = 'WITHDRAW';
                }, 2000);
            } else if (amount > realWallet.balance) {
                showMessageBox('Insufficient balance for withdrawal.', 'error');
            } else {
                showMessageBox('Please enter a valid withdrawal amount.', 'error');
            }
        });

        document.getElementById('deposit-amount').addEventListener('input', () => {
            realWallet.updateUsdValueEstimates();
        });

        document.getElementById('withdraw-amount').addEventListener('input', () => {
            realWallet.updateUsdValueEstimates();
        });


        // --- Engagement Boosters ---

        // Sound Effects
        const rollSound = new Audio('https://www.soundjay.com/mechanical/gears-01.wav');
        const winSound = new Audio('https://www.soundjay.com/human/applause-01.wav');
        const lossSound = new Audio('https://www.soundjay.com/misc/fart-01.wav');
        const uiSound = new Audio('https://www.soundjay.com/button/button-10.wav'); // Generic UI sound

        // UI/UX SAFETY: Robust sound system error catching
        function playSound(audioElement) {
            if (state.soundSettings.masterVolume > 0) {
                audioElement.volume = state.soundSettings.masterVolume;
                audioElement.currentTime = 0;
                audioElement.play().catch(e => console.error("Error playing sound:", e));
            }
        }

        function playRollSound() {
            if (state.soundSettings.rollSound) {
                playSound(rollSound);
            }
        }

        function playResultSound(type) {
            if (state.soundSettings.resultSound) {
                if (type === 'win') {
                    playSound(winSound);
                } else if (type === 'loss') {
                    playSound(lossSound);
                }
            }
        }

        function playUISound() {
            if (state.soundSettings.uiSound) {
                playSound(uiSound);
            }
        }

        // Coin Shower Animation (using existing triggerConfetti function)
        function triggerCoinShower() {
            triggerConfetti();
        }

        // Daily Challenge
        const dailyChallengePanel = document.getElementById('daily-challenge-panel');
        const challengeText = document.getElementById('challenge-text');
        const challengeProgress = document.getElementById('challenge-progress');
        const claimRewardBtn = document.getElementById('claim-reward-btn');

        const dailyChallenge = {
            description: "Roll under 5 three times",
            targetValue: 5,
            targetCount: 3,
            currentProgress: 0,
            rewardAmount: 0.1,
            isCompleted: false
        };

        function loadDailyChallengeProgress() {
            const savedProgress = localStorage.getItem('dailyChallengeProgress');
            if (savedProgress !== null) {
                dailyChallenge.currentProgress = parseInt(savedProgress);
            }
            const savedCompletion = localStorage.getItem('dailyChallengeCompleted');
            if (savedCompletion === 'true') {
                dailyChallenge.isCompleted = true;
            }
             updateDailyChallengeUI();
        }

        function updateDailyChallengeUI() {
            challengeText.textContent = dailyChallenge.description;
            challengeProgress.textContent = `Progress: ${dailyChallenge.currentProgress}/${dailyChallenge.targetCount}`;

            if (dailyChallenge.isCompleted) {
                challengeProgress.textContent = "Completed!";
                claimRewardBtn.style.display = 'none';
            } else if (dailyChallenge.currentProgress >= dailyChallenge.targetCount) {
                 claimRewardBtn.style.display = 'block';
            } else {
                 claimRewardBtn.style.display = 'none';
            }
        }

        function checkDailyChallenge() {
            if (!dailyChallenge.isCompleted && state.rollResult === 'WIN' && (state.diceValues[0] + state.diceValues[1]) < dailyChallenge.targetValue) {
                dailyChallenge.currentProgress++;
                localStorage.setItem('dailyChallengeProgress', dailyChallenge.currentProgress);
                updateDailyChallengeUI();
                if (dailyChallenge.currentProgress >= dailyChallenge.targetCount) {
                     dailyChallenge.isCompleted = true;
                     localStorage.setItem('dailyChallengeCompleted', 'true');
                     updateDailyChallengeUI();
                     showMessageBox('Daily Challenge Completed! Claim your reward.', 'success');
                }
            }
        }

        claimRewardBtn.addEventListener('click', () => {
            if (dailyChallenge.isCompleted && !localStorage.getItem('dailyChallengeClaimed')) {
                 showMessageBox(`Claiming mock reward of ${dailyChallenge.rewardAmount} SOL!`, 'info');
                 realWallet.balance += dailyChallenge.rewardAmount;
                 realWallet.updateWalletUI();
                 localStorage.setItem('dailyChallengeClaimed', 'true');
                 claimRewardBtn.style.display = 'none';
            } else {
                 showMessageBox('Reward already claimed or challenge not completed.', 'warning');
            }
        });

        loadDailyChallengeProgress();


        // Referral Feature
        const referralCodeElement = document.getElementById('referral-code');
        const copyReferralBtn = document.getElementById('copy-referral-btn');

        function generateReferralCode() {
             const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
             let code = '';
             for (let i = 0; i < 7; i++) {
                 code += characters.charAt(Math.floor(Math.random() * characters.length));
             }
             return code;
        }

        referralCodeElement.textContent = generateReferralCode();

        copyReferralBtn.addEventListener('click', () => {
             const code = referralCodeElement.textContent;
             const tempInput = document.createElement('textarea');
             tempInput.value = code;
             document.body.appendChild(tempInput);
             tempInput.select();
             try {
                 document.execCommand('copy');
                 showMessageBox('Referral code copied to clipboard!', 'success');
             } catch (err) {
                 console.error('Failed to copy referral code: ', err);
                 showMessageBox('Could not copy referral code.', 'error');
             }
             document.body.removeChild(tempInput);
        });


        // --- UI/UX Enhancements ---

        // Adjust leaderboard and chat visibility on window resize
        window.addEventListener('resize', () => {
            const leaderboardContent = document.getElementById('leaderboard-content');
            const chatContainer = document.getElementById('chat-container');
            const chatHeader = document.getElementById('chat-header');
            const chatBody = document.getElementById('chat-body');
            const chatInput = document.getElementById('chat-input');
            const chatBubbleIcon = document.getElementById('chat-bubble-icon');

            if (window.innerWidth > 768) {
                document.body.classList.remove('leaderboard-open');
                document.body.classList.remove('chat-open');
                // leaderboardContent.style.transform = 'translateX(0)'; // No longer needed for tabbed content

                chatContainer.style.position = 'fixed';
                chatContainer.style.width = 'var(--chat-width)';
                chatContainer.style.height = 'var(--chat-height)';
                chatContainer.style.bottom = 'calc(1rem + env(safe-area-inset-bottom))';
                chatContainer.style.right = '1rem';
                chatContainer.style.top = 'auto';
                chatContainer.style.left = 'auto';
                chatContainer.style.borderRadius = 'var(--radius-md)';
                chatContainer.style.background = 'rgba(20, 20, 20, 0.9)';
                chatContainer?.style?.setProperty('box-shadow', 'var(--shadow-glow) rgba(255, 255, 255, 0.1)');
                chatContainer.style.cursor = 'default';

                chatBubbleIcon.style.display = 'none';
                chatHeader.style.display = 'flex';
                chatBody.style.display = 'flex';
                chatInput.parentElement.style.display = 'flex';
            } else {
                // leaderboardContent.style.transform = 'translateX(100%)'; // No longer needed for tabbed content

                if (!document.body.classList.contains('chat-open')) {
                    chatContainer.style.position = 'fixed';
                    chatContainer.style.width = 'var(--chat-bubble-size)';
                    chatContainer.style.height = 'var(--chat-bubble-size)';
                    chatContainer.style.bottom = 'calc(1rem + env(safe-area-inset-bottom))';
                    chatContainer.style.right = '1rem';
                    chatContainer.style.top = 'auto';
                    chatContainer.style.left = 'auto';
                    chatContainer.style.borderRadius = '50%';
                    chatContainer.style.background = 'var(--accent-pink)';
                    chatContainer.style.boxShadow = '0 0 10px var(--accent-pink)';
                    chatContainer.style.cursor = 'pointer';

                    chatBubbleIcon.style.display = 'flex';
                    chatHeader.style.display = 'none';
                    chatBody.style.display = 'none';
                    chatInput.parentElement.style.display = 'none';
                }
            }
        });

        window.dispatchEvent(new Event('resize'));


        const profileAvatarNew = document.getElementById('profile-avatar-new');
        const profileDropdown = document.getElementById('profile-dropdown');
        const dropdownProfileBtn = document.getElementById('dropdown-profile-btn');
        const dropdownDepositBtn = document.getElementById('dropdown-deposit-btn');
        const dropdownWithdrawBtn = document.getElementById('dropdown-withdraw-btn');
        const dropdownProvablyFairBtn = document.getElementById('dropdown-provably-fair-btn'); // PROVABLY FAIR
        const dropdownSettingsBtn = document.getElementById('dropdown-settings-btn'); // SETTINGS
        const dropdownHistoryBtn = document.getElementById('dropdown-history-btn'); // HISTORY
        // const dropdownReferralBtn = document.getElementById('dropdown-referral-btn'); // Removed
        const dropdownDisconnectBtn = document.getElementById('dropdown-disconnect-btn');

        const hamburgerMenu = document.getElementById('hamburger-menu');
        const mobileNavOverlay = document.getElementById('mobile-nav-overlay');
        const mobileProfileBtn = document.getElementById('mobile-profile-btn');
        const mobileDepositBtn = document.getElementById('mobile-deposit-btn');
        const mobileWithdrawBtn = document.getElementById('mobile-withdraw-btn');
        const mobileProvablyFairBtn = document.getElementById('mobile-provably-fair-btn'); // PROVABLY FAIR
        const mobileSettingsBtn = document.getElementById('mobile-settings-btn'); // SETTINGS
        const mobileHistoryBtn = document.getElementById('mobile-history-btn'); // HISTORY
        // const mobileReferralBtn = document.getElementById('mobile-referral-btn'); // Removed
        const mobileDisconnectBtn = document.getElementById('mobile-disconnect-btn');
        const mobileConnectWalletBtn = document.getElementById('mobile-connect-wallet-btn');

        document.getElementById('close-menu-btn').addEventListener('click', () => {
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
        });

        dropdownProfileBtn.addEventListener('click', (e) => {
             e.preventDefault();
             profileModal.style.display = 'flex';
             profileDropdown.classList.remove('show');
         });
        dropdownDepositBtn.addEventListener('click', (e) => {
             e.preventDefault();
             depositModal.style.display = 'flex';
             profileDropdown.classList.remove('show');
             realWallet.updateTransactionModals();
         });
        dropdownWithdrawBtn.addEventListener('click', (e) => {
             e.preventDefault();
             withdrawModal.style.display = 'flex';
             profileDropdown.classList.remove('show');
             realWallet.updateTransactionModals();
         });
        // PROVABLY FAIR START
        dropdownProvablyFairBtn.addEventListener('click', (e) => {
            e.preventDefault();
            provablyFairModal.style.display = 'flex';
            profileDropdown.classList.remove('show');
            updateProvablyFairUI();
        });
        // PROVABLY FAIR END
        // SETTINGS START
        dropdownSettingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            settingsModal.style.display = 'flex';
            profileDropdown.classList.remove('show');
            loadSoundSettings(); // Load settings when modal opens
        });
        // SETTINGS END
        // HISTORY START
        dropdownHistoryBtn.addEventListener('click', (e) => {
            e.preventDefault();
            historyModal.style.display = 'flex';
            profileDropdown.classList.remove('show');
            gameHistory.renderHistory();
            personalRecords.updateDisplay();
        });
        // HISTORY END
        // Removed dropdownReferralBtn event listener
        dropdownDisconnectBtn.addEventListener('click', (e) => {
            e.preventDefault();
            realWallet.disconnect();
            profileDropdown.classList.remove('show');
        });

        mobileProfileBtn.addEventListener('click', (e) => {
             e.preventDefault();
             profileModal.style.display = 'flex';
             mobileNavOverlay.classList.remove('show');
             hamburgerMenu.classList.remove('active');
         });
        mobileDepositBtn.addEventListener('click', (e) => {
             e.preventDefault();
             depositModal.style.display = 'flex';
             mobileNavOverlay.classList.remove('show');
             hamburgerMenu.classList.remove('active');
             realWallet.updateTransactionModals();
         });
        mobileWithdrawBtn.addEventListener('click', (e) => {
             e.preventDefault();
             withdrawModal.style.display = 'flex';
             mobileNavOverlay.classList.remove('show');
             hamburgerMenu.classList.remove('active');
             realWallet.updateTransactionModals();
         });
        // PROVABLY FAIR START
        mobileProvablyFairBtn.addEventListener('click', (e) => {
            e.preventDefault();
            provablyFairModal.style.display = 'flex';
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
            updateProvablyFairUI();
        });
        // PROVABLY FAIR END
        // SETTINGS START
        mobileSettingsBtn.addEventListener('click', (e) => {
            e.preventDefault();
            settingsModal.style.display = 'flex';
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
            loadSoundSettings();
        });
        // SETTINGS END
        // HISTORY START
        mobileHistoryBtn.addEventListener('click', (e) => {
            e.preventDefault();
            historyModal.style.display = 'flex';
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
            gameHistory.renderHistory();
            personalRecords.updateDisplay();
        });
        // HISTORY END
        // Removed mobileReferralBtn event listener
        mobileDisconnectBtn.addEventListener('click', (e) => {
            e.preventDefault();
            realWallet.disconnect();
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
        });
        mobileConnectWalletBtn.addEventListener('click', (e) => {
             e.preventDefault();
             walletModal.style.display = 'flex';
             mobileNavOverlay.classList.remove('show');
             hamburgerMenu.classList.remove('active');
         });

        profileAvatarNew.addEventListener('click', (event) => {
            event.stopPropagation();
            profileDropdown.classList.toggle('show');
        });

        hamburgerMenu.addEventListener('click', () => {
            hamburgerMenu.classList.toggle('active');
            mobileNavOverlay.classList.toggle('show');
        });

        window.addEventListener('click', (event) => {
            if (!event.target.closest('.profile-dropdown-container') && profileDropdown.classList.contains('show')) {
                profileDropdown.classList.remove('show');
            }
            if (event.target === mobileNavOverlay) {
                mobileNavOverlay.classList.remove('show');
                hamburgerMenu.classList.remove('active');
            }
        });

        document.getElementById('connect-phantom').addEventListener('click', () => {
            realWallet.connectWallet('phantom');
        });

        document.getElementById('connect-solflare').addEventListener('click', () => {
            realWallet.connectWallet('solflare');
        });

        document.getElementById('wallet-success-continue').addEventListener('click', () => {
            document.getElementById('wallet-modal').style.display = 'none';
            realWallet.resetModalState();
            realWallet.updateTransactionModals();
            updateMobileMenuVisibility(); // Add this line to ensure mobile menu updates
        });

        document.getElementById('wallet-error-retry').addEventListener('click', () => {
            realWallet.resetModalState();
        });

        document.getElementById('wallet-info').addEventListener('click', () => {
            if (!realWallet.isConnected) {
                document.getElementById('wallet-modal').style.display = 'flex';
                realWallet.resetModalState();
            }
        });

        document.querySelector('#wallet-modal .close-button').addEventListener('click', () => {
            document.getElementById('wallet-modal').style.display = 'none';
            realWallet.resetModalState();
        });

        window.addEventListener('click', (event) => {
            if (event.target === document.getElementById('wallet-modal')) {
                document.getElementById('wallet-modal').style.display = 'none';
                realWallet.resetModalState();
            }
        });

        function updateBalanceDisplay() {
            const balance = realWallet.balance || 0;
            const balanceText = `${balance.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            })}`;
                
            // Update header balance
            const headerBalance = document.querySelector('#header-balance #balance-amount');
            if (headerBalance) {
                headerBalance.textContent = balanceText;
            }
        }

        function handleCustomBetInput() {
            let customValue = parseFloat(customBetInput.value);
            
            if (customValue && customValue > 0) {
                chipButtons.forEach(btn => btn.classList.remove('active'));
                
                // Prevent negative balances: Ensure bet amount does not exceed balance
                // This check is now only for connected wallet. If not connected, it can go below 0.
                if (realWallet.isConnected) {
                    customValue = Math.min(customValue, realWallet.balance);
                }
                
                state.chipValue = customValue;
                state.currentStake = state.chipValue;
                
                customBetInput.value = customValue.toFixed(2); // Format input value
                customBetInput.style.borderColor = 'var(--accent-green)';
                setTimeout(() => {
                    customBetInput.style.borderColor = '';
                }, 300);
            } else if (customValue <= 0 && customBetInput.value !== '') {
                // If user enters 0 or negative, clear and reset to default
                customBetInput.value = '';
                clearCustomBet();
                showMessageBox('Bet amount must be greater than 0.', 'warning');
            }
        }

        function clearCustomBet() {
            customBetInput.value = '';
            customBetInput.style.borderColor = '';
            
            chipButtons.forEach(btn => btn.classList.remove('active'));
            const defaultChip = document.querySelector('[data-value="1"]');
            if (defaultChip) {
                defaultChip.classList.add('active');
                state.chipValue = 1;
                state.currentStake = 1;
            }
        }

        // UI/UX SAFETY: Auto-Bet Safety Limits - Validate bet amount
        function validateBetAmount(amount) {
            const balance = realWallet.balance || 0;
            // Only check against real wallet balance if connected
            if (realWallet.isConnected && amount > balance) {
                showMessageBox(`Bet amount (${amount.toFixed(3)} SOL) exceeds your balance (${balance.toFixed(3)} SOL)`, 'warning');
                return false;
            }
            if (amount < 0.01) {
                showMessageBox('Minimum bet amount is 0.01 SOL', 'warning');
                return false;
            }
            return true;
        }

        customBetInput.addEventListener('input', handleCustomBetInput);
        customBetInput.addEventListener('blur', () => {
            const value = parseFloat(customBetInput.value);
            if (value && !validateBetAmount(value)) {
                customBetInput.value = '';
                clearCustomBet();
            }
        });

        customBetInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                customBetInput.blur();
                if (state.gameMode === 'solo' && !rollButton.disabled) {
                    rollButton.click();
                }
            }
        });

        clearBetBtn.addEventListener('click', clearCustomBet);

        // QUICK BALANCE REFRESH BUTTON START
        balanceRefreshIcon.addEventListener('click', async () => {
            if (realWallet.isConnected) {
                balanceRefreshIcon.classList.add('fa-spin');
                await realWallet.fetchBalance();
            } else {
                showMessageBox('Connect your wallet to refresh balance.', 'warning');
            }
        });
        // QUICK BALANCE REFRESH BUTTON END

        updateBalanceDisplay();

        realWallet.updateTransactionModals();

        dropdownDepositBtn.addEventListener('click', (e) => {
            e.preventDefault();
            depositModal.style.display = 'flex';
            profileDropdown.classList.remove('show');
            realWallet.updateTransactionModals();
        });

        dropdownWithdrawBtn.addEventListener('click', (e) => {
            e.preventDefault();
            withdrawModal.style.display = 'flex';
            profileDropdown.classList.remove('show');
            realWallet.updateTransactionModals();
        });

        mobileDepositBtn.addEventListener('click', (e) => {
            e.preventDefault();
            depositModal.style.display = 'flex';
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
            realWallet.updateTransactionModals();
        });

        mobileWithdrawBtn.addEventListener('click', (e) => {
            e.preventDefault();
            withdrawModal.style.display = 'flex';
            mobileNavOverlay.classList.remove('show');
            hamburgerMenu.classList.remove('active');
            realWallet.updateTransactionModals();
        });

        document.getElementById('wallet-success-continue').addEventListener('click', () => {
            document.getElementById('wallet-modal').style.display = 'none';
            realWallet.resetModalState();
            realWallet.updateTransactionModals();
        });

        // 15. JavaScript Functionality
        // --- Enhanced Game Statistics ---
        const gameStats = {
            totalGames: 0,
            totalWins: 0,
            totalWagered: 0,
            totalWinnings: 0,
            load: function() {
                this.totalGames = parseInt(localStorage.getItem('totalGames')) || 0;
                this.totalWins = parseInt(localStorage.getItem('totalWins')) || 0;
                this.totalWagered = parseFloat(localStorage.getItem('totalWagered')) || 0;
                this.totalWinnings = parseFloat(localStorage.getItem('totalWinnings')) || 0;
                this.updateDisplay();
            },
            save: function() {
                localStorage.setItem('totalGames', this.totalGames);
                localStorage.setItem('totalWins', this.totalWins);
                localStorage.setItem('totalWagered', this.totalWagered.toFixed(3));
                localStorage.setItem('totalWinnings', this.totalWinnings.toFixed(3));
            },
            addGame: function(wagered, winnings = 0, isWin = false) {
                // This function should only be called if realWallet.isConnected, as per instruction
                this.totalGames++;
                this.totalWagered += wagered;
                if (isWin) {
                    this.totalWins++;
                    this.totalWinnings += winnings;
                }
                this.save();
                this.updateDisplay();
            },
            updateDisplay: function() {
                document.getElementById('total-games').textContent = this.totalGames.toLocaleString();
                document.getElementById('win-rate').textContent = 
                    this.totalGames > 0 ? Math.round((this.totalWins / this.totalGames) * 100) + '%' : '0%';
                document.getElementById('total-wagered').textContent = this.totalWagered.toFixed(3);
                document.getElementById('net-profit').textContent = (this.totalWinnings - this.totalWagered).toFixed(3);
                
                const profitElement = document.getElementById('net-profit');
                const netProfit = this.totalWinnings - this.totalWagered;
                if (netProfit > 0) {
                    profitElement.style.color = 'var(--accent-green)';
                } else if (netProfit < 0) {
                    profitElement.style.color = 'var(--accent-pink)';
                } else {
                    profitElement.style.color = 'var(--text-light)';
                }
            }
        };

        // --- Floating Particles Background ---
        function createFloatingParticles() {
            const particlesContainer = document.getElementById('floating-particles');
            
            function createParticle() {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const size = Math.random() * 4 + 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.left = Math.random() * 100 + '%';
                
                const colors = ['rgba(0, 255, 153, 0.1)', 'rgba(255, 51, 102, 0.1)', 'rgba(157, 78, 221, 0.1)'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                particle.style.animationDuration = (Math.random() * 15 + 10) + 's';
                particle.style.animationDelay = Math.random() * 2 + 's';
                
                particlesContainer.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 25000);
            }
            
            for (let i = 0; i < 5; i++) {
                setTimeout(createParticle, i * 1000);
            }
            
            setInterval(createParticle, 2000);
        }

        // --- Enhanced Dice Animation ---
        function animateDiceEnhanced(diceElements) {
            diceElements.forEach((die, index) => {
                die.classList.add('rolling');
                
                const soundWaves = die.querySelector('.sound-waves');
                if (soundWaves) {
                    soundWaves.classList.add('active');
                    setTimeout(() => {
                        soundWaves.classList.remove('active');
                    }, 1000);
                }
                
                setTimeout(() => {
                    die.classList.remove('rolling');
                }, 1000);
            });
        }

        // --- Live Activity Feed ---
        const liveFeed = {
            items: [
                { type: 'win', message: 'Anonymous won 2.5x on Roll Under 8!' },
                { type: 'loss', message: 'Player123 lost 1.2 SOL on Roll Over 6' },
                { type: 'win', message: 'CryptoKing hit 5.5x multiplier!' },
                { type: 'win', message: 'LuckyPlayer earned 3.2 SOL!' },
                { type: 'loss', message: 'GamblerPro lost streak at 7 wins' }
            ],
            rotationInterval: null, // Initialize to null
            
            show: function() {
                const feedElement = document.getElementById('live-feed');
                feedElement.classList.add('show');
                this.startRotation();
            },
            
            hide: function() {
                const feedElement = document.getElementById('live-feed');
                feedElement.classList.remove('show');
                this.stopRotation();
            },
            
            addItem: function(type, message) {
                this.items.unshift({ type, message });
                if (this.items.length > 10) {
                    this.items.pop();
                }
                this.updateDisplay();
            },
            
            updateDisplay: function() {
                const feedContent = document.getElementById('feed-content');
                feedContent.innerHTML = '';
                this.items.slice(0, 5).forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.className = `feed-item ${item.type}`;
                    itemElement.textContent = item.message;
                    feedContent.appendChild(itemElement);
                });
            },
            
            startRotation: function() {
                this.stopRotation(); // Clear any existing interval first
                this.rotationInterval = setInterval(() => {
                    const types = ['win', 'loss'];
                    const messages = [
                        'Player won big on dice roll!',
                        'Someone hit the jackpot!',
                        'Lucky streak continues...',
                        'Close call - almost won!',
                        'High roller betting big!'
                    ];
                    
                    const randomType = types[Math.floor(Math.random() * types.length)];
                    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                    
                    this.addItem(randomType, randomMessage);
                }, 5000); // Reduced frequency to avoid spam
            },
            
            stopRotation: function() {
                if (this.rotationInterval) {
                    clearInterval(this.rotationInterval);
                    this.rotationInterval = null;
                }
            }
        };

        // Removed setupMobileQuickActions function and its call
        // function setupMobileQuickActions() {
        //     const quickBetButtons = document.querySelectorAll('.quick-bet-btn');
        //     const mobileRollBtn = document.getElementById('mobile-roll-btn');
            
        //     quickBetButtons.forEach(btn => {
        //         btn.addEventListener('click', () => {
        //             const amount = parseFloat(btn.dataset.amount);
        //             state.chipValue = amount;
        //             state.currentStake = amount;
                    
        //             quickBetButtons.forEach(b => b.style.opacity = '0.6');
        //             btn.style.opacity = '1';
                    
        //             const customInput = document.getElementById('custom-bet-input');
        //             if (customInput) {
        //                 customInput.value = amount;
        //             }
        //         });
        //     });
            
        //     mobileRollBtn.addEventListener('click', () => {
        //         if (state.gameMode === 'solo') {
        //             rollDiceSolo();
        //         } else if (state.gameMode === 'duel' && state.activeMatch) {
        //             rollDiceDuel();
        //         }
        //     });
        // }

        // Function to update mobile menu visibility based on wallet connection status
        function updateMobileMenuVisibility() {
            const mobileConnectBtn = document.getElementById('mobile-connect-wallet-btn');
            const mobileDisconnectBtn = document.getElementById('mobile-disconnect-btn');
        
            if (realWallet.isConnected) {
                // Wallet is connected - show disconnect, hide connect
                mobileConnectBtn.style.display = 'none';
                mobileDisconnectBtn.style.display = 'block';
                // Update disconnect button text to show wallet type (optional)
                const walletType = realWallet.walletType ? 
                    realWallet.walletType.charAt(0).toUpperCase() + realWallet.walletType.slice(1) : 
                    '';
                mobileDisconnectBtn.innerHTML = `<i class="fas fa-power-off"></i> Disconnect ${walletType}`;
            } else {
                // Wallet is not connected - show connect, hide disconnect
                mobileConnectBtn.style.display = 'block';
                mobileDisconnectBtn.style.display = 'none';
                // Reset disconnect button text
                mobileDisconnectBtn.innerHTML = `<i class="fas fa-power-off"></i> Disconnect`;
            }
        }

        // Initialize enhanced features
        gameStats.load();
        createFloatingParticles();
        updateMobileMenuVisibility(); // Add this line to set initial state
        // Removed setupMobileQuickActions() call
        // setupMobileQuickActions();

        // Show live feed on desktop
        if (window.innerWidth > 768) {
            setTimeout(() => liveFeed.show(), 2000);
        }

        // AUTO-BET FEATURE START
        function toggleAutoBetSettings() {
            autoBetSettings.classList.toggle('show');
            autoBetToggle.classList.toggle('active');
            playUISound();
        }

        function startAutoBet() {
            if (!realWallet.isConnected) {
                showMessageBox('Connect wallet to use Auto Bet!', 'error');
                autoBetCheckbox.checked = false;
                return;
            }
            if (!validateBetAmount(state.chipValue)) {
                showMessageBox('Invalid bet amount for Auto Bet. Please adjust.', 'error');
                autoBetCheckbox.checked = false;
                return;
            }

            state.autoBet.isActive = true;
            state.autoBet.count = parseInt(autoBetCountInput.value) || 1;
            state.autoBet.delay = parseInt(autoBetDelayInput.value) || 1000;
            state.autoBet.stopOnWin = autoBetStopWinCheckbox.checked;
            state.autoBet.stopOnLoss = autoBetStopLossCheckbox.checked;
            state.autoBet.currentBet = 0;

            rollButton.disabled = true; // Disable manual roll button
            autoBetCheckbox.disabled = true; // Disable auto-bet toggle during active session

            updateAutoBetProgress();
            showMessageBox(`Auto Bet started for ${state.autoBet.count} rolls.`, 'info');
            state.autoBet.intervalId = setTimeout(rollDiceSolo, state.autoBet.delay);
        }

        function stopAutoBet() {
            if (state.autoBet.intervalId) {
                clearTimeout(state.autoBet.intervalId);
                state.autoBet.intervalId = null;
            }
            state.autoBet.isActive = false;
            rollButton.disabled = false; // Re-enable manual roll button
            autoBetCheckbox.disabled = false; // Re-enable auto-bet toggle
            updateAutoBetProgress();
            showMessageBox('Auto Bet stopped.', 'info');
        }

        function updateAutoBetProgress() {
            autoBetProgressDisplay.innerHTML = `Progress: <strong>${state.autoBet.currentBet}</strong> / <strong>${state.autoBet.count}</strong>`;
        }

        autoBetToggle.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') { // Prevent double-triggering from checkbox click
                autoBetCheckbox.checked = !autoBetCheckbox.checked;
            }
            if (autoBetCheckbox.checked) {
                startAutoBet();
            } else {
                autoBetSettings.classList.remove('show');
                autoBetToggle.classList.remove('active');
                stopAutoBet();
            }
        });

        autoBetCheckbox.addEventListener('change', () => {
            if (autoBetCheckbox.checked) {
                startAutoBet();
            } else {
                stopAutoBet();
            }
        });

        // Initialize auto-bet UI state
        autoBetCheckbox.checked = state.autoBet.isActive;
        if (state.autoBet.isActive) {
            autoBetSettings.classList.add('show');
            autoBetToggle.classList.add('active');
        }
        autoBetCountInput.value = state.autoBet.count;
        autoBetDelayInput.value = state.autoBet.delay;
        autoBetStopWinCheckbox.checked = state.autoBet.stopOnWin;
        autoBetStopLossCheckbox.checked = state.autoBet.stopOnLoss;
        updateAutoBetProgress();
        // AUTO-BET FEATURE END

        // SOUND TOGGLE IN SETTINGS START
        function loadSoundSettings() {
            masterVolumeSlider.value = state.soundSettings.masterVolume;
            rollSoundToggle.checked = state.soundSettings.rollSound;
            resultSoundToggle.checked = state.soundSettings.resultSound;
            uiSoundToggle.checked = state.soundSettings.uiSound;

            // Apply volume to all sounds
            rollSound.volume = state.soundSettings.masterVolume;
            winSound.volume = state.soundSettings.masterVolume;
            lossSound.volume = state.soundSettings.masterVolume;
            uiSound.volume = state.soundSettings.masterVolume;
        }

        function saveSoundSettings() {
            state.soundSettings.masterVolume = parseFloat(masterVolumeSlider.value);
            state.soundSettings.rollSound = rollSoundToggle.checked;
            state.soundSettings.resultSound = resultSoundToggle.checked;
            state.soundSettings.uiSound = uiSoundToggle.checked;

            localStorage.setItem('masterVolume', state.soundSettings.masterVolume);
            localStorage.setItem('rollSound', state.soundSettings.rollSound);
            localStorage.setItem('resultSound', state.soundSettings.resultSound);
            localStorage.setItem('uiSound', state.soundSettings.uiSound);

            loadSoundSettings(); // Apply new settings immediately
            showMessageBox('Sound settings saved!', 'success');
            playUISound();
        }

        masterVolumeSlider.addEventListener('input', () => {
            state.soundSettings.masterVolume = parseFloat(masterVolumeSlider.value);
            loadSoundSettings(); // Apply volume changes immediately
        });

        rollSoundToggle.addEventListener('change', playUISound);
        resultSoundToggle.addEventListener('change', playUISound);
        uiSoundToggle.addEventListener('change', playUISound);

        saveSettingsBtn.addEventListener('click', saveSoundSettings);

        loadSoundSettings(); // Initial load of sound settings
        // SOUND TOGGLE IN SETTINGS END

        // REAL-TIME NOTIFICATION SYSTEM START
        const notificationContainer = document.getElementById('notification-container');

        // Removed showNotification function as per instructions to eliminate notification spam.
        // Keeping a placeholder for showMessageBox for critical user feedback that is not spammy.
        /*
        function showNotification(message, type = 'info', actions = [], duration = 5000) {
            const notification = document.createElement('div');
            notification.className = `toast-notification ${type}`;
            
            let icon = '';
            if (type === 'success') icon = '<i class="fas fa-check-circle"></i>';
            else if (type === 'error') icon = '<i class="fas fa-times-circle"></i>';
            else if (type === 'warning') icon = '<i class="fas fa-exclamation-triangle"></i>';
            else if (type === 'info') icon = '<i class="fas fa-info-circle"></i>';

            let actionButtonsHtml = '';
            if (actions && actions.length > 0) {
                actionButtonsHtml = `<div class="actions">
                    ${actions.map(action => `<button class="action-btn" data-action="${action.name}">${action.label}</button>`).join('')}
                </div>`;
            }

            notification.innerHTML = `
                ${icon}
                <div class="content">
                    <div class="title">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
                    <div class="message">${message}</div>
                    ${actionButtonsHtml}
                </div>
                <button class="close-btn">&times;</button>
            `;

            notificationContainer.appendChild(notification);

            // Trigger slide-in animation
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 50); // Small delay to ensure CSS transition applies

            // Auto-dismiss
            const dismissTimeout = setTimeout(() => {
                dismissNotification(notification);
            }, duration);

            // Close button listener
            notification.querySelector('.close-btn').addEventListener('click', () => {
                clearTimeout(dismissTimeout); // Clear auto-dismiss if manually closed
                dismissNotification(notification);
            });

            // Action button listeners
            notification.querySelectorAll('.action-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const actionName = button.dataset.action;
                    const action = actions.find(a => a.name === actionName);
                    if (action && typeof action.callback === 'function') {
                        action.callback();
                    }
                    clearTimeout(dismissTimeout);
                    dismissNotification(notification);
                });
            });
        }

        function dismissNotification(notificationElement) {
            notificationElement.style.opacity = '0';
            notificationElement.style.transform = 'translateX(100%)';
            setTimeout(() => {
                notificationElement.remove();
            }, 400); // Match CSS transition duration
        }
        */

        // Mock WebSocket for real-time updates - Removed setInterval for notifications
        let mockWebSocketInterval;
        function startMockWebSocket() {
            // This interval is removed as per instruction to eliminate notification spam
            // mockWebSocketInterval = setInterval(() => {
            //     const messages = [
            //         { type: 'info', message: 'New game update available!' },
            //         { type: 'success', message: 'A player just hit a massive multiplier!' },
            //         { type: 'warning', message: 'High network latency detected.' },
            //         { type: 'error', message: 'Failed to connect to game server. Retrying...' },
            //         { type: 'info', message: 'Daily challenge reset! New rewards await.', actions: [{ name: 'viewChallenge', label: 'View Challenge', callback: () => {
            //             console.log('Opening daily challenge panel...');
            //         }}] }
            //     ];
            //     const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            //     console.log('Mock WebSocket message:', randomMessage.message); // Log instead of showNotification
            // }, 15000); // Every 15 seconds
        }
        startMockWebSocket(); // Call to initialize, but the interval itself is removed
        // REAL-TIME NOTIFICATION SYSTEM END

        // FRIENDS SECTION START
        let mockFriends = JSON.parse(localStorage.getItem('mockFriends')) || [
            { id: 'friend1', username: 'DegenPal', avatar: '😎', online: true, winRate: '65%', lastSeen: 'now' },
            { id: 'friend2', username: 'LuckyLuke', avatar: '🍀', online: false, winRate: '58%', lastSeen: '2h ago' },
            { id: 'friend3', username: 'CryptoQueen', avatar: '👑', online: true, winRate: '72%', lastSeen: 'now' },
            { id: 'friend4', username: 'SolanaSam', avatar: '🚀', online: false, winRate: '40%', lastSeen: '1d ago' }
        ];

        function saveFriends() {
            localStorage.setItem('mockFriends', JSON.stringify(mockFriends));
        }

        function renderFriendsList(filter = '') {
            friendsList.innerHTML = '';
            const filteredFriends = mockFriends.filter(friend => 
                friend.username.toLowerCase().includes(filter.toLowerCase()) ||
                friend.id.toLowerCase().includes(filter.toLowerCase())
            );

            if (filteredFriends.length === 0 && filter) {
                const noResults = document.createElement('li');
                noResults.textContent = 'No friends found matching your search.';
                noResults.style.textAlign = 'center';
                noResults.style.opacity = '0.7';
                noResults.style.padding = '1rem';
                friendsList.appendChild(noResults);
                return;
            }

            filteredFriends.forEach(friend => {
                const listItem = document.createElement('li');
                listItem.className = 'friend-item';
                listItem.innerHTML = `
                    <div class="friend-info">
                        <span class="friend-avatar">${friend.avatar}</span>
                        <div>
                            <div class="friend-name">${friend.username}</div>
                            <div class="friend-status ${friend.online ? 'online' : ''}">
                                ${friend.online ? 'Online' : `Last seen: ${friend.lastSeen}`}
                            </div>
                            <div class="friend-win-rate">Win Rate: ${friend.winRate}</div>
                        </div>
                    </div>
                    <div class="friend-actions">
                        <button class="duel-btn" data-friend-id="${friend.id}">Duel</button>
                        <button class="remove-btn" data-friend-id="${friend.id}">Remove</button>
                    </div>
                `;
                friendsList.appendChild(listItem);
            });

            // Add event listeners for duel and remove buttons
            friendsList.querySelectorAll('.duel-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const friendId = e.target.dataset.friendId;
                    const friend = mockFriends.find(f => f.id === friendId);
                    if (friend) {
                        showMessageBox(`Inviting ${friend.username} to a duel!`, 'info');
                        // Simulate duel invitation logic
                    }
                });
            });

            friendsList.querySelectorAll('.remove-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const friendId = e.target.dataset.friendId;
                    removeFriend(friendId);
                });
            });
        }

        function addFriend(id, username, avatar) {
            if (mockFriends.some(f => f.id === id)) {
                showMessageBox(`Friend with ID ${id} already exists!`, 'warning');
                return;
            }
            const newFriend = {
                id: id,
                username: username,
                avatar: avatar,
                online: false, // Default to offline
                winRate: '0%', // Default win rate
                lastSeen: 'just now'
            };
            mockFriends.push(newFriend);
            saveFriends();
            renderFriendsList();
            showMessageBox(`${username} added to your friends list!`, 'success');
        }

        function removeFriend(id) {
            mockFriends = mockFriends.filter(friend => friend.id !== id);
            saveFriends();
            renderFriendsList();
            showMessageBox('Friend removed.', 'info');
        }

        friendSearchInput.addEventListener('input', (e) => {
            renderFriendsList(e.target.value.trim());
        });

        addFriendByIdBtn.addEventListener('click', () => {
            const friendId = friendSearchInput.value.trim();
            if (friendId && friendId !== mockAuth.currentUser.uid) {
                // Simulate finding a user by ID
                const potentialFriend = mockLeaderboardData.find(p => p.id === friendId);
                if (potentialFriend) {
                    addFriend(potentialFriend.id, potentialFriend.username, potentialFriend.avatar);
                    friendSearchInput.value = ''; // Clear input
                } else {
                    showMessageBox('User not found with that ID.', 'warning');
                }
            } else if (friendId === mockAuth.currentUser.uid) {
                showMessageBox('You cannot add yourself as a friend.', 'warning');
            } else {
                showMessageBox('Please enter a friend ID.', 'warning');
            }
        });

        renderFriendsList(); // Initial render of friends list
        // FRIENDS SECTION END

        // HISTORY/RECORDS SECTION START
        const gameHistory = {
            data: state.gameHistory,
            filters: {
                mode: 'all',
                outcome: 'all',
                date: ''
            },
            currentPage: 1,
            rowsPerPage: 10,

            save: function() {
                localStorage.setItem('gameHistory', JSON.stringify(this.data));
            },

            addGameEntry: function(entry) {
                this.data.unshift(entry); // Add to the beginning
                this.save();
                this.renderHistory(); // Re-render history table
            },

            applyFilters: function() {
                const mode = historyFilterMode.value;
                const outcome = historyFilterOutcome.value;
                const date = historyFilterDate.value;

                this.filters.mode = mode;
                this.filters.outcome = outcome;
                this.filters.date = date;
                this.currentPage = 1; // Reset to first page on filter change
                this.renderHistory();
            },

            renderHistory: function() {
                gameHistoryTableBody.innerHTML = '';
                let filteredData = [...this.data];

                if (this.filters.mode !== 'all') {
                    filteredData = filteredData.filter(entry => entry.mode === this.filters.mode);
                }
                if (this.filters.outcome !== 'all') {
                    filteredData = filteredData.filter(entry => entry.outcome.toLowerCase() === this.filters.outcome.toLowerCase());
                }
                if (this.filters.date) {
                    filteredData = filteredData.filter(entry => {
                        const entryDate = new Date(entry.date).toISOString().split('T')[0];
                        return entryDate === this.filters.date;
                    });
                }

                const totalPages = Math.ceil(filteredData.length / this.rowsPerPage);
                historyPageInfo.textContent = `Page ${this.currentPage} of ${totalPages || 1}`;

                const startIndex = (this.currentPage - 1) * this.rowsPerPage;
                const endIndex = startIndex + this.rowsPerPage;
                const paginatedData = filteredData.slice(startIndex, endIndex);

                paginatedData.forEach(entry => {
                    const row = document.createElement('tr');
                    row.className = entry.outcome.toLowerCase() === 'win' ? 'win-entry' : (entry.outcome.toLowerCase() === 'loss' ? 'loss-entry' : '');
                    row.innerHTML = `
                        <td>${new Date(entry.date).toLocaleString()}</td>
                        <td>${entry.mode.charAt(0).toUpperCase() + entry.mode.slice(1)}</td>
                        <td>${entry.bet.toFixed(2)} SOL</td>
                        <td>${entry.roll}</td>
                        <td>${entry.mode === 'solo' ? (entry.outcome === 'WIN' ? '&lt; ' + entry.target : '&gt; ' + entry.target) : entry.target}</td>
                        <td>${entry.outcome}</td>
                        <td>${entry.payoutLoss > 0 ? '+' : ''}${entry.payoutLoss.toFixed(2)} SOL</td>
                    `;
                    gameHistoryTableBody.appendChild(row);
                });

                historyPrevPageBtn.disabled = this.currentPage === 1;
                historyNextPageBtn.disabled = this.currentPage === totalPages || totalPages === 0;
            },

            nextPage: function() {
                const filteredData = this.data.filter(entry => {
                    const modeMatch = this.filters.mode === 'all' || entry.mode === this.filters.mode;
                    const outcomeMatch = this.filters.outcome === 'all' || entry.outcome.toLowerCase() === this.filters.outcome.toLowerCase();
                    const dateMatch = !this.filters.date || new Date(entry.date).toISOString().split('T')[0] === this.filters.date;
                    return modeMatch && outcomeMatch && dateMatch;
                });
                const totalPages = Math.ceil(filteredData.length / this.rowsPerPage);
                if (this.currentPage < totalPages) {
                    this.currentPage++;
                    this.renderHistory();
                }
            },

            prevPage: function() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderHistory();
                }
            },

            exportToCsv: function() {
                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "Date,Mode,Bet,Roll,Target,Outcome,Payout/Loss\n"; // Header row

                const filteredData = this.data.filter(entry => {
                    const modeMatch = this.filters.mode === 'all' || entry.mode === this.filters.mode;
                    const outcomeMatch = this.filters.outcome === 'all' || entry.outcome.toLowerCase() === this.filters.outcome.toLowerCase();
                    const dateMatch = !this.filters.date || new Date(entry.date).toISOString().split('T')[0] === this.filters.date;
                    return modeMatch && outcomeMatch && dateMatch;
                });

                filteredData.forEach(entry => {
                    const row = [
                        `"${new Date(entry.date).toLocaleString()}"`,
                        `"${entry.mode.charAt(0).toUpperCase() + entry.mode.slice(1)}"`,
                        `"${entry.bet.toFixed(2)} SOL"`,
                        `"${entry.roll}"`,
                        `"${entry.mode === 'solo' ? (entry.outcome === 'WIN' ? '< ' + entry.target : '> ' + entry.target) : entry.target}"`,
                        `"${entry.outcome}"`,
                        `"${entry.payoutLoss > 0 ? '+' : ''}${entry.payoutLoss.toFixed(2)} SOL"`
                    ].join(',');
                    csvContent += row + "\n";
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "degen-dice-history.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessageBox('Game history exported to CSV!', 'success');
            }
        };

        const personalRecords = {
            data: state.personalRecords,

            save: function() {
                localStorage.setItem('personalRecords', JSON.stringify(this.data));
            },

            updateRecords: function(gameEntry) {
                // Update total games and wagered
                this.data.totalGamesPlayed++;
                this.data.totalWageredSum += gameEntry.bet;
                this.data.netProfitSum += gameEntry.payoutLoss;

                // Update biggest win
                if (gameEntry.outcome === 'WIN' && gameEntry.payoutLoss > this.data.biggestWin) {
                    this.data.biggestWin = gameEntry.payoutLoss;
                }

                // Update longest win streak
                if (gameEntry.outcome === 'WIN') {
                    this.data.longestWinStreak = Math.max(this.data.longestWinStreak, state.streak); // Use global streak
                } else {
                    // Streak is reset in the main game logic, so no need to manage it here
                }

                // Update highest multiplier
                if (gameEntry.outcome === 'WIN' && gameEntry.multiplier > this.data.highestMultiplier) {
                    this.data.highestMultiplier = gameEntry.multiplier;
                }
                this.save();
                this.updateDisplay();
            },

            updateDisplay: function() {
                recordBiggestWin.textContent = `${this.data.biggestWin.toFixed(2)} SOL`;
                recordLongestStreak.textContent = `${this.data.longestWinStreak}`;
                recordHighestMultiplier.textContent = `${this.data.highestMultiplier.toFixed(1)}x`;
                recordTotalGamesPlayed.textContent = `${this.data.totalGamesPlayed}`;
                recordTotalWageredSum.textContent = `${this.data.totalWageredSum.toFixed(2)} SOL`;
                recordNetProfitSum.textContent = `${this.data.netProfitSum.toFixed(2)} SOL`;

                const netProfitElement = recordNetProfitSum;
                const netProfit = this.data.netProfitSum;
                if (netProfit > 0) {
                    netProfitElement.style.color = 'var(--accent-green)';
                } else if (netProfit < 0) {
                    netProfitElement.style.color = 'var(--accent-pink)';
                } else {
                    netProfitElement.style.color = 'var(--text-light)';
                }
            }
        };

        gameHistoryTab.addEventListener('click', () => {
            gameHistoryTab.classList.add('active');
            personalRecordsTab.classList.remove('active');
            gameHistoryContent.classList.add('active');
            personalRecordsContent.classList.remove('active');
            gameHistory.renderHistory();
        });

        personalRecordsTab.addEventListener('click', () => {
            personalRecordsTab.classList.add('active');
            gameHistoryTab.classList.remove('active');
            personalRecordsContent.classList.add('active');
            gameHistoryContent.classList.remove('active');
            personalRecords.updateDisplay();
        });

        historyApplyFiltersBtn.addEventListener('click', () => gameHistory.applyFilters());
        historyExportCsvBtn.addEventListener('click', () => gameHistory.exportToCsv());
        historyPrevPageBtn.addEventListener('click', () => gameHistory.prevPage());
        historyNextPageBtn.addEventListener('click', () => gameHistory.nextPage());

        // Initial render for history and records
        gameHistory.renderHistory();
        personalRecords.updateDisplay();
        // HISTORY/RECORDS SECTION END

        // PREDEFINED AVATAR SELECTION START
        function renderAvatarSelectionGrid() {
            avatarSelectionGrid.innerHTML = '';
            predefinedAvatars.forEach(avatar => {
                const avatarOption = document.createElement('div');
                avatarOption.className = 'avatar-option';
                avatarOption.textContent = avatar;
                avatarOption.dataset.avatar = avatar; // Store the emoji itself
                
                if (localStorage.getItem('avatar') === avatar) {
                    avatarOption.classList.add('selected');
                }

                avatarOption.addEventListener('click', () => {
                    selectAvatarInGrid(avatar);
                    localStorage.setItem('avatar', avatar);
                    loadProfile(); // Update profile display immediately
                    playUISound();
                });
                avatarSelectionGrid.appendChild(avatarOption);
            });
        }

        function selectAvatarInGrid(selectedAvatar) {
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.avatar === selectedAvatar) {
                    option.classList.add('selected');
                }
            });
            customAvatarInput.value = ''; // Clear custom input when a predefined avatar is selected
        }

        setCustomAvatarBtn.addEventListener('click', () => {
            const customValue = customAvatarInput.value.trim();
            if (customValue) {
                // Basic validation for emoji or URL
                const isEmoji = /\p{Emoji}/u.test(customValue);
                const isUrl = customValue.startsWith('http://') || customValue.startsWith('https://');

                if (isEmoji || isUrl) {
                    localStorage.setItem('avatar', customValue);
                    loadProfile(); // Update profile display immediately
                    renderAvatarSelectionGrid(); // Re-render to deselect any predefined
                    showMessageBox('Custom avatar set!', 'success');
                    playUISound();
                } else {
                    showMessageBox('Invalid custom avatar. Please use an emoji or a valid image URL.', 'error');
                }
            } else {
                showMessageBox('Please enter an emoji or image URL.', 'warning');
            }
        });

        // Initial render of avatar selection grid
        renderAvatarSelectionGrid();
        // PREDEFINED AVATAR SELECTION END

    </script>
</body>
</html>
